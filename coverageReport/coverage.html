
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TheAlgorithms/Go/cache/lfu.go (100.0%)</option>
				
				<option value="file1">github.com/TheAlgorithms/Go/cache/lru.go (100.0%)</option>
				
				<option value="file2">github.com/TheAlgorithms/Go/cipher/caesar/caesar.go (100.0%)</option>
				
				<option value="file3">github.com/TheAlgorithms/Go/cipher/diffiehellman/diffiehellmankeyexchange.go (91.7%)</option>
				
				<option value="file4">github.com/TheAlgorithms/Go/cipher/polybius/polybius.go (93.5%)</option>
				
				<option value="file5">github.com/TheAlgorithms/Go/cipher/rot13/rot13.go (100.0%)</option>
				
				<option value="file6">github.com/TheAlgorithms/Go/cipher/rsa/rsa.go (85.7%)</option>
				
				<option value="file7">github.com/TheAlgorithms/Go/cipher/transposition/transposition.go (91.5%)</option>
				
				<option value="file8">github.com/TheAlgorithms/Go/cipher/xor/xor.go (100.0%)</option>
				
				<option value="file9">github.com/TheAlgorithms/Go/compression/huffmancoding.go (95.6%)</option>
				
				<option value="file10">github.com/TheAlgorithms/Go/conversion/base64.go (100.0%)</option>
				
				<option value="file11">github.com/TheAlgorithms/Go/conversion/binarytodecimal.go (80.0%)</option>
				
				<option value="file12">github.com/TheAlgorithms/Go/conversion/decimaltobinary.go (92.3%)</option>
				
				<option value="file13">github.com/TheAlgorithms/Go/conversion/inttoroman.go (100.0%)</option>
				
				<option value="file14">github.com/TheAlgorithms/Go/conversion/rgbhex.go (100.0%)</option>
				
				<option value="file15">github.com/TheAlgorithms/Go/conversion/romantoint.go (100.0%)</option>
				
				<option value="file16">github.com/TheAlgorithms/Go/dynamic/abbreviation.go (100.0%)</option>
				
				<option value="file17">github.com/TheAlgorithms/Go/dynamic/binomialcoefficient.go (100.0%)</option>
				
				<option value="file18">github.com/TheAlgorithms/Go/dynamic/catalan.go (100.0%)</option>
				
				<option value="file19">github.com/TheAlgorithms/Go/dynamic/coinchange.go (100.0%)</option>
				
				<option value="file20">github.com/TheAlgorithms/Go/dynamic/editdistance.go (72.0%)</option>
				
				<option value="file21">github.com/TheAlgorithms/Go/dynamic/fibonacci.go (100.0%)</option>
				
				<option value="file22">github.com/TheAlgorithms/Go/dynamic/knapsack.go (100.0%)</option>
				
				<option value="file23">github.com/TheAlgorithms/Go/dynamic/longestcommonsubsequence.go (100.0%)</option>
				
				<option value="file24">github.com/TheAlgorithms/Go/dynamic/longestincreasingsubsequence.go (100.0%)</option>
				
				<option value="file25">github.com/TheAlgorithms/Go/dynamic/longestincreasingsubsequencegreedy.go (100.0%)</option>
				
				<option value="file26">github.com/TheAlgorithms/Go/dynamic/longestpalindromicsubsequence.go (100.0%)</option>
				
				<option value="file27">github.com/TheAlgorithms/Go/dynamic/matrixmultiplication.go (0.0%)</option>
				
				<option value="file28">github.com/TheAlgorithms/Go/dynamic/rodcutting.go (100.0%)</option>
				
				<option value="file29">github.com/TheAlgorithms/Go/dynamic/subsetsum.go (100.0%)</option>
				
				<option value="file30">github.com/TheAlgorithms/Go/graph/articulationpoints.go (100.0%)</option>
				
				<option value="file31">github.com/TheAlgorithms/Go/graph/bellmanford.go (100.0%)</option>
				
				<option value="file32">github.com/TheAlgorithms/Go/graph/breadthfirstsearch.go (100.0%)</option>
				
				<option value="file33">github.com/TheAlgorithms/Go/graph/coloring/backtracking.go (90.5%)</option>
				
				<option value="file34">github.com/TheAlgorithms/Go/graph/coloring/bfs.go (100.0%)</option>
				
				<option value="file35">github.com/TheAlgorithms/Go/graph/coloring/bipartite.go (100.0%)</option>
				
				<option value="file36">github.com/TheAlgorithms/Go/graph/coloring/graph.go (100.0%)</option>
				
				<option value="file37">github.com/TheAlgorithms/Go/graph/coloring/greedy.go (94.1%)</option>
				
				<option value="file38">github.com/TheAlgorithms/Go/graph/cycle.go (93.2%)</option>
				
				<option value="file39">github.com/TheAlgorithms/Go/graph/depthfirstsearch.go (96.6%)</option>
				
				<option value="file40">github.com/TheAlgorithms/Go/graph/dijkstra.go (100.0%)</option>
				
				<option value="file41">github.com/TheAlgorithms/Go/graph/floydwarshall.go (100.0%)</option>
				
				<option value="file42">github.com/TheAlgorithms/Go/graph/graph.go (100.0%)</option>
				
				<option value="file43">github.com/TheAlgorithms/Go/graph/kruskal.go (100.0%)</option>
				
				<option value="file44">github.com/TheAlgorithms/Go/graph/lowestcommonancestor.go (100.0%)</option>
				
				<option value="file45">github.com/TheAlgorithms/Go/graph/topological.go (100.0%)</option>
				
				<option value="file46">github.com/TheAlgorithms/Go/graph/unionfind.go (94.7%)</option>
				
				<option value="file47">github.com/TheAlgorithms/Go/hashing/sha256/sha256.go (100.0%)</option>
				
				<option value="file48">github.com/TheAlgorithms/Go/math/abs.go (100.0%)</option>
				
				<option value="file49">github.com/TheAlgorithms/Go/math/aliquotsum.go (100.0%)</option>
				
				<option value="file50">github.com/TheAlgorithms/Go/math/armstrong/isarmstrong.go (100.0%)</option>
				
				<option value="file51">github.com/TheAlgorithms/Go/math/binary/abs.go (100.0%)</option>
				
				<option value="file52">github.com/TheAlgorithms/Go/math/binary/arithmeticmean.go (100.0%)</option>
				
				<option value="file53">github.com/TheAlgorithms/Go/math/binary/bitcounter.go (100.0%)</option>
				
				<option value="file54">github.com/TheAlgorithms/Go/math/binary/checkisnumberpoweroftwo.go (100.0%)</option>
				
				<option value="file55">github.com/TheAlgorithms/Go/math/binary/fast_inverse_sqrt.go (100.0%)</option>
				
				<option value="file56">github.com/TheAlgorithms/Go/math/binary/logarithm.go (100.0%)</option>
				
				<option value="file57">github.com/TheAlgorithms/Go/math/binary/rbc.go (100.0%)</option>
				
				<option value="file58">github.com/TheAlgorithms/Go/math/binary/reversebits.go (100.0%)</option>
				
				<option value="file59">github.com/TheAlgorithms/Go/math/binary/sqrt.go (100.0%)</option>
				
				<option value="file60">github.com/TheAlgorithms/Go/math/binary/xorsearch.go (100.0%)</option>
				
				<option value="file61">github.com/TheAlgorithms/Go/math/binomialcoefficient.go (100.0%)</option>
				
				<option value="file62">github.com/TheAlgorithms/Go/math/catalan/catalannumber.go (100.0%)</option>
				
				<option value="file63">github.com/TheAlgorithms/Go/math/checkisnumberpoweroftwo.go (100.0%)</option>
				
				<option value="file64">github.com/TheAlgorithms/Go/math/cos.go (100.0%)</option>
				
				<option value="file65">github.com/TheAlgorithms/Go/math/eulertotient.go (100.0%)</option>
				
				<option value="file66">github.com/TheAlgorithms/Go/math/factorial/factorial.go (86.4%)</option>
				
				<option value="file67">github.com/TheAlgorithms/Go/math/fibonacci/fibonacci.go (100.0%)</option>
				
				<option value="file68">github.com/TheAlgorithms/Go/math/gcd/extended.go (100.0%)</option>
				
				<option value="file69">github.com/TheAlgorithms/Go/math/gcd/extendedgcd.go (100.0%)</option>
				
				<option value="file70">github.com/TheAlgorithms/Go/math/gcd/extendedgcditerative.go (100.0%)</option>
				
				<option value="file71">github.com/TheAlgorithms/Go/math/gcd/gcd.go (100.0%)</option>
				
				<option value="file72">github.com/TheAlgorithms/Go/math/gcd/gcditerative.go (100.0%)</option>
				
				<option value="file73">github.com/TheAlgorithms/Go/math/geometry/distance.go (100.0%)</option>
				
				<option value="file74">github.com/TheAlgorithms/Go/math/geometry/straightlines.go (100.0%)</option>
				
				<option value="file75">github.com/TheAlgorithms/Go/math/isautomorphic.go (100.0%)</option>
				
				<option value="file76">github.com/TheAlgorithms/Go/math/krishnamurthy.go (100.0%)</option>
				
				<option value="file77">github.com/TheAlgorithms/Go/math/kthnumber.go (94.1%)</option>
				
				<option value="file78">github.com/TheAlgorithms/Go/math/lcm/lcm.go (100.0%)</option>
				
				<option value="file79">github.com/TheAlgorithms/Go/math/lerp.go (100.0%)</option>
				
				<option value="file80">github.com/TheAlgorithms/Go/math/liouville.go (100.0%)</option>
				
				<option value="file81">github.com/TheAlgorithms/Go/math/matrix/add.go (82.1%)</option>
				
				<option value="file82">github.com/TheAlgorithms/Go/math/matrix/checkequal.go (100.0%)</option>
				
				<option value="file83">github.com/TheAlgorithms/Go/math/matrix/copy.go (78.6%)</option>
				
				<option value="file84">github.com/TheAlgorithms/Go/math/matrix/isvalid.go (100.0%)</option>
				
				<option value="file85">github.com/TheAlgorithms/Go/math/matrix/matchdimensions.go (100.0%)</option>
				
				<option value="file86">github.com/TheAlgorithms/Go/math/matrix/matrix.go (97.2%)</option>
				
				<option value="file87">github.com/TheAlgorithms/Go/math/matrix/multiply.go (72.5%)</option>
				
				<option value="file88">github.com/TheAlgorithms/Go/math/matrix/strassenmatrixmultiply.go (69.1%)</option>
				
				<option value="file89">github.com/TheAlgorithms/Go/math/matrix/string.go (100.0%)</option>
				
				<option value="file90">github.com/TheAlgorithms/Go/math/matrix/submatrix.go (72.2%)</option>
				
				<option value="file91">github.com/TheAlgorithms/Go/math/matrix/subtract.go (82.1%)</option>
				
				<option value="file92">github.com/TheAlgorithms/Go/math/max/bitwisemax.go (100.0%)</option>
				
				<option value="file93">github.com/TheAlgorithms/Go/math/max/max.go (100.0%)</option>
				
				<option value="file94">github.com/TheAlgorithms/Go/math/mean.go (100.0%)</option>
				
				<option value="file95">github.com/TheAlgorithms/Go/math/median.go (100.0%)</option>
				
				<option value="file96">github.com/TheAlgorithms/Go/math/min/bitwisemin.go (100.0%)</option>
				
				<option value="file97">github.com/TheAlgorithms/Go/math/min/min.go (100.0%)</option>
				
				<option value="file98">github.com/TheAlgorithms/Go/math/mobius.go (100.0%)</option>
				
				<option value="file99">github.com/TheAlgorithms/Go/math/mode.go (100.0%)</option>
				
				<option value="file100">github.com/TheAlgorithms/Go/math/modular/exponentiation.go (88.9%)</option>
				
				<option value="file101">github.com/TheAlgorithms/Go/math/modular/inverse.go (100.0%)</option>
				
				<option value="file102">github.com/TheAlgorithms/Go/math/moserdebruijnsequence/sequence.go (100.0%)</option>
				
				<option value="file103">github.com/TheAlgorithms/Go/math/pascal/pascaltriangle.go (100.0%)</option>
				
				<option value="file104">github.com/TheAlgorithms/Go/math/perfectnumber.go (100.0%)</option>
				
				<option value="file105">github.com/TheAlgorithms/Go/math/permutation/heaps.go (100.0%)</option>
				
				<option value="file106">github.com/TheAlgorithms/Go/math/pi/montecarlopi.go (97.4%)</option>
				
				<option value="file107">github.com/TheAlgorithms/Go/math/pi/spigotpi.go (100.0%)</option>
				
				<option value="file108">github.com/TheAlgorithms/Go/math/pollard.go (100.0%)</option>
				
				<option value="file109">github.com/TheAlgorithms/Go/math/power/fastexponent.go (100.0%)</option>
				
				<option value="file110">github.com/TheAlgorithms/Go/math/power/powvialogarithm.go (100.0%)</option>
				
				<option value="file111">github.com/TheAlgorithms/Go/math/prime/millerrabintest.go (55.6%)</option>
				
				<option value="file112">github.com/TheAlgorithms/Go/math/prime/primecheck.go (100.0%)</option>
				
				<option value="file113">github.com/TheAlgorithms/Go/math/prime/primefactorization.go (100.0%)</option>
				
				<option value="file114">github.com/TheAlgorithms/Go/math/prime/sieve.go (100.0%)</option>
				
				<option value="file115">github.com/TheAlgorithms/Go/math/prime/twin.go (100.0%)</option>
				
				<option value="file116">github.com/TheAlgorithms/Go/math/pronicnumber.go (100.0%)</option>
				
				<option value="file117">github.com/TheAlgorithms/Go/math/pythagoras/pythagoras.go (100.0%)</option>
				
				<option value="file118">github.com/TheAlgorithms/Go/math/sin.go (100.0%)</option>
				
				<option value="file119">github.com/TheAlgorithms/Go/other/maxsubarraysum/maxsubarraysum.go (100.0%)</option>
				
				<option value="file120">github.com/TheAlgorithms/Go/other/nested/nestedbrackets.go (100.0%)</option>
				
				<option value="file121">github.com/TheAlgorithms/Go/search/binary.go (100.0%)</option>
				
				<option value="file122">github.com/TheAlgorithms/Go/search/interpolation.go (66.7%)</option>
				
				<option value="file123">github.com/TheAlgorithms/Go/search/jump.go (95.0%)</option>
				
				<option value="file124">github.com/TheAlgorithms/Go/search/jump2.go (100.0%)</option>
				
				<option value="file125">github.com/TheAlgorithms/Go/search/linear.go (100.0%)</option>
				
				<option value="file126">github.com/TheAlgorithms/Go/search/selectk.go (100.0%)</option>
				
				<option value="file127">github.com/TheAlgorithms/Go/search/ternary.go (88.9%)</option>
				
				<option value="file128">github.com/TheAlgorithms/Go/search/testcases.go (0.0%)</option>
				
				<option value="file129">github.com/TheAlgorithms/Go/sort/binaryinsertionsort.go (100.0%)</option>
				
				<option value="file130">github.com/TheAlgorithms/Go/sort/bogosort.go (0.0%)</option>
				
				<option value="file131">github.com/TheAlgorithms/Go/sort/bubblesort.go (100.0%)</option>
				
				<option value="file132">github.com/TheAlgorithms/Go/sort/bucketsort.go (100.0%)</option>
				
				<option value="file133">github.com/TheAlgorithms/Go/sort/cocktailsort.go (100.0%)</option>
				
				<option value="file134">github.com/TheAlgorithms/Go/sort/combSort.go (100.0%)</option>
				
				<option value="file135">github.com/TheAlgorithms/Go/sort/countingsort.go (100.0%)</option>
				
				<option value="file136">github.com/TheAlgorithms/Go/sort/cyclesort.go (95.8%)</option>
				
				<option value="file137">github.com/TheAlgorithms/Go/sort/exchangesort.go (100.0%)</option>
				
				<option value="file138">github.com/TheAlgorithms/Go/sort/heapsort.go (33.9%)</option>
				
				<option value="file139">github.com/TheAlgorithms/Go/sort/insertionsort.go (100.0%)</option>
				
				<option value="file140">github.com/TheAlgorithms/Go/sort/mergesort.go (100.0%)</option>
				
				<option value="file141">github.com/TheAlgorithms/Go/sort/pancakesort.go (100.0%)</option>
				
				<option value="file142">github.com/TheAlgorithms/Go/sort/patiencesort.go (100.0%)</option>
				
				<option value="file143">github.com/TheAlgorithms/Go/sort/pigeonholesort.go (100.0%)</option>
				
				<option value="file144">github.com/TheAlgorithms/Go/sort/quicksort.go (100.0%)</option>
				
				<option value="file145">github.com/TheAlgorithms/Go/sort/radixsort.go (100.0%)</option>
				
				<option value="file146">github.com/TheAlgorithms/Go/sort/selectionsort.go (100.0%)</option>
				
				<option value="file147">github.com/TheAlgorithms/Go/sort/shellsort.go (100.0%)</option>
				
				<option value="file148">github.com/TheAlgorithms/Go/sort/simplesort.go (100.0%)</option>
				
				<option value="file149">github.com/TheAlgorithms/Go/sort/timsort.go (100.0%)</option>
				
				<option value="file150">github.com/TheAlgorithms/Go/sqrt/sqrtdecomposition.go (100.0%)</option>
				
				<option value="file151">github.com/TheAlgorithms/Go/strings/ahocorasick/advancedahocorasick.go (0.0%)</option>
				
				<option value="file152">github.com/TheAlgorithms/Go/strings/ahocorasick/ahocorasick.go (95.1%)</option>
				
				<option value="file153">github.com/TheAlgorithms/Go/strings/ahocorasick/shared.go (71.0%)</option>
				
				<option value="file154">github.com/TheAlgorithms/Go/strings/charoccurrence.go (100.0%)</option>
				
				<option value="file155">github.com/TheAlgorithms/Go/strings/generateparentheses/generateparentheses.go (100.0%)</option>
				
				<option value="file156">github.com/TheAlgorithms/Go/strings/genetic/genetic.go (94.0%)</option>
				
				<option value="file157">github.com/TheAlgorithms/Go/strings/guid/guid.go (92.3%)</option>
				
				<option value="file158">github.com/TheAlgorithms/Go/strings/horspool/horspool.go (100.0%)</option>
				
				<option value="file159">github.com/TheAlgorithms/Go/strings/isisogram.go (100.0%)</option>
				
				<option value="file160">github.com/TheAlgorithms/Go/strings/issubsequence.go (100.0%)</option>
				
				<option value="file161">github.com/TheAlgorithms/Go/strings/kmp/kmp.go (95.5%)</option>
				
				<option value="file162">github.com/TheAlgorithms/Go/strings/levenshtein/levenshteindistance.go (100.0%)</option>
				
				<option value="file163">github.com/TheAlgorithms/Go/strings/manacher/longestpalindrome.go (100.0%)</option>
				
				<option value="file164">github.com/TheAlgorithms/Go/strings/palindrome/ispalindrome.go (100.0%)</option>
				
				<option value="file165">github.com/TheAlgorithms/Go/strings/pangram/ispangram.go (100.0%)</option>
				
				<option value="file166">github.com/TheAlgorithms/Go/strings/parenthesis/parenthesis.go (100.0%)</option>
				
				<option value="file167">github.com/TheAlgorithms/Go/strings/search/boyermoore.go (100.0%)</option>
				
				<option value="file168">github.com/TheAlgorithms/Go/strings/search/naive.go (100.0%)</option>
				
				<option value="file169">github.com/TheAlgorithms/Go/structure/deque/deque.go (100.0%)</option>
				
				<option value="file170">github.com/TheAlgorithms/Go/structure/dynamicarray/dynamicarray.go (83.9%)</option>
				
				<option value="file171">github.com/TheAlgorithms/Go/structure/fenwicktree/fenwicktree.go (100.0%)</option>
				
				<option value="file172">github.com/TheAlgorithms/Go/structure/hashmap/hashmap.go (94.6%)</option>
				
				<option value="file173">github.com/TheAlgorithms/Go/structure/heap/heap.go (94.4%)</option>
				
				<option value="file174">github.com/TheAlgorithms/Go/structure/linkedlist/cyclic.go (100.0%)</option>
				
				<option value="file175">github.com/TheAlgorithms/Go/structure/linkedlist/doubly.go (46.9%)</option>
				
				<option value="file176">github.com/TheAlgorithms/Go/structure/linkedlist/shared.go (100.0%)</option>
				
				<option value="file177">github.com/TheAlgorithms/Go/structure/linkedlist/singlylinkedlist.go (60.5%)</option>
				
				<option value="file178">github.com/TheAlgorithms/Go/structure/queue/queuearray.go (87.5%)</option>
				
				<option value="file179">github.com/TheAlgorithms/Go/structure/queue/queuelinkedlist.go (85.0%)</option>
				
				<option value="file180">github.com/TheAlgorithms/Go/structure/queue/queuelinklistwithlist.go (81.2%)</option>
				
				<option value="file181">github.com/TheAlgorithms/Go/structure/segmenttree/segmenttree.go (100.0%)</option>
				
				<option value="file182">github.com/TheAlgorithms/Go/structure/set/set.go (100.0%)</option>
				
				<option value="file183">github.com/TheAlgorithms/Go/structure/stack/stackarray.go (73.3%)</option>
				
				<option value="file184">github.com/TheAlgorithms/Go/structure/stack/stacklinkedlist.go (100.0%)</option>
				
				<option value="file185">github.com/TheAlgorithms/Go/structure/stack/stacklinkedlistwithlist.go (83.3%)</option>
				
				<option value="file186">github.com/TheAlgorithms/Go/structure/tree/avl.go (98.6%)</option>
				
				<option value="file187">github.com/TheAlgorithms/Go/structure/tree/bstree.go (100.0%)</option>
				
				<option value="file188">github.com/TheAlgorithms/Go/structure/tree/rbtree.go (100.0%)</option>
				
				<option value="file189">github.com/TheAlgorithms/Go/structure/tree/tree.go (100.0%)</option>
				
				<option value="file190">github.com/TheAlgorithms/Go/structure/trie/trie.go (97.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// lfu.go
// description: a type of cache algorithm used to manage memory within a computer.
// details:
// The standard characteristics of this method involve the system keeping track of the number of times a block is referenced in memory.
// When the cache is full and requires more room the system will purge the item with the lowest reference frequency.
// ref: (https://en.wikipedia.org/wiki/Least_frequently_used)
// time complexity: O(N)
// space complexity: O(1)
// author: [CocaineCong](https://github.com/CocaineCong)

package cache

import (
        "container/list"
        "math"
)

// LFU the Least Frequently Used (LFU) page-replacement algorithm
type LFU struct {
        len     int // length
        cap     int // capacity
        minFreq int // The element that operates least frequently in LFU

        // key: key of element, value: value of element
        itemMap map[string]*list.Element

        // key: frequency of possible occurrences of all elements in the itemMap
        // value: elements with the same frequency
        freqMap map[int]*list.List
}

// NewLFU init the LFU cache with capacity
func NewLFU(capacity int) LFU <span class="cov8" title="1">{
        return LFU{
                len:     0,
                cap:     capacity,
                minFreq: math.MaxInt,
                itemMap: make(map[string]*list.Element),
                freqMap: make(map[int]*list.List),
        }
}</span>

// initItem to init item for LFU
func initItem(k string, v any, f int) item <span class="cov8" title="1">{
        return item{
                key:   k,
                value: v,
                freq:  f,
        }
}</span>

// Get the key in cache by LFU
func (c *LFU) Get(key string) any <span class="cov8" title="1">{
        // if existed, will return value
        if e, ok := c.itemMap[key]; ok </span><span class="cov8" title="1">{
                // the frequency of e +1 and change freqMap
                c.increaseFreq(e)
                obj := e.Value.(item)
                return obj.value
        }</span>

        // if not existed, return nil
        <span class="cov8" title="1">return nil</span>
}

// Put the key in LFU cache
func (c *LFU) Put(key string, value any) <span class="cov8" title="1">{
        if e, ok := c.itemMap[key]; ok </span><span class="cov8" title="1">{
                // if key existed, update the value
                obj := e.Value.(item)
                obj.value = value
                c.increaseFreq(e)
        }</span> else<span class="cov8" title="1"> {
                // if key not existed
                obj := initItem(key, value, 1)
                // if the length of item gets to the top line
                // remove the least frequently operated element
                if c.len == c.cap </span><span class="cov8" title="1">{
                        c.eliminate()
                        c.len--
                }</span>
                // insert in freqMap and itemMap
                <span class="cov8" title="1">c.insertMap(obj)
                // change minFreq to 1 because insert the newest one
                c.minFreq = 1
                // length++
                c.len++</span>
        }
}

// increaseFreq increase the frequency if element
func (c *LFU) increaseFreq(e *list.Element) <span class="cov8" title="1">{
        obj := e.Value.(item)
        // remove from low frequency first
        oldLost := c.freqMap[obj.freq]
        oldLost.Remove(e)
        // change the value of minFreq
        if c.minFreq == obj.freq &amp;&amp; oldLost.Len() == 0 </span><span class="cov8" title="1">{
                // if it is the last node of the minimum frequency that is removed
                c.minFreq++
        }</span>
        // add to high frequency list
        <span class="cov8" title="1">c.insertMap(obj)</span>
}

// insertMap insert item in map
func (c *LFU) insertMap(obj item) <span class="cov8" title="1">{
        // add in freqMap
        l, ok := c.freqMap[obj.freq]
        if !ok </span><span class="cov8" title="1">{
                l = list.New()
                c.freqMap[obj.freq] = l
        }</span>
        <span class="cov8" title="1">e := l.PushFront(obj)
        // update or add the value of itemMap key to e
        c.itemMap[obj.key] = e</span>
}

// eliminate clear the least frequently operated element
func (c *LFU) eliminate() <span class="cov8" title="1">{
        l := c.freqMap[c.minFreq]
        e := l.Back()
        obj := e.Value.(item)
        l.Remove(e)

        delete(c.itemMap, obj.key)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "github.com/TheAlgorithms/Go/structure/linkedlist"
)

type item struct {
        key   string
        value any

        // the frequency of key
        freq int
}

type LRU struct {
        dl       *linkedlist.Doubly[any]
        size     int
        capacity int
        storage  map[string]*linkedlist.Node[any]
}

// NewLRU represent initiate lru cache with capacity
func NewLRU(capacity int) LRU <span class="cov8" title="1">{
        return LRU{
                dl:       linkedlist.NewDoubly[any](),
                storage:  make(map[string]*linkedlist.Node[any], capacity),
                size:     0,
                capacity: capacity,
        }
}</span>

// Get value from lru
// if not found, return nil
func (c *LRU) Get(key string) any <span class="cov8" title="1">{
        v, ok := c.storage[key]
        if ok </span><span class="cov8" title="1">{
                c.dl.MoveToBack(v)
                return v.Val.(item).value
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Put cache with key and value to lru
func (c *LRU) Put(key string, value any) <span class="cov8" title="1">{
        e, ok := c.storage[key]
        if ok </span><span class="cov8" title="1">{
                n := e.Val.(item)
                n.value = value
                e.Val = n
                c.dl.MoveToBack(e)
                return
        }</span>

        <span class="cov8" title="1">if c.size &gt;= c.capacity </span><span class="cov8" title="1">{
                e := c.dl.Front()
                dk := e.Val.(item).key
                c.dl.Remove(e)
                delete(c.storage, dk)
                c.size--
        }</span>

        <span class="cov8" title="1">n := item{key: key, value: value}
        c.dl.AddAtEnd(n)
        ne := c.dl.Back()
        c.storage[key] = ne
        c.size++</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package caesar is the shift cipher
// ref: https://en.wikipedia.org/wiki/Caesar_cipher
package caesar

// Encrypt encrypts by right shift of "key" each character of "input"
func Encrypt(input string, key int) string <span class="cov8" title="1">{
        // if key is negative value,
        // updates "key" the number which congruents to "key" modulo 26
        key8 := byte(key%26+26) % 26

        var outputBuffer []byte
        // b is a byte, which is the equivalent of uint8.
        for _, b := range []byte(input) </span><span class="cov8" title="1">{
                newByte := b
                if 'A' &lt;= b &amp;&amp; b &lt;= 'Z' </span><span class="cov8" title="1">{
                        outputBuffer = append(outputBuffer, 'A'+(newByte-'A'+key8)%26)
                }</span> else<span class="cov8" title="1"> if 'a' &lt;= b &amp;&amp; b &lt;= 'z' </span><span class="cov8" title="1">{
                        outputBuffer = append(outputBuffer, 'a'+(newByte-'a'+key8)%26)
                }</span> else<span class="cov8" title="1"> {
                        outputBuffer = append(outputBuffer, newByte)
                }</span>
        }
        <span class="cov8" title="1">return string(outputBuffer)</span>
}

// Decrypt decrypts by left shift of "key" each character of "input"
func Decrypt(input string, key int) string <span class="cov8" title="1">{
        // left shift of "key" is same as right shift of 26-"key"
        return Encrypt(input, 26-key)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package diffiehellman implements Diffie-Hellman Key Exchange Algorithm
// for more information watch : https://www.youtube.com/watch?v=NmM9HA2MQGI
package diffiehellman

const (
        generator         = 3
        primeNumber int64 = 6700417 // prime number discovered by Leonhard Euler
)

// GenerateShareKey : generates a key using client private key , generator and primeNumber
// this key can be made public
// shareKey = (g^key)%primeNumber
func GenerateShareKey(prvKey int64) int64 <span class="cov8" title="1">{
        return modularExponentiation(generator, prvKey, primeNumber)
}</span>

// GenerateMutualKey : generates a mutual key that can be used by only alice and bob
// mutualKey = (shareKey^prvKey)%primeNumber
func GenerateMutualKey(prvKey, shareKey int64) int64 <span class="cov8" title="1">{
        return modularExponentiation(shareKey, prvKey, primeNumber)
}</span>

// r = (b^e)%mod
func modularExponentiation(b, e, mod int64) int64 <span class="cov8" title="1">{

        //runs in O(log(n)) where n = e
        //uses exponentiation by squaring to speed up the process
        if mod == 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var r int64 = 1
        b = b % mod
        for e &gt; 0 </span><span class="cov8" title="1">{
                if e&amp;1 == 1 </span><span class="cov8" title="1">{
                        r = (r * b) % mod
                }</span>
                <span class="cov8" title="1">e = e &gt;&gt; 1
                b = (b * b) % mod</span>
        }
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package polybius is encrypting method with polybius square
// ref: https://en.wikipedia.org/wiki/Polybius_square#Hybrid_Polybius_Playfair_Cipher
package polybius

import (
        "fmt"
        "math"
        "strings"
)

// Polybius is struct having size, characters, and key
type Polybius struct {
        size       int
        characters string
        key        string
}

// NewPolybius returns a pointer to object of Polybius.
// If the size of "chars" is longer than "size",
// "chars" are truncated to "size".
func NewPolybius(key string, size int, chars string) (*Polybius, error) <span class="cov8" title="1">{
        if size &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provided size %d cannot be negative", size)
        }</span>
        <span class="cov8" title="1">key = strings.ToUpper(key)
        if size &gt; len(chars) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provided size %d is too small to use to slice string %q of len %d", size, chars, len(chars))
        }</span>
        <span class="cov8" title="1">for _, r := range chars </span><span class="cov8" title="1">{
                if (r &lt; 'a' || r &gt; 'z') &amp;&amp; (r &lt; 'A' || r &gt; 'Z') </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("provided string %q should only contain latin characters", chars)
                }</span>
        }
        <span class="cov8" title="1">chars = strings.ToUpper(chars)[:size]
        for i, r := range chars </span><span class="cov8" title="1">{
                if strings.ContainsRune(chars[i+1:], r) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%q contains same character %q", chars[i+1:], r)
                }</span>
        }

        <span class="cov8" title="1">if len(key) != size*size </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("len(key): %d must be as long as size squared: %d", len(key), size*size)
        }</span>
        <span class="cov8" title="1">return &amp;Polybius{size, chars, key}, nil</span>
}

// Encrypt encrypts with polybius encryption
func (p *Polybius) Encrypt(text string) (string, error) <span class="cov8" title="1">{
        encryptedText := ""
        for _, char := range strings.ToUpper(text) </span><span class="cov8" title="1">{
                encryptedChar, err := p.encipher(char)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed encipher: %w", err)
                }</span>
                <span class="cov8" title="1">encryptedText += encryptedChar</span>
        }
        <span class="cov8" title="1">return encryptedText, nil</span>
}

// Decrypt decrypts with polybius encryption
func (p *Polybius) Decrypt(text string) (string, error) <span class="cov8" title="1">{
        chars := []rune(strings.ToUpper(text))
        decryptedText := ""
        for i := 0; i &lt; len(chars); i += 2 </span><span class="cov8" title="1">{
                decryptedChar, err := p.decipher(chars[i:int(math.Min(float64(i+2), float64(len(chars))))])
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed decipher: %w", err)
                }</span>
                <span class="cov8" title="1">decryptedText += decryptedChar</span>
        }
        <span class="cov8" title="1">return decryptedText, nil</span>
}

func (p *Polybius) encipher(char rune) (string, error) <span class="cov8" title="1">{
        index := strings.IndexRune(p.key, char)
        if index &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%q does not exist in keys", char)
        }</span>
        <span class="cov8" title="1">row := index / p.size
        col := index % p.size
        chars := []rune(p.characters)
        return string([]rune{chars[row], chars[col]}), nil</span>
}

func (p *Polybius) decipher(chars []rune) (string, error) <span class="cov8" title="1">{
        if len(chars) != 2 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("the size of \"chars\" must be even")
        }</span>
        <span class="cov8" title="1">row := strings.IndexRune(p.characters, chars[0])
        if row &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%c does not exist in characters", chars[0])
        }</span>
        <span class="cov8" title="1">col := strings.IndexRune(p.characters, chars[1])
        if col &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%c does not exist in characters", chars[1])
        }</span>
        <span class="cov8" title="1">return string(p.key[row*p.size+col]), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package rot13 is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet.
// ref: https://en.wikipedia.org/wiki/ROT13
package rot13

import (
        "github.com/TheAlgorithms/Go/cipher/caesar"
)

// rot13 is a special case, which is fixed the shift of 13, of the Caesar cipher
func rot13(input string) string <span class="cov8" title="1">{
        return caesar.Encrypt(input, 13)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// rsa.go
// description: Simple RSA algorithm implementation
// details:
// A simple RSA Encryption and Decryption algorithm.
// It uses prime numbers that fit in int64 datatypes and
// thus both the Encrypt and Decrypt are not a production
// ready implementation. The OpenSSL implementation of RSA
// also adds a padding which is not present in this algorithm.
// author(s) [Taj](https://github.com/tjgurwara99)
// see rsa_test.go

// Package rsa shows a simple implementation of RSA algorithm
package rsa

import (
        "errors"

        modular "github.com/TheAlgorithms/Go/math/modular"
)

// ErrorFailedToEncrypt Raised when Encrypt function fails to encrypt the message
var ErrorFailedToEncrypt = errors.New("failed to Encrypt")

// ErrorFailedToDecrypt Raised when Decrypt function fails to decrypt the encrypted message
var ErrorFailedToDecrypt = errors.New("failed to Decrypt")

// Encrypt encrypts based on the RSA algorithm - uses modular exponentitation in math directory
func Encrypt(message []rune, publicExponent, modulus int64) ([]rune, error) <span class="cov8" title="1">{
        var encrypted []rune

        for _, letter := range message </span><span class="cov8" title="1">{
                encryptedLetter, err := modular.Exponentiation(int64(letter), publicExponent, modulus)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, ErrorFailedToEncrypt
                }</span>
                <span class="cov8" title="1">encrypted = append(encrypted, rune(encryptedLetter))</span>
        }

        <span class="cov8" title="1">return encrypted, nil</span>
}

// Decrypt decrypts encrypted rune slice based on the RSA algorithm
func Decrypt(encrypted []rune, privateExponent, modulus int64) (string, error) <span class="cov8" title="1">{
        var decrypted []rune

        for _, letter := range encrypted </span><span class="cov8" title="1">{
                decryptedLetter, err := modular.Exponentiation(int64(letter), privateExponent, modulus)
                if err != nil </span><span class="cov0" title="0">{
                        return "", ErrorFailedToDecrypt
                }</span>
                <span class="cov8" title="1">decrypted = append(decrypted, rune(decryptedLetter))</span>
        }
        <span class="cov8" title="1">return string(decrypted), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// transposition.go
// description: Transposition cipher
// details:
// Implementation "Transposition cipher" is a method of encryption by which the positions held by units of plaintext (which are commonly characters or groups of characters) are shifted according to a regular system, so that the ciphertext constitutes a permutation of the plaintext [Transposition cipher](https://en.wikipedia.org/wiki/Transposition_cipher)
// author(s) [red_byte](https://github.com/i-redbyte)
// see transposition_test.go

package transposition

import (
        "errors"
        "fmt"
        "sort"
        "strings"
)

var ErrNoTextToEncrypt = errors.New("no text to encrypt")
var ErrKeyMissing = errors.New("missing Key")

const placeholder = ' '

func getKey(keyWord string) []int <span class="cov8" title="1">{
        keyWord = strings.ToLower(keyWord)
        word := []rune(keyWord)
        var sortedWord = make([]rune, len(word))
        copy(sortedWord, word)
        sort.Slice(sortedWord, func(i, j int) bool </span><span class="cov8" title="1">{ return sortedWord[i] &lt; sortedWord[j] }</span>)
        <span class="cov8" title="1">usedLettersMap := make(map[rune]int)
        wordLength := len(word)
        resultKey := make([]int, wordLength)
        for i := 0; i &lt; wordLength; i++ </span><span class="cov8" title="1">{
                char := word[i]
                numberOfUsage := usedLettersMap[char]
                resultKey[i] = getIndex(sortedWord, char) + numberOfUsage + 1 //+1 -so that indexing does not start at 0
                numberOfUsage++
                usedLettersMap[char] = numberOfUsage
        }</span>
        <span class="cov8" title="1">return resultKey</span>
}

func getIndex(wordSet []rune, subString rune) int <span class="cov8" title="1">{
        n := len(wordSet)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                if wordSet[i] == subString </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func Encrypt(text []rune, keyWord string) ([]rune, error) <span class="cov8" title="1">{
        key := getKey(keyWord)
        keyLength := len(key)
        textLength := len(text)
        if keyLength &lt;= 0 </span><span class="cov8" title="1">{
                return nil, ErrKeyMissing
        }</span>
        <span class="cov8" title="1">if textLength &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrNoTextToEncrypt
        }</span>
        <span class="cov8" title="1">if text[len(text)-1] == placeholder </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: cannot encrypt a text, %q, ending with the placeholder char %q", ErrNoTextToEncrypt, text, placeholder)
        }</span>
        <span class="cov8" title="1">n := textLength % keyLength

        for i := 0; i &lt; keyLength-n; i++ </span><span class="cov8" title="1">{
                text = append(text, placeholder)
        }</span>
        <span class="cov8" title="1">textLength = len(text)
        var result []rune
        for i := 0; i &lt; textLength; i += keyLength </span><span class="cov8" title="1">{
                transposition := make([]rune, keyLength)
                for j := 0; j &lt; keyLength; j++ </span><span class="cov8" title="1">{
                        transposition[key[j]-1] = text[i+j]
                }</span>
                <span class="cov8" title="1">result = append(result, transposition...)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func Decrypt(text []rune, keyWord string) ([]rune, error) <span class="cov8" title="1">{
        key := getKey(keyWord)
        textLength := len(text)
        if textLength &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrNoTextToEncrypt
        }</span>
        <span class="cov8" title="1">keyLength := len(key)
        if keyLength &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrKeyMissing
        }</span>
        <span class="cov8" title="1">n := textLength % keyLength
        for i := 0; i &lt; keyLength-n; i++ </span><span class="cov8" title="1">{
                text = append(text, placeholder)
        }</span>
        <span class="cov8" title="1">var result []rune
        for i := 0; i &lt; textLength; i += keyLength </span><span class="cov8" title="1">{
                transposition := make([]rune, keyLength)
                for j := 0; j &lt; keyLength; j++ </span><span class="cov8" title="1">{
                        transposition[j] = text[i+key[j]-1]
                }</span>
                <span class="cov8" title="1">result = append(result, transposition...)</span>
        }
        <span class="cov8" title="1">result = []rune(strings.TrimRight(string(result), string(placeholder)))
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package xor is an encryption algorithm that operates the exclusive disjunction(XOR)
// ref: https://en.wikipedia.org/wiki/XOR_cipher
package xor

// Encrypt encrypts with Xor encryption after converting each character to byte
// The returned value might not be readable because there is no guarantee
// which is within the ASCII range
// If using other type such as string, []int, or some other types,
// add the statements for converting the type to []byte.
func Encrypt(key byte, plaintext []byte) []byte <span class="cov8" title="1">{
        cipherText := []byte{}
        for _, ch := range plaintext </span><span class="cov8" title="1">{
                cipherText = append(cipherText, key^ch)
        }</span>
        <span class="cov8" title="1">return cipherText</span>
}

// Decrypt decrypts with Xor encryption
func Decrypt(key byte, cipherText []byte) []byte <span class="cov8" title="1">{
        plainText := []byte{}
        for _, ch := range cipherText </span><span class="cov8" title="1">{
                plainText = append(plainText, key^ch)
        }</span>
        <span class="cov8" title="1">return plainText</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// huffman.go
// description: Implements Huffman compression, encoding and decoding
// details:
// We implement the linear-time 2-queue method described here https://en.wikipedia.org/wiki/Huffman_coding.
// It assumes that the list of symbol-frequencies is sorted.
// author(s) [pedromsrocha](https://github.com/pedromsrocha)
// see also huffmancoding_test.go

package compression

import "fmt"

// A Node of an Huffman tree, which can either be a leaf or an internal node.
// Each node has a weight.
// A leaf node has an associated symbol, but no children (i.e., left == right == nil).
// A parent node has a left and right child and no symbol (i.e., symbol == -1).
type Node struct {
        left   *Node
        right  *Node
        symbol rune
        weight int
}

// A SymbolFreq is a pair of a symbol and its associated frequency.
type SymbolFreq struct {
        Symbol rune
        Freq   int
}

// HuffTree returns the root Node of the Huffman tree by compressing listfreq.
// The compression produces the most optimal code lengths, provided listfreq is ordered,
// i.e.: listfreq[i] &lt;= listfreq[j], whenever i &lt; j.
func HuffTree(listfreq []SymbolFreq) (*Node, error) <span class="cov8" title="1">{
        if len(listfreq) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("huffman coding: HuffTree : calling method with empty list of symbol-frequency pairs")
        }</span>
        <span class="cov8" title="1">q1 := make([]Node, len(listfreq))
        q2 := make([]Node, 0, len(listfreq))
        for i, x := range listfreq </span><span class="cov8" title="1">{ // after the loop, q1 is a slice of leaf nodes representing listfreq
                q1[i] = Node{left: nil, right: nil, symbol: x.Symbol, weight: x.Freq}
        }</span>
        //loop invariant: q1, q2 are ordered by increasing weights
        <span class="cov8" title="1">for len(q1)+len(q2) &gt; 1 </span><span class="cov8" title="1">{
                var node1, node2 Node
                node1, q1, q2 = least(q1, q2)
                node2, q1, q2 = least(q1, q2)
                node := Node{left: &amp;node1, right: &amp;node2,
                        symbol: -1, weight: node1.weight + node2.weight}
                q2 = append(q2, node)
        }</span>
        <span class="cov8" title="1">if len(q1) == 1 </span><span class="cov0" title="0">{ // returns the remaining node in q1, q2
                return &amp;q1[0], nil
        }</span>
        <span class="cov8" title="1">return &amp;q2[0], nil</span>
}

// least removes the node with lowest weight from q1, q2.
// It returns the node with lowest weight and the slices q1, q2 after the update.
func least(q1 []Node, q2 []Node) (Node, []Node, []Node) <span class="cov8" title="1">{
        if len(q1) == 0 </span><span class="cov8" title="1">{
                return q2[0], q1, q2[1:]
        }</span>
        <span class="cov8" title="1">if len(q2) == 0 </span><span class="cov8" title="1">{
                return q1[0], q1[1:], q2
        }</span>
        <span class="cov8" title="1">if q1[0].weight &lt;= q2[0].weight </span><span class="cov8" title="1">{
                return q1[0], q1[1:], q2
        }</span>
        <span class="cov8" title="1">return q2[0], q1, q2[1:]</span>
}

// HuffEncoding recursively traverses the Huffman tree pointed by node to obtain
// the map codes, that associates a rune with a slice of booleans.
// Each code is prefixed by prefix and left and right children are labelled with
// the booleans false and true, respectively.
func HuffEncoding(node *Node, prefix []bool, codes map[rune][]bool) <span class="cov8" title="1">{
        if node.symbol != -1 </span><span class="cov8" title="1">{ //base case
                codes[node.symbol] = prefix
                return
        }</span>
        // inductive step
        <span class="cov8" title="1">prefixLeft := make([]bool, len(prefix))
        copy(prefixLeft, prefix)
        prefixLeft = append(prefixLeft, false)
        HuffEncoding(node.left, prefixLeft, codes)
        prefixRight := make([]bool, len(prefix))
        copy(prefixRight, prefix)
        prefixRight = append(prefixRight, true)
        HuffEncoding(node.right, prefixRight, codes)</span>
}

// HuffEncode encodes the string in by applying the mapping defined by codes.
func HuffEncode(codes map[rune][]bool, in string) []bool <span class="cov8" title="1">{
        out := make([]bool, 0)
        for _, s := range in </span><span class="cov8" title="1">{
                out = append(out, codes[s]...)
        }</span>
        <span class="cov8" title="1">return out</span>
}

// HuffDecode recursively decodes the binary code in, by traversing the Huffman compression tree pointed by root.
// current stores the current node of the traversing algorithm.
// out stores the current decoded string.
func HuffDecode(root, current *Node, in []bool, out string) string <span class="cov8" title="1">{
        if current.symbol != -1 </span><span class="cov8" title="1">{
                out += string(current.symbol)
                return HuffDecode(root, root, in, out)
        }</span>
        <span class="cov8" title="1">if len(in) == 0 </span><span class="cov8" title="1">{
                return out
        }</span>
        <span class="cov8" title="1">if in[0] </span><span class="cov8" title="1">{
                return HuffDecode(root, current.right, in[1:], out)
        }</span>
        <span class="cov8" title="1">return HuffDecode(root, current.left, in[1:], out)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// base64.go
// description: The base64 encoding algorithm as defined in the RFC4648 standard.
// author: [Paul Leydier] (https://github.com/paul-leydier)
// ref: https://datatracker.ietf.org/doc/html/rfc4648#section-4
// ref: https://en.wikipedia.org/wiki/Base64
// see base64_test.go

package conversion

import (
        "strings" // Used for efficient string builder (more efficient than simply appending strings)
)

const Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

// Base64Encode encodes the received input bytes slice into a base64 string.
// The implementation follows the RFC4648 standard, which is documented
// at https://datatracker.ietf.org/doc/html/rfc4648#section-4
func Base64Encode(input []byte) string <span class="cov8" title="1">{
        var sb strings.Builder
        // If not 24 bits (3 bytes) multiple, pad with 0 value bytes, and with "=" for the output
        var padding string
        for i := len(input) % 3; i &gt; 0 &amp;&amp; i &lt; 3; i++ </span><span class="cov8" title="1">{
                var zeroByte byte
                input = append(input, zeroByte)
                padding += "="
        }</span>

        // encode 24 bits per 24 bits (3 bytes per 3 bytes)
        <span class="cov8" title="1">for i := 0; i &lt; len(input); i += 3 </span><span class="cov8" title="1">{
                // select 3 8-bit input groups, and re-arrange them into 4 6-bit groups
                // the literal 0x3F corresponds to the byte "0011 1111"
                // the operation "byte &amp; 0x3F" masks the two left-most bits
                group := [4]byte{
                        input[i] &gt;&gt; 2,
                        (input[i]&lt;&lt;4)&amp;0x3F + input[i+1]&gt;&gt;4,
                        (input[i+1]&lt;&lt;2)&amp;0x3F + input[i+2]&gt;&gt;6,
                        input[i+2] &amp; 0x3F,
                }

                // translate each group into a char using the static map
                for _, b := range group </span><span class="cov8" title="1">{
                        sb.WriteString(string(Alphabet[int(b)]))
                }</span>
        }
        <span class="cov8" title="1">encoded := sb.String()

        // Apply the output padding
        encoded = encoded[:len(encoded)-len(padding)] + padding[:]

        return encoded</span>
}

// Base64Decode decodes the received input base64 string into a byte slice.
// The implementation follows the RFC4648 standard, which is documented
// at https://datatracker.ietf.org/doc/html/rfc4648#section-4
func Base64Decode(input string) []byte <span class="cov8" title="1">{
        padding := strings.Count(input, "=") // Number of bytes which will be ignored
        var decoded []byte

        // select 4 6-bit input groups, and re-arrange them into 3 8-bit groups
        for i := 0; i &lt; len(input); i += 4 </span><span class="cov8" title="1">{
                // translate each group into a byte using the static map
                byteInput := [4]byte{
                        byte(strings.IndexByte(Alphabet, input[i])),
                        byte(strings.IndexByte(Alphabet, input[i+1])),
                        byte(strings.IndexByte(Alphabet, input[i+2])),
                        byte(strings.IndexByte(Alphabet, input[i+3])),
                }

                group := [3]byte{
                        byteInput[0]&lt;&lt;2 + byteInput[1]&gt;&gt;4,
                        byteInput[1]&lt;&lt;4 + byteInput[2]&gt;&gt;2,
                        byteInput[2]&lt;&lt;6 + byteInput[3],
                }

                decoded = append(decoded, group[:]...)
        }</span>

        <span class="cov8" title="1">return decoded[:len(decoded)-padding]</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Author: Motasim
GitHub: https://github.com/motasimmakki
Date: 19-Oct-2021
*/

// This algorithm will convert any Binary number(0 or 1) to Decimal number(+ve number).
// https://en.wikipedia.org/wiki/Binary_number
// https://en.wikipedia.org/wiki/Decimal
// Function receives a Binary Number as string and returns the Decimal number as integer.
// Supported Binary number range is 0 to 2^(31-1).

package conversion

// Importing necessary package.
import (
        "errors"
        "regexp"
)

var isValid = regexp.MustCompile("^[0-1]{1,}$").MatchString

// BinaryToDecimal() function that will take Binary number as string,
// and return it's Decimal equivalent as integer.
func BinaryToDecimal(binary string) (int, error) <span class="cov8" title="1">{
        if !isValid(binary) </span><span class="cov0" title="0">{
                return -1, errors.New("not a valid binary string")
        }</span>
        <span class="cov8" title="1">if len(binary) &gt; 32 </span><span class="cov0" title="0">{
                return -1, errors.New("binary number must be in range 0 to 2^(31-1)")
        }</span>
        <span class="cov8" title="1">var result, base int = 0, 1
        for i := len(binary) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if binary[i] == '1' </span><span class="cov8" title="1">{
                        result += base
                }</span>
                <span class="cov8" title="1">base *= 2</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Author: Motasim
GitHub: https://github.com/motasimmakki
Date: 14-Oct-2021
*/

// This algorithm will convert any Decimal (+ve integer) number to Binary number.
// https://en.wikipedia.org/wiki/Binary_number
// Function receives a integer as a Decimal number and returns the Binary number.
// Supported integer value range is 0 to 2^(31 -1).

package conversion

// Importing necessary package.
import (
        "errors"
        "strconv"
)

// Reverse() function that will take string,
// and returns the reverse of that string.
func Reverse(str string) string <span class="cov8" title="1">{
        rStr := []rune(str)
        for i, j := 0, len(rStr)-1; i &lt; len(rStr)/2; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                rStr[i], rStr[j] = rStr[j], rStr[i]
        }</span>
        <span class="cov8" title="1">return string(rStr)</span>
}

// DecimalToBinary() function that will take Decimal number as int,
// and return it's Binary equivalent as string.
func DecimalToBinary(num int) (string, error) <span class="cov8" title="1">{
        if num &lt; 0 </span><span class="cov0" title="0">{
                return "", errors.New("integer must have +ve value")
        }</span>
        <span class="cov8" title="1">if num == 0 </span><span class="cov8" title="1">{
                return "0", nil
        }</span>
        <span class="cov8" title="1">var result string = ""
        for num &gt; 0 </span><span class="cov8" title="1">{
                result += strconv.Itoa(num &amp; 1)
                num &gt;&gt;= 1
        }</span>
        <span class="cov8" title="1">return Reverse(result), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package conversion

import (
        "errors"
)

var (
        // lookup arrays used for converting from an int to a roman numeral extremely quickly.
        r0 = []string{"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"} // 1 - 9
        r1 = []string{"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"} // 10 - 90
        r2 = []string{"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"} // 100 - 900
        r3 = []string{"", "M", "MM", "MMM"}                                       // 1,000 - 3,000
)

// IntToRoman converts an integer value to a roman numeral string. An error is
// returned if the integer is not between 1 and 3999.
func IntToRoman(n int) (string, error) <span class="cov8" title="1">{
        if n &lt; 1 || n &gt; 3999 </span><span class="cov8" title="1">{
                return "", errors.New("integer must be between 1 and 3999")
        }</span>
        // Concatenate strings for each of 4 lookup array categories.
        //
        // Key behavior to note here is how math with integers is handled. Values are floored to the
        // nearest int, not rounded up. For example, 26/10 = 2 even though the actual result is 2.6.
        //
        // For example, lets use an input value of 126:
        // `r3[n%1e4/1e3]` --&gt; 126 % 10_000 = 126 --&gt; 126 / 1_000 = 0.126 (0 as int) --&gt; r3[0] = ""
        // `r2[n%1e3/1e2]` --&gt; 126 % 1_000 = 126 --&gt; 126 / 100 = 1.26 (1 as int) --&gt; r2[1] = "C"
        // `r1[n%100/10]` --&gt; 126 % 100 = 26 --&gt; 26 / 10 = 2.6 (2 as int) --&gt; r1[2] = "XX"
        // `r0[n%10]` --&gt; 126 % 10 = 6 --&gt; r0[6] = "VI"
        // FINAL --&gt; "" + "C" + "XX" + "VI" = "CXXVI"
        //
        // This is efficient in Go. The 4 operands are evaluated,
        // then a single allocation is made of the exact size needed for the result.
        <span class="cov8" title="1">return r3[n%1e4/1e3] + r2[n%1e3/1e2] + r1[n%100/10] + r0[n%10], nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// rgbhex.go
// description: convert hex input to red, green and blue and vice versa
// author(s) [darmiel](https://github.com/darmiel)
// see rgbhex_test.go

package conversion

// HEXToRGB splits an RGB input (e.g. a color in hex format; 0x&lt;color-code&gt;)
// into the individual components: red, green and blue
func HEXToRGB(hex uint) (red, green, blue byte) <span class="cov8" title="1">{
        // A hex code is structured like this:
        // #3498db (light blue) - converted to binary:
        // 00110100 10011000 11011011
        //  &lt;red&gt;   &lt;green&gt;   &lt;blue&gt;

        // To get the blue value we use the bit operation AND with the bit mask 0xFF (in binary: 11111111)
        // 00110100 10011000 &lt;11011011&gt; &amp;
        // 00000000 00000000  11111111  =
        // 00000000 00000000 &lt;11011011&gt; =
        blue = byte(hex &amp; 0xFF)

        // To get the green value, we first shift the value 8 bits to the right:
        //  00110100 &lt;10011000&gt;  11011011  &gt;&gt; 8 =
        //  00000000  00110100  &lt;10011000&gt; &amp;
        //  00000000  00000000   11111111  =
        //  00000000  00000000  &lt;10011000&gt; =
        green = byte((hex &gt;&gt; 8) &amp; 0xFF)

        // Same as green value, only this time shift 16 to the right
        // Alternatively, you can apply a bitmask first and then shift it.
        // &lt;00110100&gt; 10011000  11011011 &amp;
        //  11111111  00000000  00000000 =
        // &lt;00110100&gt; 00000000  00000000 &gt;&gt; 16
        //  00000000  00000000 &lt;00110100&gt; =
        red = byte((hex &gt;&gt; 16) &amp; 0xFF)
        return
}</span>

// RGBToHEX does exactly the opposite of HEXToRGB:
// it combines the three components red, green and blue to an RGB value, which can be converted to e.g. Hex
func RGBToHEX(red, green, blue byte) (hex uint) <span class="cov8" title="1">{
        // Sets the bits of blue in position 1-8, green in 9-16 and red in 17-24

        // Red: 00110100
        // Green: 10011000
        // Blue: 11011011
        // RGB:
        // R &lt;&lt; 16: [00110100]  00000000   00000000 |
        // G &lt;&lt; 8 :  00000000  {10011000}  00000000 |
        // B      :  00000000   00000000  &lt;11011011&gt; =
        //          [00110100] {10011000} &lt;11011011&gt;
        return (uint(red) &lt;&lt; 16) | (uint(green) &lt;&lt; 8) | uint(blue)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// This algorithm will convert a standard roman number to an integer
// https://en.wikipedia.org/wiki/Roman_numerals
// Function receives a string as a roman number and outputs an integer
// Maximum output will be 3999
// Only standard form is supported

package conversion

import (
        "errors"
        "strings"
)

// numeral describes the value and symbol of a single roman numeral
type numeral struct {
        val int
        sym string
}

// lookup array for numeral values sorted by largest to smallest
var nums = []numeral{
        {1000, "M"},
        {900, "CM"},
        {500, "D"},
        {400, "CD"},
        {100, "C"},
        {90, "XC"},
        {50, "L"},
        {40, "XL"},
        {10, "X"},
        {9, "IX"},
        {5, "V"},
        {4, "IV"},
        {1, "I"},
}

// RomanToInt converts a roman numeral string to an integer. Roman numerals for numbers
// outside the range 1 to 3,999 will return an error. Nil or empty string return 0
// with no error thrown.
func RomanToInt(input string) (int, error) <span class="cov8" title="1">{
        if input == "" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">var output int
        for _, n := range nums </span><span class="cov8" title="1">{
                for strings.HasPrefix(input, n.sym) </span><span class="cov8" title="1">{
                        output += n.val
                        input = input[len(n.sym):]
                }</span>
        }
        // if we are still left with input string values then the
        // input was invalid and an error is returned.
        <span class="cov8" title="1">if len(input) &gt; 0 </span><span class="cov8" title="1">{
                return 0, errors.New("invalid roman numeral")
        }</span>
        <span class="cov8" title="1">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// File: abbreviation.go
// Description: Abbreviation problem
// Details:
//   https://www.hackerrank.com/challenges/abbr/problem
// Problem description (from hackerrank):
//   You can perform the following operations on the string, a:
//   1. Capitalize zero or more of a's lowercase letters.
//   2. Delete all of the remaining lowercase letters in a.
//   Given 2 strings a and b, determine if it's possible to make a equal to be using above operations.
// Example:
//         Given a = "ABcde" and b = "ABCD"
//   We can capitalize "c" and "d" in a to get "ABCde" then delete all the lowercase letters (which is only "e") in a to get "ABCD" which equals b.
// Author: [duongoku](https://github.com/duongoku)
// See abbreviation_test.go for test cases

package dynamic

// strings for getting uppercases and lowercases
import (
        "strings"
)

// Returns true if it is possible to make a equals b (if b is an abbreviation of a), returns false otherwise
func Abbreviation(a string, b string) bool <span class="cov8" title="1">{
        dp := make([][]bool, len(a)+1)
        for i := range dp </span><span class="cov8" title="1">{
                dp[i] = make([]bool, len(b)+1)
        }</span>
        <span class="cov8" title="1">dp[0][0] = true

        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt;= len(b); j++ </span><span class="cov8" title="1">{
                        if dp[i][j] </span><span class="cov8" title="1">{
                                if j &lt; len(b) &amp;&amp; strings.ToUpper(string(a[i])) == string(b[j]) </span><span class="cov8" title="1">{
                                        dp[i+1][j+1] = true
                                }</span>
                                <span class="cov8" title="1">if string(a[i]) == strings.ToLower(string(a[i])) </span><span class="cov8" title="1">{
                                        dp[i+1][j] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return dp[len(a)][len(b)]</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package dynamic

import "github.com/TheAlgorithms/Go/math/min"

// func main() {
//         myArrayOfK := [4]int{5, 6, 7, 8}
//         var x int

//         fmt.Println("\nBinomial Coefficient Using Dynamic Programming:", bin2(50, 5))
//         for _, element := range myArrayOfK {
//                 start := time.Now()
//                 x = bin2(50, element)
//                 elapsed := time.Since(start)
//                 fmt.Println("bin2 (50,", element, ") = ", x, "    took ", elapsed)

//         }

// }

// Bin2 function
func Bin2(n int, k int) int <span class="cov8" title="1">{
        var i, j int
        B := make([][]int, (n + 1))
        for i := range B </span><span class="cov8" title="1">{
                B[i] = make([]int, k+1)
        }</span>

        <span class="cov8" title="1">for i = 0; i &lt;= n; i++ </span><span class="cov8" title="1">{
                for j = 0; j &lt;= min.Int(i, k); j++ </span><span class="cov8" title="1">{
                        if j == 0 || j == i </span><span class="cov8" title="1">{
                                B[i][j] = 1
                        }</span> else<span class="cov8" title="1"> {
                                B[i][j] = B[i-1][j-1] + B[i-1][j]
                        }</span>
                }
        }
        <span class="cov8" title="1">return B[n][k]</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">//The Catalan numbers are a sequence of positive integers that appear in many counting
//problems in combinatorics.
//reference: https://brilliant.org/wiki/catalan-numbers/

package dynamic

import "fmt"

var errCatalan = fmt.Errorf("can't have a negative n-th catalan number")

// NthCatalan returns the n-th Catalan Number
// Complexity: O(n²)
func NthCatalanNumber(n int) (int64, error) <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov8" title="1">{
                //doesn't accept negative number
                return 0, errCatalan
        }</span>

        <span class="cov8" title="1">var catalanNumberList []int64
        catalanNumberList = append(catalanNumberList, 1) //first value is 1

        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                catalanNumberList = append(catalanNumberList, 0) //append 0 and calculate

                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        catalanNumberList[i] += catalanNumberList[j] * catalanNumberList[i-j-1]
                }</span>
        }

        <span class="cov8" title="1">return catalanNumberList[n], nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package dynamic

// CoinChange finds the number of possible combinations of coins
// of different values which can get to the target amount.
func CoinChange(coins []int32, amount int32) int32 <span class="cov8" title="1">{
        combination := make([]int32, amount)
        combination[0] = 1

        for _, c := range coins </span><span class="cov8" title="1">{
                for i := c; i &lt; amount; i++ </span><span class="cov8" title="1">{

                        combination[i] += combination[i-c]
                }</span>
        }

        <span class="cov8" title="1">return combination[amount-1]</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// EDIT DISTANCE PROBLEM
// https://www.geeksforgeeks.org/edit-distance-dp-5/
// https://leetcode.com/problems/edit-distance/

package dynamic

import "github.com/TheAlgorithms/Go/math/min"

// EditDistanceRecursive is a naive implementation with exponential time complexity.
func EditDistanceRecursive(first string, second string, pointerFirst int, pointerSecond int) int <span class="cov0" title="0">{

        if pointerFirst == 0 </span><span class="cov0" title="0">{
                return pointerSecond
        }</span>

        <span class="cov0" title="0">if pointerSecond == 0 </span><span class="cov0" title="0">{
                return pointerFirst
        }</span>

        // Characters match, so we recur for the remaining portions
        <span class="cov0" title="0">if first[pointerFirst-1] == second[pointerSecond-1] </span><span class="cov0" title="0">{
                return EditDistanceRecursive(first, second, pointerFirst-1, pointerSecond-1)
        }</span>

        // We have three choices, all with cost of 1 unit
        <span class="cov0" title="0">return 1 + min.Int(EditDistanceRecursive(first, second, pointerFirst, pointerSecond-1), // Insert
                EditDistanceRecursive(first, second, pointerFirst-1, pointerSecond),   // Delete
                EditDistanceRecursive(first, second, pointerFirst-1, pointerSecond-1))</span> // Replace
}

// EditDistanceDP is an optimised implementation which builds on the ideas of the recursive implementation.
// We use dynamic programming to compute the DP table where dp[i][j] denotes the edit distance value
// of first[0..i-1] and second[0..j-1]. Time complexity is O(m * n) where m and n are lengths of the strings,
// first and second respectively.
func EditDistanceDP(first string, second string) int <span class="cov8" title="1">{

        m := len(first)
        n := len(second)

        // Create the DP table
        dp := make([][]int, m+1)
        for i := 0; i &lt;= m; i++ </span><span class="cov8" title="1">{
                dp[i] = make([]int, n+1)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= m; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt;= n; j++ </span><span class="cov8" title="1">{

                        if i == 0 </span><span class="cov8" title="1">{
                                dp[i][j] = j
                                continue</span>
                        }

                        <span class="cov8" title="1">if j == 0 </span><span class="cov8" title="1">{
                                dp[i][j] = i
                                continue</span>
                        }

                        <span class="cov8" title="1">if first[i-1] == second[j-1] </span><span class="cov8" title="1">{
                                dp[i][j] = dp[i-1][j-1]
                                continue</span>
                        }

                        <span class="cov8" title="1">dp[i][j] = 1 + min.Int(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])</span>
                }
        }

        <span class="cov8" title="1">return dp[m][n]</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package dynamic

// https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/

// NthFibonacci returns the nth Fibonacci Number
func NthFibonacci(n uint) uint <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // n1 and n2 are the (i-1)th and ith Fibonacci numbers, respectively
        <span class="cov8" title="1">var n1, n2 uint = 0, 1

        for i := uint(1); i &lt; n; i++ </span><span class="cov8" title="1">{
                n3 := n1 + n2
                n1 = n2
                n2 = n3
        }</span>

        <span class="cov8" title="1">return n2</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package dynamic

// Knapsack Problem
// https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/

import (
        "math"
)

// Max function - possible duplicate
func Max(a, b int) int <span class="cov8" title="1">{
        return int(math.Max(float64(a), float64(b)))
}</span>

// Knapsack solves knapsack problem
// return maxProfit
func Knapsack(maxWeight int, weights, values []int) int <span class="cov8" title="1">{
        n := len(weights)
        m := maxWeight
        // create dp data structure
        dp := make([][]int, n+1)
        for i := range dp </span><span class="cov8" title="1">{
                dp[i] = make([]int, m+1)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(weights); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt;= maxWeight; j++ </span><span class="cov8" title="1">{
                        if weights[i] &gt; j </span><span class="cov8" title="1">{
                                dp[i+1][j] = dp[i][j]
                        }</span> else<span class="cov8" title="1"> {
                                dp[i+1][j] = Max(dp[i][j-weights[i]]+values[i], dp[i][j])
                        }</span>
                }
        }
        <span class="cov8" title="1">return dp[n][m]</span>
}

/*
func main() {
        maxWeight := 50
        values := []int{
                60, 100, 120,
        }
        weights := []int{
                10, 20, 30,
        }
        maxProfit := Knapsack(maxWeight, weights, values)
        fmt.Println(maxProfit)
}
*/
</pre>
		
		<pre class="file" id="file23" style="display: none">// LONGEST COMMON SUBSEQUENCE
// DP - 4
// https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/

package dynamic

func strToRuneSlice(s string) (r []rune, size int) <span class="cov8" title="1">{
        r = []rune(s)
        return r, len(r)
}</span>

// LongestCommonSubsequence function
func LongestCommonSubsequence(a string, b string) int <span class="cov8" title="1">{
        aRunes, aLen := strToRuneSlice(a)
        bRunes, bLen := strToRuneSlice(b)

        // here we are making a 2d slice of size (aLen+1)*(bLen+1)
        lcs := make([][]int, aLen+1)
        for i := 0; i &lt;= aLen; i++ </span><span class="cov8" title="1">{
                lcs[i] = make([]int, bLen+1)
        }</span>

        // block that implements LCS
        <span class="cov8" title="1">for i := 0; i &lt;= aLen; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt;= bLen; j++ </span><span class="cov8" title="1">{
                        if i == 0 || j == 0 </span><span class="cov8" title="1">{
                                lcs[i][j] = 0
                        }</span> else<span class="cov8" title="1"> if aRunes[i-1] == bRunes[j-1] </span><span class="cov8" title="1">{
                                lcs[i][j] = lcs[i-1][j-1] + 1
                        }</span> else<span class="cov8" title="1"> {
                                lcs[i][j] = Max(lcs[i-1][j], lcs[i][j-1])
                        }</span>
                }
        }
        // returning the length of longest common subsequence
        <span class="cov8" title="1">return lcs[aLen][bLen]</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package dynamic

import (
        "github.com/TheAlgorithms/Go/math/max"
)

// LongestIncreasingSubsequence returns the longest increasing subsequence
// where all elements of the subsequence are sorted in increasing order
func LongestIncreasingSubsequence(elements []int) int <span class="cov8" title="1">{
        n := len(elements)
        lis := make([]int, n)
        for i := range lis </span><span class="cov8" title="1">{
                lis[i] = 1
        }</span>
        <span class="cov8" title="1">for i := range lis </span><span class="cov8" title="1">{
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        if elements[i] &gt; elements[j] &amp;&amp; lis[i] &lt; lis[j]+1 </span><span class="cov8" title="1">{
                                lis[i] = lis[j] + 1
                        }</span>
                }
        }
        <span class="cov8" title="1">res := 0
        for _, value := range lis </span><span class="cov8" title="1">{
                res = max.Int(res, value)
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package dynamic

// LongestIncreasingSubsequenceGreedy is a function to find the longest increasing
// subsequence in a given array using a greedy approach.
// The dynamic programming approach is implemented alongside this one.
// Worst Case Time Complexity: O(nlogn)
// Auxiliary Space: O(n), where n is the length of the array(slice).
// Reference: https://www.geeksforgeeks.org/construction-of-longest-monotonically-increasing-subsequence-n-log-n/
func LongestIncreasingSubsequenceGreedy(nums []int) int <span class="cov8" title="1">{
        longestIncreasingSubsequence := make([]int, 0)

        for _, num := range nums </span><span class="cov8" title="1">{
                // find the leftmost index in longestIncreasingSubsequence with value &gt;= num
                leftmostIndex := lowerBound(longestIncreasingSubsequence, num)

                if leftmostIndex == len(longestIncreasingSubsequence) </span><span class="cov8" title="1">{
                        longestIncreasingSubsequence = append(longestIncreasingSubsequence, num)
                }</span> else<span class="cov8" title="1"> {
                        longestIncreasingSubsequence[leftmostIndex] = num
                }</span>
        }

        <span class="cov8" title="1">return len(longestIncreasingSubsequence)</span>
}

// Function to find the leftmost index in arr with value &gt;= val, mimicking the inbuild lower_bound function in C++
// Time Complexity: O(logn)
// Auxiliary Space: O(1)
func lowerBound(arr []int, val int) int <span class="cov8" title="1">{
        searchWindowLeft, searchWindowRight := 0, len(arr)-1

        for searchWindowLeft &lt;= searchWindowRight </span><span class="cov8" title="1">{
                middle := (searchWindowLeft + searchWindowRight) / 2

                if arr[middle] &lt; val </span><span class="cov8" title="1">{
                        searchWindowLeft = middle + 1
                }</span> else<span class="cov8" title="1"> {
                        searchWindowRight = middle - 1
                }</span>
        }

        <span class="cov8" title="1">return searchWindowRight + 1</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// longest palindromic subsequence
// http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/

package dynamic

func lpsRec(word string, i, j int) int <span class="cov8" title="1">{
        if i == j </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">if i &gt; j </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if word[i] == word[j] </span><span class="cov8" title="1">{
                return 2 + lpsRec(word, i+1, j-1)
        }</span>
        <span class="cov8" title="1">return Max(lpsRec(word, i, j-1), lpsRec(word, i+1, j))</span>
}

// LpsRec function
func LpsRec(word string) int <span class="cov8" title="1">{
        return lpsRec(word, 0, len(word)-1)
}</span>

// LpsDp function
func LpsDp(word string) int <span class="cov8" title="1">{
        N := len(word)
        dp := make([][]int, N)

        for i := 0; i &lt; N; i++ </span><span class="cov8" title="1">{
                dp[i] = make([]int, N)
                dp[i][i] = 1
        }</span>

        <span class="cov8" title="1">for l := 2; l &lt;= N; l++ </span><span class="cov8" title="1">{
                // for length l
                for i := 0; i &lt; N-l+1; i++ </span><span class="cov8" title="1">{
                        j := i + l - 1
                        if word[i] == word[j] </span><span class="cov8" title="1">{
                                if l == 2 </span><span class="cov8" title="1">{
                                        dp[i][j] = 2
                                }</span> else<span class="cov8" title="1"> {
                                        dp[i][j] = 2 + dp[i+1][j-1]
                                }</span>
                        } else<span class="cov8" title="1"> {
                                dp[i][j] = Max(dp[i+1][j], dp[i][j-1])
                        }</span>
                }
        }

        <span class="cov8" title="1">return dp[0][N-1]</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// matrix chain multiplication problem
// https://en.wikipedia.org/wiki/Matrix_chain_multiplication
// www.geeksforgeeks.org/dynamic_programming-set-8-matrix-chain-multiplication/

package dynamic

import "github.com/TheAlgorithms/Go/math/min"

// MatrixChainRec function
func MatrixChainRec(D []int, i, j int) int <span class="cov0" title="0">{
        // d[i-1] x d[i] : dimension of matrix i
        if i == j </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">q := 1 &lt;&lt; 32
        for k := i; k &lt; j; k++ </span><span class="cov0" title="0">{
                prod := MatrixChainRec(D, i, k) + MatrixChainRec(D, k+1, j) + D[i-1]*D[k]*D[j]
                q = min.Int(prod, q)
        }</span>
        <span class="cov0" title="0">return q</span>
}

// MatrixChainDp function
func MatrixChainDp(D []int) int <span class="cov0" title="0">{
        // d[i-1] x d[i] : dimension of matrix i
        N := len(D)

        dp := make([][]int, N) // dp[i][j] = matrixChainRec(D, i, j)
        for i := 0; i &lt; N; i++ </span><span class="cov0" title="0">{
                dp[i] = make([]int, N)
                dp[i][i] = 0
        }</span>

        <span class="cov0" title="0">for l := 2; l &lt; N; l++ </span><span class="cov0" title="0">{
                for i := 1; i &lt; N-l+1; i++ </span><span class="cov0" title="0">{
                        j := i + l - 1
                        dp[i][j] = 1 &lt;&lt; 31
                        for k := i; k &lt; j; k++ </span><span class="cov0" title="0">{
                                prod := dp[i][k] + dp[k+1][j] + D[i-1]*D[k]*D[j]
                                dp[i][j] = min.Int(prod, dp[i][j])
                        }</span>
                }
        }

        <span class="cov0" title="0">return dp[1][N-1]</span>
}

/*
func main() {
        D := []int{2, 2, 2, 2, 2} // 4 matrices
        fmt.Print(matrixChainRec(D, 1, 4), "\n")
        fmt.Print(matrixChainDp(D), "\n")
}
*/
</pre>
		
		<pre class="file" id="file28" style="display: none">// Solution to Rod cutting problem
// https://en.wikipedia.org/wiki/Cutting_stock_problem
// http://www.geeksforgeeks.org/dynamic-programming-set-13-cutting-a-rod/

package dynamic

// CutRodRec solve the problem recursively: initial approach
func CutRodRec(price []int, length int) int <span class="cov8" title="1">{
        if length == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">q := -1
        for i := 1; i &lt;= length; i++ </span><span class="cov8" title="1">{
                q = Max(q, price[i]+CutRodRec(price, length-i))
        }</span>
        <span class="cov8" title="1">return q</span>
}

// CutRodDp solve the same problem using dynamic programming
func CutRodDp(price []int, length int) int <span class="cov8" title="1">{
        r := make([]int, length+1) // a.k.a the memoization array
        r[0] = 0                   // cost of 0 length rod is 0

        for j := 1; j &lt;= length; j++ </span><span class="cov8" title="1">{ // for each length (subproblem)
                q := -1
                for i := 1; i &lt;= j; i++ </span><span class="cov8" title="1">{
                        q = Max(q, price[i]+r[j-i]) // avoiding recursive call
                }</span>
                <span class="cov8" title="1">r[j] = q</span>
        }

        <span class="cov8" title="1">return r[length]</span>
}

/*
func main() {
        length := 10
        price := []int{0, 1, 5, 8, 9, 17, 17, 17, 20, 24, 30}
        // price := []int{0, 10, 5, 8, 9, 17, 17, 17, 20, 24, 30}

        // fmt.Print(price[5]+price[length-5], "\n")

        fmt.Print(cutRodRec(price, length), "\n")
        fmt.Print(cutRodDp(price, length), "\n")
}
*/
</pre>
		
		<pre class="file" id="file29" style="display: none">//Given a set of non-negative integers, and a (positive) value sum,
//determine if there is a subset of the given set with sum
//equal to given sum.
//Complexity: O(n*sum)
//references: https://www.geeksforgeeks.org/subset-sum-problem-dp-25/

package dynamic

import "fmt"

var ErrInvalidPosition = fmt.Errorf("invalid position in subset")
var ErrNegativeSum = fmt.Errorf("negative sum is not allowed")

func IsSubsetSum(array []int, sum int) (bool, error) <span class="cov8" title="1">{
        if sum &lt; 0 </span><span class="cov8" title="1">{
                //not allow negative sum
                return false, ErrNegativeSum
        }</span>

        //create subset matrix
        <span class="cov8" title="1">arraySize := len(array)
        subset := make([][]bool, arraySize+1)
        for i := 0; i &lt;= arraySize; i++ </span><span class="cov8" title="1">{
                subset[i] = make([]bool, sum+1)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= arraySize; i++ </span><span class="cov8" title="1">{
                //sum 0 is always true
                subset[i][0] = true
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= sum; i++ </span><span class="cov8" title="1">{
                //empty set is false when sum is not 0
                subset[0][i] = false
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= arraySize; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt;= sum; j++ </span><span class="cov8" title="1">{
                        if array[i-1] &gt; j </span><span class="cov8" title="1">{
                                subset[i][j] = subset[i-1][j]
                        }</span>

                        <span class="cov8" title="1">if array[i-1] &lt;= j </span><span class="cov8" title="1">{
                                if j-array[i-1] &lt; 0 || j-array[i-1] &gt; sum </span><span class="cov8" title="1">{
                                        //out of bounds
                                        return false, ErrInvalidPosition
                                }</span>

                                <span class="cov8" title="1">subset[i][j] = subset[i-1][j] || subset[i-1][j-array[i-1]]</span>
                        }
                }
        }

        <span class="cov8" title="1">return subset[arraySize][sum], nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package graph

import "github.com/TheAlgorithms/Go/math/min"

type apHelper struct {
        is_ap              []bool
        visited            []bool
        child_cnt          []int
        discovery_time     []int
        earliest_discovery []int
}

// ArticulationPoint is a function to identify articulation points in a graph.
// The function takes the graph as an argument and returns a boolean slice
// which indicates whether a vertex is an articulation point or not.
// Worst Case Time Complexity: O(|V| + |E|)
// Auxiliary Space: O(|V|)
// reference: https://en.wikipedia.org/wiki/Biconnected_component and https://cptalks.quora.com/Cut-Vertex-Articulation-point
func ArticulationPoint(graph *Graph) []bool <span class="cov8" title="1">{
        // time variable to keep track of the time of discovery_time of a vertex
        time := 0

        //initialize all the variables
        apHelperInstance := &amp;apHelper{
                is_ap:     make([]bool, graph.vertices),
                visited:   make([]bool, graph.vertices),
                child_cnt: make([]int, graph.vertices),
                // integer slice to store the discovery time of a vertex as we traverse
                // the graph in a depth first manner
                discovery_time: make([]int, graph.vertices),
                // integer slice to store the earliest discovered vertex reachable from a vertex
                earliest_discovery: make([]int, graph.vertices),
        }
        articulationPointHelper(
                apHelperInstance,
                0,
                -1,
                &amp;time,
                graph,
        )

        if apHelperInstance.child_cnt[0] == 1 </span><span class="cov8" title="1">{
                // if the root has only one child, it is not an articulation point
                apHelperInstance.is_ap[0] = false
        }</span>

        <span class="cov8" title="1">return apHelperInstance.is_ap</span>
}

// articulationPointHelper is a recursive function to traverse the graph
// and mark articulation points. Based on the depth first search transversal
// of the graph, however modified to keep track and update the
// `child_cnt`, `discovery_time` and `earliest_discovery` slices defined above
func articulationPointHelper(
        apHelperInstance *apHelper,
        vertex int,
        parent int,
        time *int,
        graph *Graph,
) <span class="cov8" title="1">{
        apHelperInstance.visited[vertex] = true

        // Mark the time of discovery of a vertex
        // set the earliest discovery time to the discovered time
        // increment the time
        apHelperInstance.discovery_time[vertex] = *time
        apHelperInstance.earliest_discovery[vertex] = apHelperInstance.discovery_time[vertex]
        *time++

        for next_vertex := range graph.edges[vertex] </span><span class="cov8" title="1">{
                if next_vertex == parent </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if apHelperInstance.visited[next_vertex] </span><span class="cov8" title="1">{
                        apHelperInstance.earliest_discovery[vertex] = min.Int(
                                apHelperInstance.earliest_discovery[vertex],
                                apHelperInstance.discovery_time[next_vertex],
                        )
                        continue</span>
                }

                <span class="cov8" title="1">apHelperInstance.child_cnt[vertex]++
                articulationPointHelper(
                        apHelperInstance,
                        next_vertex,
                        vertex,
                        time,
                        graph,
                )
                apHelperInstance.earliest_discovery[vertex] = min.Int(
                        apHelperInstance.earliest_discovery[vertex],
                        apHelperInstance.earliest_discovery[next_vertex],
                )
                if apHelperInstance.earliest_discovery[next_vertex] &gt;= apHelperInstance.discovery_time[vertex] </span><span class="cov8" title="1">{
                        apHelperInstance.is_ap[vertex] = true
                }</span>

        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// The Bellman–Ford algorithm is an algorithm that computes shortest paths from a
// single source vertex to all of the other vertices in a weighted durected graph.
// It is slower than Dijkstra but capable of handling negative edge weights.
// https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm
// Implementation is based on the book 'Introduction to Algorithms' (CLRS)

package graph

import (
        "errors"
        "math"
)

func (g *Graph) BellmanFord(start, end int) (isReachable bool, distance int, err error) <span class="cov8" title="1">{
        INF := math.Inf(1)
        distances := make([]float64, g.vertices)

        // Set all vertices to unreachable, initialize source
        for i := 0; i &lt; g.vertices; i++ </span><span class="cov8" title="1">{
                distances[i] = INF
        }</span>
        <span class="cov8" title="1">distances[start] = 0

        // Making iterations equal to #vertices
        for n := 0; n &lt; g.vertices; n++ </span><span class="cov8" title="1">{

                // Looping over all edges
                for u, adjacents := range g.edges </span><span class="cov8" title="1">{
                        for v, weightUV := range adjacents </span><span class="cov8" title="1">{

                                // If new shorter distance is found, update distance value (relaxation step)
                                if newDistance := distances[u] + float64(weightUV); distances[v] &gt; newDistance </span><span class="cov8" title="1">{
                                        distances[v] = newDistance
                                }</span>
                        }
                }
        }

        // Check for negative weight cycle
        <span class="cov8" title="1">for u, adjacents := range g.edges </span><span class="cov8" title="1">{
                for v, weightUV := range adjacents </span><span class="cov8" title="1">{
                        if newDistance := distances[u] + float64(weightUV); distances[v] &gt; newDistance </span><span class="cov8" title="1">{
                                return false, -1, errors.New("negative weight cycle present")
                        }</span>
                }
        }

        <span class="cov8" title="1">return distances[end] != INF, int(distances[end]), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package graph

// BreadthFirstSearch is an algorithm for traversing and searching graph data structures.
// It starts at an arbitrary node of a graph, and explores all of the neighbor nodes
// at the present depth prior to moving on to the nodes at the next depth level.
// Worst-case performance                         O(|V|+|E|)=O(b^{d})}O(|V|+|E|)=O(b^{d})
// Worst-case space complexity                 O(|V|)=O(b^{d})}O(|V|)=O(b^{d})
// reference: https://en.wikipedia.org/wiki/Breadth-first_search
func BreadthFirstSearch(start, end, nodes int, edges [][]int) (isConnected bool, distance int) <span class="cov8" title="1">{
        queue := make([]int, 0)
        discovered := make([]int, nodes)
        discovered[start] = 1
        queue = append(queue, start)
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                v := queue[0]
                queue = queue[1:]
                for i := 0; i &lt; len(edges[v]); i++ </span><span class="cov8" title="1">{
                        if discovered[i] == 0 &amp;&amp; edges[v][i] &gt; 0 </span><span class="cov8" title="1">{
                                if i == end </span><span class="cov8" title="1">{
                                        return true, discovered[v]
                                }</span>
                                <span class="cov8" title="1">discovered[i] = discovered[v] + 1
                                queue = append(queue, i)</span>
                        }
                }
        }
        <span class="cov8" title="1">return false, 0</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// This file contains the graph coloring implementation using backtracking
// Author(s): [Shivam](https://github.com/Shivam010)

package coloring

// ColorUsingBacktracking will return the Color of each vertex and the
// total number of different colors used, using backtracking
func (g *Graph) ColorUsingBacktracking() (map[int]Color, int) <span class="cov8" title="1">{
        vertexColors := make(map[int]Color, g.vertices)
        g.colorVertex(0, vertexColors)

        colorsUsed := 0
        for _, cr := range vertexColors </span><span class="cov8" title="1">{
                if colorsUsed &lt; int(cr) </span><span class="cov8" title="1">{
                        colorsUsed = int(cr)
                }</span>
        }
        <span class="cov8" title="1">return vertexColors, colorsUsed</span>
}

// colorVertex will try to color provided vertex, v
func (g *Graph) colorVertex(v int, color map[int]Color) bool <span class="cov8" title="1">{
        // If all vertices are colored, the colors store will be completely filled.
        if len(color) == g.vertices </span><span class="cov8" title="1">{
                return true
        }</span>

        // As the upper bound of no. of colors is the no. of vertices in graph,
        // try assigning each color to the vertex v
        <span class="cov8" title="1">for cr := Color(1); cr &lt;= Color(g.vertices); cr++ </span><span class="cov8" title="1">{
                // Use the color, cr for vertex, v if it is safe to use, by
                // checking its neighbours
                safe := true
                for nb := range g.edges[v] </span><span class="cov8" title="1">{
                        // cr, color is not safe if color of nb, crnb is not equal to cr
                        if crnb, ok := color[nb]; ok &amp;&amp; crnb == cr </span><span class="cov8" title="1">{
                                safe = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if safe </span><span class="cov8" title="1">{
                        color[v] = cr
                        if g.colorVertex(v+1, color) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov0" title="0">delete(color, v)</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// This file contains the graph coloring implementation using BFS
// Author(s): [Shivam](https://github.com/Shivam010)

package coloring

import "container/list"

// ColorUsingBFS will return the Color of each vertex and the
// total number of different colors used, using BFS
func (g *Graph) ColorUsingBFS() (map[int]Color, int) <span class="cov8" title="1">{
        // Initially all vertices will have same color
        vertexColors := make(map[int]Color, g.vertices)
        for i := 0; i &lt; g.vertices; i++ </span><span class="cov8" title="1">{
                vertexColors[i] = 1
        }</span>

        <span class="cov8" title="1">visited := make(map[int]struct{})
        // Run BFS from each non-visited vertex
        for i := 0; i &lt; g.vertices; i++ </span><span class="cov8" title="1">{
                if _, ok := visited[i]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">visited[i] = struct{}{}

                queue := list.New()
                queue.PushBack(i)

                for queue.Len() != 0 </span><span class="cov8" title="1">{
                        // front vertex in the queue
                        frontNode := queue.Front()
                        front := frontNode.Value.(int)
                        queue.Remove(frontNode)

                        // Now, check all neighbours of front vertex, if they have same
                        // color as that of front, change their color
                        for nb := range g.edges[front] </span><span class="cov8" title="1">{
                                if vertexColors[nb] == vertexColors[front] </span><span class="cov8" title="1">{
                                        vertexColors[nb]++
                                }</span>
                                // if the neighbour is not already visited, add it to the queue
                                <span class="cov8" title="1">if _, ok := visited[nb]; !ok </span><span class="cov8" title="1">{
                                        visited[nb] = struct{}{}
                                        queue.PushBack(nb)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">colorsUsed := 0
        for _, cr := range vertexColors </span><span class="cov8" title="1">{
                if colorsUsed &lt; int(cr) </span><span class="cov8" title="1">{
                        colorsUsed = int(cr)
                }</span>
        }
        <span class="cov8" title="1">return vertexColors, colorsUsed</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package coloring

func (g *Graph) TryBipartiteColoring() map[int]Color <span class="cov8" title="1">{
        // 0 is uncolored, 1/2 is colors
        colors := make(map[int]Color)
        visited := make(map[int]bool)

        for i := range g.edges </span><span class="cov8" title="1">{
                colors[i] = 0
                visited[i] = false
        }</span>

        <span class="cov8" title="1">var color_node func(int)
        color_node = func(s int) </span><span class="cov8" title="1">{
                visited[s] = true
                coloring := []Color{0, 2, 1}

                for n := range g.edges[s] </span><span class="cov8" title="1">{
                        if colors[n] == 0 </span><span class="cov8" title="1">{
                                colors[n] = coloring[colors[s]]
                        }</span>
                        <span class="cov8" title="1">if !visited[n] </span><span class="cov8" title="1">{
                                color_node(n)
                        }</span>
                }
        }

        <span class="cov8" title="1">for i := range g.edges </span><span class="cov8" title="1">{
                if colors[i] == 0 </span><span class="cov8" title="1">{
                        colors[i] = 1
                        color_node(i)
                }</span>
        }

        <span class="cov8" title="1">return colors</span>
}

// basically tries to color the graph in two colors if each edge
// connects 2 differently colored nodes the graph can be considered bipartite
func BipartiteCheck(N int, edges [][]int) bool <span class="cov8" title="1">{
        var graph Graph
        for i := 0; i &lt; N; i++ </span><span class="cov8" title="1">{
                graph.AddVertex(i)
        }</span>
        <span class="cov8" title="1">for _, e := range edges </span><span class="cov8" title="1">{
                graph.AddEdge(e[0], e[1])
        }</span>
        <span class="cov8" title="1">return graph.ValidateColorsOfVertex(graph.TryBipartiteColoring()) == nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// This file contains the simple structural implementation of undirected
// graph, used in coloring algorithms.
// Author(s): [Shivam](https://github.com/Shivam010)

package coloring

import "errors"

// Color provides a type for vertex color
type Color int

// Graph provides a structure to store an undirected graph.
// It is safe to use its empty object.
type Graph struct {
        vertices int
        edges    map[int]map[int]struct{}
}

// AddVertex will add a new vertex in the graph, if the vertex already
// exist it will do nothing
func (g *Graph) AddVertex(v int) <span class="cov8" title="1">{
        if g.edges == nil </span><span class="cov8" title="1">{
                g.edges = make(map[int]map[int]struct{})
        }</span>

        // Check if vertex is present or not
        <span class="cov8" title="1">if _, ok := g.edges[v]; !ok </span><span class="cov8" title="1">{
                g.vertices++
                g.edges[v] = make(map[int]struct{})
        }</span>
}

// AddEdge will add a new edge between the provided vertices in the graph
func (g *Graph) AddEdge(one, two int) <span class="cov8" title="1">{
        // Add vertices: one and two to the graph if they are not present
        g.AddVertex(one)
        g.AddVertex(two)

        // and finally add the edges: one-&gt;two and two-&gt;one for undirected graph
        g.edges[one][two] = struct{}{}
        g.edges[two][one] = struct{}{}
}</span>

func (g *Graph) ValidateColorsOfVertex(colors map[int]Color) error <span class="cov8" title="1">{
        if g.vertices != len(colors) </span><span class="cov8" title="1">{
                return errors.New("coloring: not all vertices of graph are colored")
        }</span>
        // check colors
        <span class="cov8" title="1">for vertex, neighbours := range g.edges </span><span class="cov8" title="1">{
                for nb := range neighbours </span><span class="cov8" title="1">{
                        if colors[vertex] == colors[nb] </span><span class="cov8" title="1">{
                                return errors.New("coloring: same colors of neighbouring vertex")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// This file contains the graph coloring implementation using Greedy Approach.
// Author(s): [Shivam](https://github.com/Shivam010)

package coloring

import "sort"

// ColorUsingGreedyApproach will return the Color of each vertex and the
// total number of different colors used, using a greedy approach, based on
// the number of edges (or degree) from any vertex.
func (g *Graph) ColorUsingGreedyApproach() (map[int]Color, int) <span class="cov8" title="1">{
        degreeOfVertex := make([]struct{ degree, vertex int }, 0, g.vertices)
        for v, neighbours := range g.edges </span><span class="cov8" title="1">{
                degreeOfVertex = append(degreeOfVertex,
                        struct{ degree, vertex int }{
                                vertex: v,
                                degree: len(neighbours),
                        },
                )
        }</span>
        // sort the degreeOfVertex in decreasing order of degrees
        <span class="cov8" title="1">sort.Slice(degreeOfVertex, func(i, j int) bool </span><span class="cov8" title="1">{
                return degreeOfVertex[i].degree &gt; degreeOfVertex[j].degree
        }</span>)

        <span class="cov8" title="1">vertexColors := make(map[int]Color, g.vertices)
        // Start with a color and assign the color to all possible vertices in the degreeOfVertex slice
        // and then, re-iterate with new color for all those which are left
        for color := 1; color &lt;= g.vertices; color++ </span><span class="cov8" title="1">{
        vertexLoop:
                for _, val := range degreeOfVertex </span><span class="cov8" title="1">{
                        // skip, if already assigned
                        if _, ok := vertexColors[val.vertex]; ok </span><span class="cov8" title="1">{
                                continue vertexLoop</span>
                        }
                        // Check its neighbours
                        <span class="cov8" title="1">for ng := range g.edges[val.vertex] </span><span class="cov8" title="1">{
                                if vertexColors[ng] == Color(color) </span><span class="cov8" title="1">{
                                        // not possible to use this color for val.vertex
                                        continue vertexLoop</span>
                                }
                        }
                        // Assign color to the vertex
                        <span class="cov8" title="1">vertexColors[val.vertex] = Color(color)</span>
                }
                // continue till all the vertices are colored
                <span class="cov8" title="1">if len(vertexColors) == g.vertices </span><span class="cov8" title="1">{
                        return vertexColors, color
                }</span>
        }
        <span class="cov0" title="0">return vertexColors, g.vertices</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// cycle.go
// this file handle algorithm that related to cycle in graph
// reference: https://en.wikipedia.org/wiki/Cycle_(graph_theory)
// [kiarash hajian](https://github.com/kiarash8112)

package graph

func (g *Graph) HasCycle() bool <span class="cov8" title="1">{
        //this implimetation referred as 3-color too
        all := map[int]struct{}{}
        visiting := map[int]struct{}{}
        visited := map[int]struct{}{}

        for v := range g.edges </span><span class="cov8" title="1">{
                all[v] = struct{}{}
        }</span>

        <span class="cov8" title="1">for current := range all </span><span class="cov8" title="1">{
                if g.hasCycleHelper(current, all, visiting, visited) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>

}

func (g Graph) hasCycleHelper(v int, all, visiting, visited map[int]struct{}) bool <span class="cov8" title="1">{
        delete(all, v)
        visiting[v] = struct{}{}

        neighbors := g.edges[v]
        for v := range neighbors </span><span class="cov8" title="1">{
                if _, ok := visited[v]; ok </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if _, ok := visiting[v]; ok </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov8" title="1"> if g.hasCycleHelper(v, all, visiting, visited) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">delete(visiting, v)
        visited[v] = struct{}{}
        return false</span>
}

// this function can do HasCycle() job but it is slower
func (g *Graph) FindAllCycles() []Graph <span class="cov8" title="1">{
        all := map[int]struct{}{}
        visiting := map[int]struct{}{}
        visited := map[int]struct{}{}

        allCycles := []Graph{}

        for v := range g.edges </span><span class="cov8" title="1">{
                all[v] = struct{}{}
        }</span>

        <span class="cov8" title="1">for current := range all </span><span class="cov8" title="1">{
                foundCycle, parents := g.findAllCyclesHelper(current, all, visiting, visited)

                if foundCycle </span><span class="cov8" title="1">{
                        foundCycleFromCurrent := false
                        //this loop remove additional vertex from detected cycle
                        //using foundCycleFromCurrent bool to make sure after removing vertex we still have cycle
                        for i := len(parents) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                                if parents[i][1] == parents[0][0] </span><span class="cov8" title="1">{
                                        parents = parents[:i+1]
                                        foundCycleFromCurrent = true
                                }</span>
                        }
                        <span class="cov8" title="1">if foundCycleFromCurrent </span><span class="cov8" title="1">{
                                graph := Graph{Directed: true}
                                for _, edges := range parents </span><span class="cov8" title="1">{
                                        graph.AddEdge(edges[1], edges[0])
                                }</span>
                                <span class="cov8" title="1">allCycles = append(allCycles, graph)</span>
                        }

                }

        }

        <span class="cov8" title="1">return allCycles</span>

}

func (g Graph) findAllCyclesHelper(current int, all, visiting, visited map[int]struct{}) (bool, [][]int) <span class="cov8" title="1">{
        parents := [][]int{}

        delete(all, current)
        visiting[current] = struct{}{}

        neighbors := g.edges[current]
        for v := range neighbors </span><span class="cov8" title="1">{
                if _, ok := visited[v]; ok </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if _, ok := visiting[v]; ok </span><span class="cov8" title="1">{
                        parents = append(parents, []int{v, current})
                        return true, parents
                }</span> else<span class="cov8" title="1"> if ok, savedParents := g.findAllCyclesHelper(v, all, visiting, visited); ok </span><span class="cov8" title="1">{
                        parents = append(parents, savedParents...)
                        parents = append(parents, []int{v, current})
                        return true, parents
                }</span>
        }
        <span class="cov0" title="0">delete(visiting, current)
        visited[current] = struct{}{}
        return false, parents</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package graph

func GetIdx(target int, nodes []int) int <span class="cov8" title="1">{
        for i := 0; i &lt; len(nodes); i++ </span><span class="cov8" title="1">{
                if nodes[i] == target </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func NotExist(target int, slice []int) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(slice); i++ </span><span class="cov8" title="1">{
                if slice[i] == target </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func DepthFirstSearchHelper(start, end int, nodes []int, edges [][]bool, showroute bool) ([]int, bool) <span class="cov8" title="1">{
        var route []int
        var stack []int
        startIdx := GetIdx(start, nodes)
        stack = append(stack, startIdx)
        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                now := stack[len(stack)-1]
                route = append(route, nodes[now])
                if len(stack) &gt; 1 </span><span class="cov8" title="1">{
                        stack = stack[:len(stack)-1]
                }</span> else<span class="cov8" title="1"> {
                        stack = stack[:len(stack)-1]
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; len(edges[now]); i++ </span><span class="cov8" title="1">{
                        if edges[now][i] &amp;&amp; NotExist(i, stack) </span><span class="cov8" title="1">{
                                stack = append(stack, i)
                        }</span>
                        <span class="cov8" title="1">edges[now][i] = false
                        edges[i][now] = false</span>
                }
                <span class="cov8" title="1">if route[len(route)-1] == end </span><span class="cov8" title="1">{
                        return route, true
                }</span>
        }

        <span class="cov8" title="1">if showroute </span><span class="cov8" title="1">{
                return route, false
        }</span> else<span class="cov8" title="1"> {
                return nil, false
        }</span>
}

func DepthFirstSearch(start, end int, nodes []int, edges [][]bool) ([]int, bool) <span class="cov8" title="1">{
        return DepthFirstSearchHelper(start, end, nodes, edges, false)
}</span>

// func main() {
//         nodes := []int{
//                 1, 2, 3, 4, 5, 6,
//         }
//         /*
//                 sample graph
//                 ①-②
//                 |  |
//                 ③-④-⑤-⑥
//         */
//         edges := [][]bool{
//                 {false, true, true, false, false, false},
//                 {true, false, false, true, false, false},
//                 {true, false, false, true, false, false},
//                 {false, true, true, false, true, false},
//                 {false, false, false, true, false, true},
//                 {false, false, false, false, true, false},
//         }
//         start := 1
//         end := 6
//         route, _ := dfs(start, end, nodes, edges)
//         fmt.Println(route)
// }
</pre>
		
		<pre class="file" id="file40" style="display: none">package graph

import "github.com/TheAlgorithms/Go/sort"

type Item struct {
        node int
        dist int
}

func (a Item) More(b any) bool <span class="cov8" title="1">{
        // reverse direction for minheap
        return a.dist &lt; b.(Item).dist
}</span>
func (a Item) Idx() int <span class="cov8" title="1">{
        return a.node
}</span>

func (g *Graph) Dijkstra(start, end int) (int, bool) <span class="cov8" title="1">{
        visited := make(map[int]bool)
        nodes := make(map[int]*Item)

        nodes[start] = &amp;Item{
                dist: 0,
                node: start,
        }
        pq := sort.MaxHeap{}
        pq.Init(nil)
        pq.Push(*nodes[start])

        visit := func(curr Item) </span><span class="cov8" title="1">{
                visited[curr.node] = true
                for n, d := range g.edges[curr.node] </span><span class="cov8" title="1">{
                        if visited[n] </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">item := nodes[n]
                        dist2 := curr.dist + d
                        if item == nil </span><span class="cov8" title="1">{
                                nodes[n] = &amp;Item{node: n, dist: dist2}
                                pq.Push(*nodes[n])
                        }</span> else<span class="cov8" title="1"> if item.dist &gt; dist2 </span><span class="cov8" title="1">{
                                item.dist = dist2
                                pq.Update(*item)
                        }</span>
                }
        }

        <span class="cov8" title="1">for pq.Size() &gt; 0 </span><span class="cov8" title="1">{
                curr := pq.Pop().(Item)
                if curr.node == end </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">visit(curr)</span>
        }

        <span class="cov8" title="1">item := nodes[end]
        if item == nil </span><span class="cov8" title="1">{
                return -1, false
        }</span>
        <span class="cov8" title="1">return item.dist, true</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Floyd-Warshall algorithm
// https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm

package graph

import "math"

// WeightedGraph defining matrix to use 2d array easier
type WeightedGraph [][]float64

// Defining maximum value. If two vertices share this value, it means they are not connected
var Inf = math.Inf(1)

// FloydWarshall Returns all pair's shortest path using Floyd Warshall algorithm
func FloydWarshall(graph WeightedGraph) WeightedGraph <span class="cov8" title="1">{
        // If graph is empty, returns nil
        if len(graph) == 0 || len(graph) != len(graph[0]) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(graph); i++ </span><span class="cov8" title="1">{
                //If graph matrix width is different than the height, returns nil
                if len(graph[i]) != len(graph) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">numVertices := len(graph)

        // Initializing result matrix and filling it up with same values as given graph
        result := make(WeightedGraph, numVertices)

        for i := 0; i &lt; numVertices; i++ </span><span class="cov8" title="1">{
                result[i] = make([]float64, numVertices)
                for j := 0; j &lt; numVertices; j++ </span><span class="cov8" title="1">{
                        result[i][j] = graph[i][j]
                }</span>
        }

        // Running over the result matrix and following the algorithm
        <span class="cov8" title="1">for k := 0; k &lt; numVertices; k++ </span><span class="cov8" title="1">{
                for i := 0; i &lt; numVertices; i++ </span><span class="cov8" title="1">{
                        for j := 0; j &lt; numVertices; j++ </span><span class="cov8" title="1">{
                                // If there is a less costly path from i to j node, remembering it
                                if result[i][j] &gt; result[i][k]+result[k][j] </span><span class="cov8" title="1">{
                                        result[i][j] = result[i][k] + result[k][j]
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// This file contains the simple structural implementation of
// directed &amp; undirected graphs used within the graph package
// Author(s): [Shivam](https://github.com/Shivam010), [Tahmeed](https://github.com/Tahmeed156)

package graph

// Graph provides a structure to store the graph.
// It is safe to use its empty object.
type Graph struct {
        vertices int
        edges    map[int]map[int]int // Stores weight of an edge
        Directed bool                // Differentiate directed/undirected graphs
}

// Constructor functions for graphs (undirected by default)
func New(v int) *Graph <span class="cov8" title="1">{
        return &amp;Graph{
                vertices: v,
        }
}</span>

// AddVertex will add a new vertex in the graph.
// If the vertex already exists it will do nothing.
func (g *Graph) AddVertex(v int) <span class="cov8" title="1">{
        if g.edges == nil </span><span class="cov8" title="1">{
                g.edges = make(map[int]map[int]int)
        }</span>

        // Check if vertex is present or not
        <span class="cov8" title="1">if _, ok := g.edges[v]; !ok </span><span class="cov8" title="1">{
                g.edges[v] = make(map[int]int)
        }</span>
}

// AddEdge will add a new edge between the provided vertices in the graph
func (g *Graph) AddEdge(one, two int) <span class="cov8" title="1">{
        // Add an edge with 0 weight
        g.AddWeightedEdge(one, two, 0)
}</span>

// AddWeightedEdge will add a new weighted edge between the provided vertices in the graph
func (g *Graph) AddWeightedEdge(one, two, weight int) <span class="cov8" title="1">{
        // Add vertices: one and two to the graph if they are not present
        g.AddVertex(one)
        g.AddVertex(two)

        // And finally add the edges
        // one-&gt;two and two-&gt;one for undirected graph
        // one-&gt;two for directed graphs
        g.edges[one][two] = weight
        if !g.Directed </span><span class="cov8" title="1">{
                g.edges[two][one] = weight
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// KRUSKAL'S ALGORITHM
// Reference: Kruskal's Algorithm: https://www.scaler.com/topics/data-structures/kruskal-algorithm/
// Reference: Union Find Algorithm: https://www.scaler.com/topics/data-structures/disjoint-set/
// Author: Author: Mugdha Behere[https://github.com/MugdhaBehere]
// Worst Case Time Complexity: O(E log E), where E is the number of edges.
// Worst Case Space Complexity: O(V + E), where V is the number of vertices and E is the number of edges.
// see kruskal.go, kruskal_test.go

package graph

import (
        "sort"
)

type Vertex int

type Edge struct {
        Start  Vertex
        End    Vertex
        Weight int
}

func KruskalMST(n int, edges []Edge) ([]Edge, int) <span class="cov8" title="1">{
        // Initialize variables to store the minimum spanning tree and its total cost
        var mst []Edge
        var cost int

        // Create a new UnionFind data structure with 'n' nodes
        u := NewUnionFind(n)

        // Initialize each node in the UnionFind data structure
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                u.parent[i] = i
                u.size[i] = 1
        }</span>

        // Sort the edges in non-decreasing order based on their weights
        <span class="cov8" title="1">sort.SliceStable(edges, func(i, j int) bool </span><span class="cov8" title="1">{
                return edges[i].Weight &lt; edges[j].Weight
        }</span>)

        // Iterate through the sorted edges
        <span class="cov8" title="1">for _, edge := range edges </span><span class="cov8" title="1">{
                // Check if adding the current edge forms a cycle or not
                if u.Find(int(edge.Start)) != u.Find(int(edge.End)) </span><span class="cov8" title="1">{
                        // Add the edge to the minimum spanning tree
                        mst = append(mst, edge)
                        // Add the weight of the edge to the total cost
                        cost += edge.Weight
                        // Merge the sets containing the start and end vertices of the current edge
                        u = u.Union(int(edge.Start), int(edge.End))
                }</span>
        }

        // Return the minimum spanning tree and its total cost
        <span class="cov8" title="1">return mst, cost</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// lowestcommonancestor.go
// description: Implementation of Lowest common ancestor (LCA) algorithm.
// detail:
// Let `T` be a tree. The LCA of `u` and `v` in T is the shared ancestor of `u` and `v`
// that is located farthest from the root.
// references: [cp-algorithms](https://cp-algorithms.com/graph/lca_binary_lifting.html)
// author(s) [Dat](https://github.com/datbeohbbh)
// see lowestcommonancestor_test.go for a test implementation.

package graph

type TreeEdge struct {
        from int
        to   int
}

type ITree interface {
        dfs(int, int)
        addEdge(int, int)
        GetDepth(int) int
        GetDad(int) int
        GetLCA(int, int) int
}

type Tree struct {
        numbersVertex int
        root          int
        MAXLOG        int
        depth         []int
        dad           []int
        jump          [][]int
        edges         [][]int
}

func (tree *Tree) addEdge(u, v int) <span class="cov8" title="1">{
        tree.edges[u] = append(tree.edges[u], v)
        tree.edges[v] = append(tree.edges[v], u)
}</span>

func (tree *Tree) dfs(u, par int) <span class="cov8" title="1">{
        tree.jump[0][u] = par
        tree.dad[u] = par
        for _, v := range tree.edges[u] </span><span class="cov8" title="1">{
                if v != par </span><span class="cov8" title="1">{
                        tree.depth[v] = tree.depth[u] + 1
                        tree.dfs(v, u)
                }</span>
        }
}

func (tree *Tree) GetDepth(u int) int <span class="cov8" title="1">{
        return tree.depth[u]
}</span>

func (tree *Tree) GetDad(u int) int <span class="cov8" title="1">{
        return tree.dad[u]
}</span>

func (tree *Tree) GetLCA(u, v int) int <span class="cov8" title="1">{
        if tree.GetDepth(u) &lt; tree.GetDepth(v) </span><span class="cov8" title="1">{
                u, v = v, u
        }</span>

        <span class="cov8" title="1">for j := tree.MAXLOG - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if tree.GetDepth(tree.jump[j][u]) &gt;= tree.GetDepth(v) </span><span class="cov8" title="1">{
                        u = tree.jump[j][u]
                }</span>
        }

        <span class="cov8" title="1">if u == v </span><span class="cov8" title="1">{
                return u
        }</span>

        <span class="cov8" title="1">for j := tree.MAXLOG - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if tree.jump[j][u] != tree.jump[j][v] </span><span class="cov8" title="1">{
                        u = tree.jump[j][u]
                        v = tree.jump[j][v]
                }</span>
        }

        <span class="cov8" title="1">return tree.jump[0][u]</span>
}

func NewTree(numbersVertex, root int, edges []TreeEdge) (tree *Tree) <span class="cov8" title="1">{
        tree = new(Tree)
        tree.numbersVertex, tree.root, tree.MAXLOG = numbersVertex, root, 0
        tree.depth = make([]int, numbersVertex)
        tree.dad = make([]int, numbersVertex)

        for (1 &lt;&lt; tree.MAXLOG) &lt;= numbersVertex </span><span class="cov8" title="1">{
                (tree.MAXLOG) += 1
        }</span>
        <span class="cov8" title="1">(tree.MAXLOG) += 1

        tree.jump = make([][]int, tree.MAXLOG)
        for j := 0; j &lt; tree.MAXLOG; j++ </span><span class="cov8" title="1">{
                tree.jump[j] = make([]int, numbersVertex)
        }</span>

        <span class="cov8" title="1">tree.edges = make([][]int, numbersVertex)
        for _, e := range edges </span><span class="cov8" title="1">{
                tree.addEdge(e.from, e.to)
        }</span>

        <span class="cov8" title="1">return tree</span>
}

// For each node, we will precompute its ancestor above him, its ancestor two nodes above, its ancestor four nodes above, etc.
// Let's call `jump[j][u]` is the `2^j`-th ancestor above the node `u` with `u` in range `[0, numbersVertex)`, `j` in range `[0,MAXLOG)`.
// These information allow us to jump from any node to any ancestor above it in `O(MAXLOG)` time.
func LowestCommonAncestor(tree *Tree) <span class="cov8" title="1">{
        // call dfs to compute depth from the root to each node and the parent of each node.
        tree.dfs(tree.root, tree.root)

        // compute jump[j][u]
        for j := 1; j &lt; tree.MAXLOG; j++ </span><span class="cov8" title="1">{
                for u := 0; u &lt; tree.numbersVertex; u++ </span><span class="cov8" title="1">{
                        tree.jump[j][u] = tree.jump[j-1][tree.jump[j-1][u]]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package graph

// Topological assumes that graph given is valid and that its
// possible to get a topological ordering.
// constraints are array of []int{a, b}, representing
// an edge going from a to b
func Topological(N int, constraints [][]int) []int <span class="cov8" title="1">{
        dependencies := make([]int, N)
        nodes := make([]int, N)
        for i := range nodes </span><span class="cov8" title="1">{
                nodes[i] = i
        }</span>
        <span class="cov8" title="1">edges := make([][]bool, N)
        for i := range edges </span><span class="cov8" title="1">{
                edges[i] = make([]bool, N)
        }</span>

        <span class="cov8" title="1">for _, c := range constraints </span><span class="cov8" title="1">{
                a := c[0]
                b := c[1]
                dependencies[b]++
                edges[a][b] = true
        }</span>

        <span class="cov8" title="1">var answer []int
        for s := 0; s &lt; N; s++ </span><span class="cov8" title="1">{
                // Only start walking from top level nodes
                if dependencies[s] == 0 </span><span class="cov8" title="1">{
                        route, _ := DepthFirstSearchHelper(s, N, nodes, edges, true)
                        answer = append(answer, route...)
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Union Find Algorithm or Dynamic Connectivity algorithm, often implemented with the help
//of the union find data structure,
// is used to efficiently maintain connected components in a graph that undergoes dynamic changes,
// such as edges being added or removed over time
// Worst Case Time Complexity: The time complexity of find operation is nearly constant or
//O(α(n)), where where α(n) is the inverse Ackermann function
// practically, this is a very slowly growing function making the time complexity for find
//operation nearly constant.
// The time complexity of the union operation is also nearly constant or O(α(n))
// Worst Case Space Complexity: O(n), where n is the number of nodes or element in the structure
// Reference: https://www.scaler.com/topics/data-structures/disjoint-set/
// Author: Mugdha Behere[https://github.com/MugdhaBehere]
// see: unionfind.go, unionfind_test.go

package graph

// Defining the union-find data structure
type UnionFind struct {
        parent []int
        size   []int
}

// Initialise a new union find data structure with s nodes
func NewUnionFind(s int) UnionFind <span class="cov8" title="1">{
        parent := make([]int, s)
        size := make([]int, s)
        for k := 0; k &lt; s; k++ </span><span class="cov8" title="1">{
                parent[k] = k
                size[k] = 1
        }</span>
        <span class="cov8" title="1">return UnionFind{parent, size}</span>
}

// to find the root of the set to which the given element belongs, the Find function serves the purpose
func (u UnionFind) Find(q int) int <span class="cov8" title="1">{
        for q != u.parent[q] </span><span class="cov8" title="1">{
                q = u.parent[q]
        }</span>
        <span class="cov8" title="1">return q</span>
}

// to merge two sets to which the given elements belong, the Union function serves the purpose
func (u UnionFind) Union(a, b int) UnionFind <span class="cov8" title="1">{
        rootP := u.Find(a)
        rootQ := u.Find(b)

        if rootP == rootQ </span><span class="cov0" title="0">{
                return u
        }</span>

        <span class="cov8" title="1">if u.size[rootP] &lt; u.size[rootQ] </span><span class="cov8" title="1">{
                u.parent[rootP] = rootQ
                u.size[rootQ] += u.size[rootP]
        }</span> else<span class="cov8" title="1"> {
                u.parent[rootQ] = rootP
                u.size[rootP] += u.size[rootQ]
        }</span>
        <span class="cov8" title="1">return u</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// sha256.go
// description: The sha256 cryptographic hash function as defined in the RFC6234 standard.
// author: [Paul Leydier] (https://github.com/paul-leydier)
// ref: https://datatracker.ietf.org/doc/html/rfc6234
// ref: https://en.wikipedia.org/wiki/SHA-2
// see sha256_test.go

package sha256

import (
        "encoding/binary" // Used for interacting with uint at the byte level
        "math/bits"       // Used for bits rotation operations
)

var K = [64]uint32{
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
}

const chunkSize = 64

// pad returns a padded version of the input message, such as the padded message's length is a multiple
// of 512 bits.
// The padding methodology is as follows:
// A "1" bit is appended at the end of the input message, followed by m "0" bits such as the length is
// 64 bits short of a 512 bits multiple. The remaining 64 bits are filled with the initial length of the
// message, represented as a 64-bits unsigned integer.
// For more details, see: https://datatracker.ietf.org/doc/html/rfc6234#section-4.1
func pad(message []byte) []byte <span class="cov8" title="1">{
        L := make([]byte, 8)
        binary.BigEndian.PutUint64(L, uint64(len(message)*8))
        message = append(message, 0x80) // "1" bit followed by 7 "0" bits
        for (len(message)+8)%64 != 0 </span><span class="cov8" title="1">{
                message = append(message, 0x00) // 8 "0" bits
        }</span>
        <span class="cov8" title="1">message = append(message, L...)

        return message</span>
}

// Hash hashes the input message using the sha256 hashing function, and return a 32 byte array.
// The implementation follows the RGC6234 standard, which is documented
// at https://datatracker.ietf.org/doc/html/rfc6234
func Hash(message []byte) [32]byte <span class="cov8" title="1">{
        message = pad(message)

        // Initialize round constants
        h0, h1, h2, h3, h4, h5, h6, h7 := uint32(0x6a09e667), uint32(0xbb67ae85), uint32(0x3c6ef372), uint32(0xa54ff53a),
                uint32(0x510e527f), uint32(0x9b05688c), uint32(0x1f83d9ab), uint32(0x5be0cd19)

        // Iterate through 512-bit chunks
        for chunkStart := 0; chunkStart &lt; len(message); chunkStart += chunkSize </span><span class="cov8" title="1">{
                // Message schedule
                var w [64]uint32
                for i := 0; i*4 &lt; chunkSize; i++ </span><span class="cov8" title="1">{
                        w[i] = binary.BigEndian.Uint32(message[chunkStart+i*4 : chunkStart+(i+1)*4])
                }</span>

                // Extend the 16 bytes chunk to the whole 64 bytes message schedule
                <span class="cov8" title="1">for i := 16; i &lt; 64; i++ </span><span class="cov8" title="1">{
                        s0 := bits.RotateLeft32(w[i-15], -7) ^ bits.RotateLeft32(w[i-15], -18) ^ (w[i-15] &gt;&gt; 3)
                        s1 := bits.RotateLeft32(w[i-2], -17) ^ bits.RotateLeft32(w[i-2], -19) ^ (w[i-2] &gt;&gt; 10)
                        w[i] = w[i-16] + s0 + w[i-7] + s1
                }</span>

                // Actual hashing loop
                <span class="cov8" title="1">a, b, c, d, e, f, g, h := h0, h1, h2, h3, h4, h5, h6, h7
                for i := 0; i &lt; 64; i++ </span><span class="cov8" title="1">{
                        S1 := bits.RotateLeft32(e, -6) ^ bits.RotateLeft32(e, -11) ^ bits.RotateLeft32(e, -25)
                        ch := (e &amp; f) ^ ((^e) &amp; g)
                        tmp1 := h + S1 + ch + K[i] + w[i]
                        S0 := bits.RotateLeft32(a, -2) ^ bits.RotateLeft32(a, -13) ^ bits.RotateLeft32(a, -22)
                        maj := (a &amp; b) ^ (a &amp; c) ^ (b &amp; c)
                        tmp2 := S0 + maj
                        h = g
                        g = f
                        f = e
                        e = d + tmp1
                        d = c
                        c = b
                        b = a
                        a = tmp1 + tmp2
                }</span>
                <span class="cov8" title="1">h0 += a
                h1 += b
                h2 += c
                h3 += d
                h4 += e
                h5 += f
                h6 += g
                h7 += h</span>
        }

        // Export digest
        <span class="cov8" title="1">digest := [32]byte{}
        binary.BigEndian.PutUint32(digest[:4], h0)
        binary.BigEndian.PutUint32(digest[4:8], h1)
        binary.BigEndian.PutUint32(digest[8:12], h2)
        binary.BigEndian.PutUint32(digest[12:16], h3)
        binary.BigEndian.PutUint32(digest[16:20], h4)
        binary.BigEndian.PutUint32(digest[20:24], h5)
        binary.BigEndian.PutUint32(digest[24:28], h6)
        binary.BigEndian.PutUint32(digest[28:], h7)

        return digest</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// abs.go
// description: Absolute value
// details:
// In mathematics, the absolute value or modulus of a real number x, denoted |x|, is the non-negative value of x without regard to its sign. [Absolute value](https://en.wikipedia.org/wiki/Average#Arithmetic_mean)
// author(s) [red_byte](https://github.com/i-redbyte)
// see abs_test.go

package math

// Abs returns absolute value
func Abs(n int) int <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov8" title="1">{
                return -n
        }</span>
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// aliquotsum.go
// description: Returns s(n)
// details:
// the aliquot sum s(n) of a positive integer n
// is the sum of all proper divisors of n,
// that is, all divisors of n other than n itself
// wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see aliquotsum_test.go

package math

// This function returns s(n) for given number
func AliquotSum(n int) (int, error) <span class="cov8" title="1">{
        switch </span>{
        case n &lt; 0:<span class="cov8" title="1">
                return 0, ErrPosArgsOnly</span>
        case n == 0:<span class="cov8" title="1">
                return 0, ErrNonZeroArgsOnly</span>
        default:<span class="cov8" title="1">
                var sum int
                for i := 1; i &lt;= n/2; i++ </span><span class="cov8" title="1">{
                        if n%i == 0 </span><span class="cov8" title="1">{
                                sum += i
                        }</span>
                }
                <span class="cov8" title="1">return sum, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// isarmstrong.go
// description: Checks if the given number is armstrong number or not
// details: An Armstrong number is a n-digit number that is equal to the sum of each of its digits taken to the nth power.
// ref: https://mathlair.allfunandgames.ca/armstrong.php
// author: Kavitha J

package armstrong

import (
        "math"
        "strconv"
)

func IsArmstrong(number int) bool <span class="cov8" title="1">{
        var rightMost int
        var sum int = 0
        var tempNum int = number

        // to get the number of digits in the number
        length := float64(len(strconv.Itoa(number)))

        // get the right most digit and break the loop once all digits are iterated
        for tempNum &gt; 0 </span><span class="cov8" title="1">{
                rightMost = tempNum % 10
                sum += int(math.Pow(float64(rightMost), length))

                // update the input digit minus the processed rightMost
                tempNum /= 10
        }</span>

        <span class="cov8" title="1">return number == sum</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package binary

// Abs returns absolute value using binary operation
// Principle of operation:
// 1) Get the mask by right shift by the base
// 2) Base is the size of an integer variable in bits, for example, for int32 it will be 32, for int64 it will be 64
// 3) For negative numbers, above step sets mask as 1 1 1 1 1 1 1 1 and 0 0 0 0 0 0 0 0 for positive numbers.
// 4) Add the mask to the given number.
// 5) XOR of mask + n and mask gives the absolute value.
func Abs(base, n int) int <span class="cov8" title="1">{
        m := n &gt;&gt; (base - 1)
        return (n + m) ^ m
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// arithmeticmean.go
// description: Arithmetic mean
// details:
// The most common type of average is the arithmetic mean. If n numbers are given, each number denoted by ai (where i = 1,2, ..., n), the arithmetic mean is the sum of the as divided by n or - [Arithmetic mean](https://en.wikipedia.org/wiki/Average#Arithmetic_mean)
// author(s) [red_byte](https://github.com/i-redbyte)
// see arithmeticmean_test.go

// Package binary describes algorithms that use binary operations for different calculations.
package binary

// MeanUsingAndXor This function finds arithmetic mean using "AND" and "XOR" operations
func MeanUsingAndXor(a int, b int) int <span class="cov8" title="1">{
        return ((a ^ b) &gt;&gt; 1) + (a &amp; b)
}</span>

// MeanUsingRightShift This function finds arithmetic mean using right shift
func MeanUsingRightShift(a int, b int) int <span class="cov8" title="1">{
        return (a + b) &gt;&gt; 1
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// bitcounter.go
// description: Counts the number of set bits in a number
// details:
// For unsigned integer number N, return the number of bits set to 1 - [Bit numbering](https://en.wikipedia.org/wiki/Bit_numbering)
// author(s) [red_byte](https://github.com/i-redbyte)
// see bitcounter_test.go

package binary

// BitCounter - The function returns the number of set bits for an unsigned integer number
func BitCounter(n uint) int <span class="cov8" title="1">{
        counter := 0
        for n != 0 </span><span class="cov8" title="1">{
                if n&amp;1 == 1 </span><span class="cov8" title="1">{
                        counter++
                }</span>
                <span class="cov8" title="1">n &gt;&gt;= 1</span>
        }
        <span class="cov8" title="1">return counter</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// checkisnumberpoweroftwo.go
// description: Is the number a power of two
// details:
// Checks if a number is a power of two- [Power of two](https://en.wikipedia.org/wiki/Power_of_two)
// author(s) [red_byte](https://github.com/i-redbyte)
// see checkisnumberpoweroftwo_test.go

package binary

// IsPowerOfTwo This function uses the fact that powers of 2 are represented
// like 10...0 in binary, and numbers one less than the power of 2
// are represented like 11...1.
// Therefore, using the and function:
//
//          10...0
//        &amp; 01...1
//          00...0 -&gt; 0
//
// This is also true for 0, which is not a power of 2, for which we
// have to add and extra condition.
func IsPowerOfTwo(x int) bool <span class="cov8" title="1">{
        return x &gt; 0 &amp;&amp; (x&amp;(x-1)) == 0
}</span>

// IsPowerOfTwoLeftShift This function takes advantage of the fact that left shifting a number
// by 1 is equivalent to multiplying by 2. For example, binary 00000001 when shifted by 3 becomes 00001000,
// which in decimal system is 8 or = 2 * 2 * 2
func IsPowerOfTwoLeftShift(number uint) bool <span class="cov8" title="1">{
        for p := uint(1); p &lt;= number; p = p &lt;&lt; 1 </span><span class="cov8" title="1">{
                if number == p </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Calculating the inverse square root
// [See more](https://en.wikipedia.org/wiki/Fast_inverse_square_root)

package binary

import (
        "math"
)

// FastInverseSqrt assumes that argument is always positive,
// and it does not deal with negative numbers.
// The "magic" number 0x5f3759df is hex for 1597463007 in decimals.
// The math.Float32bits is alias to *(*uint32)(unsafe.Pointer(&amp;f))
// and math.Float32frombits is to *(*float32)(unsafe.Pointer(&amp;b)).
func FastInverseSqrt(number float32) float32 <span class="cov8" title="1">{
        var i uint32
        var y, x2 float32
        const threehalfs float32 = 1.5

        x2 = number * float32(0.5)
        y = number
        i = math.Float32bits(y)   // evil floating point bit level hacking
        i = 0x5f3759df - (i &gt;&gt; 1) // magic number and bitshift hacking
        y = math.Float32frombits(i)

        y = y * (threehalfs - (x2 * y * y)) // 1st iteration of Newton's method
        y = y * (threehalfs - (x2 * y * y)) // 2nd iteration, this can be removed
        return y
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// author(s) [red_byte](https://github.com/i-redbyte)
// see logarithm_test.go

package binary

// LogBase2 Finding the exponent of n = 2**x using bitwise operations (logarithm in base 2 of n) [See more](https://en.wikipedia.org/wiki/Logarithm)
func LogBase2(n uint32) uint32 <span class="cov8" title="1">{
        base := [5]uint32{0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000}
        exponents := [5]uint32{1, 2, 4, 8, 16}
        var result uint32
        for i := 4; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if n&amp;base[i] != 0 </span><span class="cov8" title="1">{
                        n &gt;&gt;= exponents[i]
                        result |= exponents[i]
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// rbc.go
// description: Reflected binary code (RBC)
// details:
// The reflected binary code (RBC), also known just as reflected binary (RB) or Gray code after Frank Gray, is an ordering of the binary numeral system such that two successive values differ in only one bit (binary digit). - [RBC](https://en.wikipedia.org/wiki/Gray_code)
// author(s) [red_byte](https://github.com/i-redbyte)
// see rbc_test.go

package binary

// SequenceGrayCode The function generates an "Gray code" sequence of length n
func SequenceGrayCode(n uint) []uint <span class="cov8" title="1">{
        result := make([]uint, 0)
        var i uint
        for i = 0; i &lt; 1&lt;&lt;n; i++ </span><span class="cov8" title="1">{
                result = append(result, i^(i&gt;&gt;1))
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// reversebits.go
// description: Reverse bits
// details:
// Reverse the bits of an integer number
// author(s) [red_byte](https://github.com/i-redbyte)
// see reversebits_test.go

package binary

// ReverseBits This function initialized the result by 0 (all bits 0) and process the given number starting
// from its least significant bit. If the current bit is 1, set the corresponding most significant bit in the result
// and finally move on to the next bit in the input number.
// Repeat this till all its bits are processed.
func ReverseBits(number uint) uint <span class="cov8" title="1">{
        result := uint(0)
        intSize := 31
        for number != 0 </span><span class="cov8" title="1">{
                result += (number &amp; 1) &lt;&lt; intSize
                number = number &gt;&gt; 1
                intSize -= 1
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// sqrt.go
// description: Square root calculation
// details:
// Calculating the square root using binary operations and a magic number 0x5f3759df [See more](https://en.wikipedia.org/wiki/Fast_inverse_square_root)
// author(s) [red_byte](https://github.com/i-redbyte)
// see sqrt_test.go

package binary

func Sqrt(n float32) float32 <span class="cov8" title="1">{ return 1 / FastInverseSqrt(n) }</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// xorsearch.go
// description: Find a missing number in a sequence
// details:
// Given an array A containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. - [xor](https://en.wikipedia.org/wiki/Exclusive_or)
// author(s) [red_byte](https://github.com/i-redbyte)
// see xorsearch_test.go

package binary

// XorSearchMissingNumber This function finds a missing number in a sequence
func XorSearchMissingNumber(a []int) int <span class="cov8" title="1">{
        n := len(a)
        result := len(a)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                result ^= i ^ a[i]
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// binomialcoefficient.go
// description: Returns C(n, k)
// details:
// a binomial coefficient C(n,k) gives number ways
// in which k objects can be chosen from n objects.
// wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see binomialcoefficient_test.go

package math

import (
        "errors"
)

var ErrPosArgsOnly error = errors.New("arguments must be positive")

// C is Binomial Coefficient function
// This function returns C(n, k) for given n and k
func Combinations(n int, k int) (int, error) <span class="cov8" title="1">{
        if n &lt; 0 || k &lt; 0 </span><span class="cov8" title="1">{
                return -1, ErrPosArgsOnly
        }</span>
        <span class="cov8" title="1">if k &gt; (n - k) </span><span class="cov8" title="1">{
                k = n - k
        }</span>
        <span class="cov8" title="1">res := 1
        for i := 0; i &lt; k; i++ </span><span class="cov8" title="1">{
                res *= (n - i)
                res /= (i + 1)
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// catalannumber.go
// description: Returns the Catalan number
// details:
// In combinatorial mathematics, the Catalan numbers are a sequence of natural numbers that occur in various counting problems, often involving recursively defined objects. - [Catalan number](https://en.wikipedia.org/wiki/Catalan_number)
// The input is the number of the Catalan number n, at the output we get the value of the number
// author(s) [red_byte](https://github.com/i-redbyte)
// see catalannumber_test.go

package catalan

import (
        f "github.com/TheAlgorithms/Go/math/factorial"
)

// CatalanNumber This function returns the `nth` Catalan number
func CatalanNumber(n int) int <span class="cov8" title="1">{
        return f.Iterative(n*2) / (f.Iterative(n) * f.Iterative(n+1))
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package math

import (
        "math"
)

// IsPowOfTwoUseLog This function checks if a number is a power of two using the logarithm.
// The limiting degree can be from 0 to 63.
// See alternatives in the binary package.
func IsPowOfTwoUseLog(number float64) bool <span class="cov8" title="1">{
        if number == 0 || math.Round(number) == math.MaxInt64 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">log := math.Log2(number)
        return log == math.Round(log)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// author(s) [red_byte](https://github.com/i-redbyte)
// see cos_test.go

package math

import "math"

// Cos  returns the cosine of the radian argument x. [See more](https://en.wikipedia.org/wiki/Sine_and_cosine)
// [Based on the idea of Bhaskara approximation of cos(x)](https://math.stackexchange.com/questions/3886552/bhaskara-approximation-of-cosx)
func Cos(x float64) float64 <span class="cov8" title="1">{
        tp := 1.0 / (2.0 * math.Pi)
        x *= tp
        x -= 0.25 + math.Floor(x+0.25)
        x *= 16.0 * (math.Abs(x) - 0.5)
        x += 0.225 * x * (math.Abs(x) - 1.0) //Extra precision
        return x
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package math

// Phi is the Euler totient function.
// This function computes the number of numbers less then n that are coprime with n.
func Phi(n int64) int64 <span class="cov8" title="1">{
        result := n
        for i := int64(2); i*i &lt;= n; i += 1 </span><span class="cov8" title="1">{
                if n%i == 0 </span><span class="cov8" title="1">{
                        for </span><span class="cov8" title="1">{
                                if n%i != 0 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">n /= i</span>
                        }
                        <span class="cov8" title="1">result -= result / i</span>
                }
        }

        <span class="cov8" title="1">if n &gt; 1 </span><span class="cov8" title="1">{
                result -= result / n
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// factorial.go
// description: Calculating factorial
// details:
// The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n - [Factorial](https://en.wikipedia.org/wiki/Factorial)
// author(s) [red_byte](https://github.com/i-redbyte)
// see factorial_test.go

// Package factorial describes algorithms Factorials calculations.
package factorial

// Iterative returns the iteratively brute forced factorial of n
func Iterative(n int) int <span class="cov8" title="1">{
        result := 1
        for i := 2; i &lt;= n; i++ </span><span class="cov8" title="1">{
                result *= i
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Recursive This function recursively computes the factorial of a number
func Recursive(n int) int <span class="cov8" title="1">{
        if n == 1 </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> {
                return n * Recursive(n-1)
        }</span>
}

// UsingTree This function finds the factorial of a number using a binary tree
func UsingTree(n int) int <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if n == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">if n == 1 || n == 2 </span><span class="cov8" title="1">{
                return n
        }</span>
        <span class="cov8" title="1">return prodTree(2, n)</span>
}

func prodTree(l int, r int) int <span class="cov8" title="1">{
        if l &gt; r </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">if l == r </span><span class="cov8" title="1">{
                return l
        }</span>
        <span class="cov8" title="1">if r-l == 1 </span><span class="cov8" title="1">{
                return l * r
        }</span>
        <span class="cov8" title="1">m := (l + r) / 2
        return prodTree(l, m) * prodTree(m+1, r)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">// fibonacci.go
// description: Get the nth Fibonacci Number
// details:
// In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. [Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number)
// author(s) [red_byte](https://github.com/i-redbyte)
// see fibonacci_test.go

package fibonacci

import (
        "math"
)

// Matrix This function calculates the n-th fibonacci number using the matrix method. [See](https://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form)
func Matrix(n uint) uint <span class="cov8" title="1">{
        a, b := 1, 1
        c, rc, tc := 1, 0, 0
        d, rd := 0, 1

        for n != 0 </span><span class="cov8" title="1">{
                if n&amp;1 == 1 </span><span class="cov8" title="1">{
                        tc = rc
                        rc = rc*a + rd*c
                        rd = tc*b + rd*d
                }</span>

                <span class="cov8" title="1">ta := a
                tb := b
                tc = c
                a = a*a + b*c
                b = ta*b + b*d
                c = c*ta + d*c
                d = tc*tb + d*d

                n &gt;&gt;= 1</span>
        }
        <span class="cov8" title="1">return uint(rc)</span>
}

// Formula This function calculates the n-th fibonacci number using the [formula](https://en.wikipedia.org/wiki/Fibonacci_number#Relation_to_the_golden_ratio)
// Attention! Tests for large values fall due to rounding error of floating point numbers, works well, only on small numbers
func Formula(n uint) uint <span class="cov8" title="1">{
        sqrt5 := math.Sqrt(5)
        phi := (sqrt5 + 1) / 2
        powPhi := math.Pow(phi, float64(n))
        return uint(powPhi/sqrt5 + 0.5)
}</span>

// Recursive calculates the n-th fibonacci number recursively by adding the previous two Fibonacci numbers.
// This algorithm is extremely slow for bigger numbers, but provides a simpler implementation.
func Recursive(n uint) uint <span class="cov8" title="1">{
        if n &lt;= 1 </span><span class="cov8" title="1">{
                return n
        }</span>

        <span class="cov8" title="1">return Recursive(n-1) + Recursive(n-2)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// extended.go
// description: Implementation of Extended GCD Algorithm
// details:
// A simple implementation of Extended GCD algorithm, that returns GCD, a and b
// which solves ax + by = gcd(a, b)
// author(s) [Taj](https://github.com/tjgurwara99)
// see extended_test.go

package gcd

// Extended simple extended gcd
func Extended(a, b int64) (int64, int64, int64) <span class="cov8" title="1">{
        if a == 0 </span><span class="cov8" title="1">{
                return b, 0, 1
        }</span>
        <span class="cov8" title="1">gcd, xPrime, yPrime := Extended(b%a, a)
        return gcd, yPrime - (b/a)*xPrime, xPrime</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package gcd

// ExtendedRecursive finds and returns gcd(a, b), x, y satisfying a*x + b*y = gcd(a, b).
func ExtendedRecursive(a, b int64) (int64, int64, int64) <span class="cov8" title="1">{
        if b &gt; 0 </span><span class="cov8" title="1">{
                d, y, x := ExtendedRecursive(b, a%b)
                y -= (a / b) * x
                return d, x, y
        }</span>

        <span class="cov8" title="1">return a, 1, 0</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package gcd

// ExtendedIterative finds and returns gcd(a, b), x, y satisfying a*x + b*y = gcd(a, b).
func ExtendedIterative(a, b int64) (int64, int64, int64) <span class="cov8" title="1">{
        var u, y, v, x int64 = 1, 1, 0, 0
        for a &gt; 0 </span><span class="cov8" title="1">{
                var q int64 = b / a
                x, u = u, x-q*u
                y, v = v, y-q*v
                b, a = a, b-q*a
        }</span>
        <span class="cov8" title="1">return b, x, y</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package gcd

// Recursive finds and returns the greatest common divisor of a given integer.
func Recursive(a, b int64) int64 <span class="cov8" title="1">{
        if b == 0 </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return Recursive(b, a%b)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package gcd

// Iterative Faster iterative version of GcdRecursive without holding up too much of the stack
func Iterative(a, b int64) int64 <span class="cov8" title="1">{
        for b != 0 </span><span class="cov8" title="1">{
                a, b = b, a%b
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// distance.go
// Find Euclidean distance between two points
// author(s) [Chetan Patil](https://github.com/Chetan07j)

// Package geometry contains geometric algorithms
package geometry

import (
        "errors"
        "math"
)

// EuclideanPoint defines a point with x and y coordinates.
type EuclideanPoint []float64

var ErrDimMismatch = errors.New("mismatched dimensions")

// EuclideanDistance returns the Euclidean distance between points in
// any `n` dimensional Euclidean space.
func EuclideanDistance(p1 EuclideanPoint, p2 EuclideanPoint) (float64, error) <span class="cov8" title="1">{
        n := len(p1)

        if len(p2) != n </span><span class="cov8" title="1">{
                return -1, ErrDimMismatch
        }</span>

        <span class="cov8" title="1">var total float64 = 0

        for i, x_i := range p1 </span><span class="cov8" title="1">{
                // using Abs since the value could be negative but we require the magnitude
                diff := math.Abs(x_i - p2[i])
                total += diff * diff
        }</span>

        <span class="cov8" title="1">return math.Sqrt(total), nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Package geometry contains geometric algorithms
package geometry

import (
        "math"
)

// Point defines a point with x and y coordinates.
type Point struct {
        X, Y float64
}

type Line struct {
        P1, P2 Point
}

// Distance calculates the shortest distance between two points.
func Distance(a, b *Point) float64 <span class="cov8" title="1">{
        return math.Sqrt(math.Pow(a.X-b.X, 2) + math.Pow(a.Y-b.Y, 2))
}</span>

// Section calculates the Point that divides a line in specific ratio.
// DO NOT specify the ratio in the form m:n, specify it as r, where r = m / n.
func Section(p1, p2 *Point, r float64) Point <span class="cov8" title="1">{
        var point Point
        point.X = (r*p2.X + p1.X) / (r + 1)
        point.Y = (r*p2.Y + p1.Y) / (r + 1)
        return point
}</span>

// Slope calculates the slope (gradient) of a line.
func Slope(l *Line) float64 <span class="cov8" title="1">{
        return (l.P2.Y - l.P1.Y) / (l.P2.X - l.P1.X)
}</span>

// YIntercept calculates the Y-Intercept of a line from a specific Point.
func YIntercept(p *Point, slope float64) float64 <span class="cov8" title="1">{
        return p.Y - (slope * p.X)
}</span>

// IsParallel checks if two lines are parallel or not.
func IsParallel(l1, l2 *Line) bool <span class="cov8" title="1">{
        return Slope(l1) == Slope(l2)
}</span>

// IsPerpendicular checks if two lines are perpendicular or not.
func IsPerpendicular(l1, l2 *Line) bool <span class="cov8" title="1">{
        return Slope(l1)*Slope(l2) == -1
}</span>

// PointDistance calculates the distance of a given Point from a given line.
// The slice should contain the coefficiet of x, the coefficient of y and the constant in the respective order.
func PointDistance(p *Point, equation [3]float64) float64 <span class="cov8" title="1">{
        return math.Abs(equation[0]*p.X+equation[1]*p.Y+equation[2]) / math.Sqrt(math.Pow(equation[0], 2)+math.Pow(equation[1], 2))
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// isautomorphic.go
// description: Checks whether a whole number integer is Automorphic or not. If number &lt; 0 then returns false.
// details:
// In mathematics, a number n is said to be a Automorphic number if the square of n ends in the same digits as n itself.
// ref: (https://en.wikipedia.org/wiki/Automorphic_number)
// time complexity: O(log10(N))
// space complexity: O(1)
// author: [SilverDragonOfR](https://github.com/SilverDragonOfR)

package math

import (
        "github.com/TheAlgorithms/Go/constraints"
)

func IsAutomorphic[T constraints.Integer](n T) bool <span class="cov8" title="1">{
        // handling the negetive number case
        if n &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">n_sq := n * n
        for n &gt; 0 </span><span class="cov8" title="1">{
                if (n % 10) != (n_sq % 10) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">n /= 10
                n_sq /= 10</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// filename : krishnamurthy.go
// description: A program which contains the function that returns true if a given number is Krishnamurthy number or not.
// details: A number is a Krishnamurthy number if the sum of all the factorials of the digits is equal to the number.
// Ex: 1! = 1, 145 = 1! + 4! + 5!
// author(s): [GooMonk](https://github.com/GooMonk)
// see krishnamurthy_test.go
package math

import "github.com/TheAlgorithms/Go/constraints"

// IsKrishnamurthyNumber returns if the provided number n is a Krishnamurthy number or not.
func IsKrishnamurthyNumber[T constraints.Integer](n T) bool <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Preprocessing: Using a slice to store the digit Factorials
        <span class="cov8" title="1">digitFact := make([]T, 10)
        digitFact[0] = 1 // 0! = 1

        for i := 1; i &lt; 10; i++ </span><span class="cov8" title="1">{
                digitFact[i] = digitFact[i-1] * T(i)
        }</span>

        // Subtract the digit Facotorial from the number
        <span class="cov8" title="1">nTemp := n
        for n &gt; 0 </span><span class="cov8" title="1">{
                nTemp -= digitFact[n%10]
                n /= 10
        }</span>
        <span class="cov8" title="1">return nTemp == 0</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package math

import (
        "github.com/TheAlgorithms/Go/search"
        "github.com/TheAlgorithms/Go/sort"
)

// FindKthMax returns the kth large element given an integer slice
// with nil `error` if found and returns -1 with `error` `search.ErrNotFound`
// if not found. NOTE: The `nums` slice gets mutated in the process.
func FindKthMax(nums []int, k int) (int, error) <span class="cov8" title="1">{
        index := len(nums) - k
        return kthNumber(nums, index)
}</span>

// FindKthMin returns kth small element given an integer slice
// with nil `error` if found and returns -1 with `error` `search.ErrNotFound`
// if not found. NOTE: The `nums` slice gets mutated in the process.
func FindKthMin(nums []int, k int) (int, error) <span class="cov8" title="1">{
        index := k - 1
        return kthNumber(nums, index)
}</span>

// kthNumber use the selection algorithm (based on the partition method - the same one as used in quicksort).
func kthNumber(nums []int, k int) (int, error) <span class="cov8" title="1">{
        if k &lt; 0 || k &gt;= len(nums) </span><span class="cov8" title="1">{
                return -1, search.ErrNotFound
        }</span>
        <span class="cov8" title="1">start := 0
        end := len(nums) - 1
        for start &lt;= end </span><span class="cov8" title="1">{
                pivot := sort.Partition(nums, start, end)
                if k == pivot </span><span class="cov8" title="1">{
                        return nums[pivot], nil
                }</span>
                <span class="cov8" title="1">if k &gt; pivot </span><span class="cov8" title="1">{
                        start = pivot + 1
                        continue</span>
                }
                <span class="cov8" title="1">end = pivot - 1</span>
        }
        <span class="cov0" title="0">return -1, search.ErrNotFound</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package lcm

import (
        "math"

        "github.com/TheAlgorithms/Go/math/gcd"
)

// Lcm returns the lcm of two numbers using the fact that lcm(a,b) * gcd(a,b) = | a * b |
func Lcm(a, b int64) int64 <span class="cov8" title="1">{
        return int64(math.Abs(float64(a*b)) / float64(gcd.Iterative(a, b)))
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package math

// Lerp or Linear interpolation
// This function will return new value in 't' percentage  between 'v0' and 'v1'
func Lerp(v0, v1, t float64) float64 <span class="cov8" title="1">{
        // see: https://en.wikipedia.org/wiki/Linear_interpolation
        return (1-t)*v0 + t*v1
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">// liouville.go
// description: Returns λ(n)
// details:
// For any positive integer n, define λ(n) as the sum of the primitive nth roots of unity.
// It has values in {−1, 1} depending on the factorization of n into prime factors:
//   λ(n) = +1 if n is a positive integer with an even number of prime factors.
//   λ(n) = −1 if n is a positive integer with an odd number of prime factors.
// wikipedia: https://en.wikipedia.org/wiki/Liouville_function
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see liouville_test.go

package math

import (
        "errors"

        "github.com/TheAlgorithms/Go/math/prime"
)

var ErrNonZeroArgsOnly error = errors.New("arguments cannot be zero")

// Lambda is the liouville function
// This function returns λ(n) for given number
func LiouvilleLambda(n int) (int, error) <span class="cov8" title="1">{
        switch </span>{
        case n &lt; 0:<span class="cov8" title="1">
                return 0, ErrPosArgsOnly</span>
        case n == 0:<span class="cov8" title="1">
                return 0, ErrNonZeroArgsOnly</span>
        case len(prime.Factorize(int64(n)))%2 == 0:<span class="cov8" title="1">
                return 1, nil</span>
        default:<span class="cov8" title="1">
                return -1, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package matrix

import (
        "context"
        "errors"
        "sync"
)

// Add adds two matrices.
func (m1 Matrix[T]) Add(m2 Matrix[T]) (Matrix[T], error) <span class="cov8" title="1">{
        // Check if the matrices have the same dimensions.
        if !m1.MatchDimensions(m2) </span><span class="cov8" title="1">{
                return Matrix[T]{}, errors.New("matrices are not compatible for addition")
        }</span>

        // Create a new matrix to store the result.
        <span class="cov8" title="1">var zeroVal T
        result := New(m1.Rows(), m1.Columns(), zeroVal)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        for i := 0; i &lt; m1.rows; i++ </span><span class="cov8" title="1">{
                i := i // Capture the loop variable for the goroutine
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for j := 0; j &lt; m1.columns; j++ </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span> // Context canceled; return without an error
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">sum := m1.elements[i][j] + m2.elements[i][j]
                                err := result.Set(i, j, sum)
                                if err != nil </span><span class="cov0" title="0">{
                                        cancel() // Cancel the context on error
                                        select </span>{
                                        case errCh &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                }()
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Check for any errors
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package matrix

// CheckEqual checks if the current matrix is equal to another matrix (m2).
// Two matrices are considered equal if they have the same dimensions and
// all their elements are equal.
func (m1 Matrix[T]) CheckEqual(m2 Matrix[T]) bool <span class="cov8" title="1">{
        if !m1.MatchDimensions(m2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">c := make(chan bool)

        for i := range m1.elements </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        for j := range m1.elements[i] </span><span class="cov8" title="1">{
                                if m1.elements[i][j] != m2.elements[i][j] </span><span class="cov8" title="1">{
                                        c &lt;- false
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">c &lt;- true</span>
                }(i)
        }

        <span class="cov8" title="1">for range m1.elements </span><span class="cov8" title="1">{
                if !&lt;-c </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package matrix

import "sync"

func (m Matrix[T]) Copy() (Matrix[T], error) <span class="cov8" title="1">{

        rows := m.Rows()
        columns := m.Columns()
        if rows == 0 || columns == 0 </span><span class="cov8" title="1">{
                return Matrix[T]{}, nil
        }</span>
        <span class="cov8" title="1">zeroVal, err := m.Get(0, 0) // Get the zero value of the element type
        if err != nil </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>
        <span class="cov8" title="1">copyMatrix := New(rows, columns, zeroVal)
        var wg sync.WaitGroup
        wg.Add(rows)
        errChan := make(chan error, 1)

        for i := 0; i &lt; rows; i++ </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for j := 0; j &lt; columns; j++ </span><span class="cov8" title="1">{
                                val, err := m.Get(i, j)
                                if err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case errChan &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                                <span class="cov8" title="1">err = copyMatrix.Set(i, j, val)
                                if err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case errChan &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                }(i)
        }

        <span class="cov8" title="1">wg.Wait()
        close(errChan)

        if err, ok := &lt;-errChan; ok </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>

        <span class="cov8" title="1">return copyMatrix, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package matrix

import "github.com/TheAlgorithms/Go/constraints"

// IsValid checks if the input matrix has consistent row lengths.
func IsValid[T constraints.Integer](elements [][]T) bool <span class="cov8" title="1">{
        if len(elements) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">columns := len(elements[0])
        for _, row := range elements </span><span class="cov8" title="1">{
                if len(row) != columns </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package matrix

// MatchDimensions checks if two matrices have the same dimensions.
func (m Matrix[T]) MatchDimensions(m1 Matrix[T]) bool <span class="cov8" title="1">{
        if m.rows == m1.rows &amp;&amp; m.columns == m1.columns </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package matrix

import (
        "errors"
        "sync"

        "github.com/TheAlgorithms/Go/constraints"
)

type Matrix[T constraints.Integer] struct {
        elements [][]T
        rows     int
        columns  int
}

// NewMatrix creates a new Matrix based on the provided arguments.
func New[T constraints.Integer](rows, columns int, initial T) Matrix[T] <span class="cov8" title="1">{
        if rows &lt; 0 || columns &lt; 0 </span><span class="cov0" title="0">{
                return Matrix[T]{} // Invalid dimensions, return an empty matrix
        }</span>

        // Initialize the matrix with the specified dimensions and fill it with the initial value.
        <span class="cov8" title="1">elements := make([][]T, rows)
        var wg sync.WaitGroup
        wg.Add(rows)

        for i := range elements </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        elements[i] = make([]T, columns)
                        for j := range elements[i] </span><span class="cov8" title="1">{
                                elements[i][j] = initial
                        }</span>
                }(i)
        }

        <span class="cov8" title="1">wg.Wait()

        return Matrix[T]{elements, rows, columns}</span>
}

// NewFromElements creates a new Matrix from the given elements.
func NewFromElements[T constraints.Integer](elements [][]T) (Matrix[T], error) <span class="cov8" title="1">{
        if !IsValid(elements) </span><span class="cov8" title="1">{
                return Matrix[T]{}, errors.New("rows have different numbers of columns")
        }</span>
        <span class="cov8" title="1">rows := len(elements)
        if rows == 0 </span><span class="cov8" title="1">{
                return Matrix[T]{}, nil // Empty matrix
        }</span>

        <span class="cov8" title="1">columns := len(elements[0])
        matrix := Matrix[T]{
                elements: make([][]T, rows),
                rows:     rows,    // Set the rows field
                columns:  columns, // Set the columns field
        }
        for i := range matrix.elements </span><span class="cov8" title="1">{
                matrix.elements[i] = make([]T, columns)
                copy(matrix.elements[i], elements[i])
        }</span>

        <span class="cov8" title="1">return matrix, nil</span>
}

func (m Matrix[T]) Get(row, col int) (T, error) <span class="cov8" title="1">{
        if row &lt; 0 || row &gt;= m.rows || col &lt; 0 || col &gt;= m.columns </span><span class="cov8" title="1">{
                var zeroVal T
                return zeroVal, errors.New("index out of range")
        }</span>
        <span class="cov8" title="1">return m.elements[row][col], nil</span>
}

func (m Matrix[T]) Set(row, col int, val T) error <span class="cov8" title="1">{
        if row &lt; 0 || row &gt;= m.rows || col &lt; 0 || col &gt;= m.columns </span><span class="cov8" title="1">{
                return errors.New("index out of bounds")
        }</span>

        <span class="cov8" title="1">m.elements[row][col] = val
        return nil</span>
}

func (m Matrix[T]) Rows() int <span class="cov8" title="1">{
        return len(m.elements)
}</span>

func (m Matrix[T]) Columns() int <span class="cov8" title="1">{
        if len(m.elements) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(m.elements[0])</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package matrix

import (
        "context"
        "errors"
        "sync"
)

// Multiply multiplies the current matrix (m1) with another matrix (m2) and returns the result as a new matrix.
func (m1 Matrix[T]) Multiply(m2 Matrix[T]) (Matrix[T], error) <span class="cov8" title="1">{
        // Check if the matrices can be multiplied.
        if m1.Columns() != m2.Rows() </span><span class="cov8" title="1">{
                return Matrix[T]{}, errors.New("matrices cannot be multiplied: column count of the first matrix must match row count of the second matrix")
        }</span>

        // Create a new matrix to store the result.
        <span class="cov8" title="1">var zeroVal T
        result := New(m1.Rows(), m2.Columns(), zeroVal)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        for i := 0; i &lt; m1.Rows(); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; m2.Columns(); j++ </span><span class="cov8" title="1">{
                        i, j := i, j // Capture the loop variable for the goroutine
                        wg.Add(1)
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                // Compute the dot product of the row from the first matrix and the column from the second matrix.
                                dotProduct := zeroVal
                                for k := 0; k &lt; m1.Columns(); k++ </span><span class="cov8" title="1">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span> // Context canceled; return without an error
                                        default:<span class="cov8" title="1"></span>
                                        }

                                        <span class="cov8" title="1">val1, err := m1.Get(i, k)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cancel()
                                                select </span>{
                                                case errCh &lt;- err:<span class="cov0" title="0"></span>
                                                default:<span class="cov0" title="0"></span>
                                                }
                                                <span class="cov0" title="0">return</span>
                                        }
                                        <span class="cov8" title="1">val2, err := m2.Get(k, j)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cancel()
                                                select </span>{
                                                case errCh &lt;- err:<span class="cov0" title="0"></span>
                                                default:<span class="cov0" title="0"></span>
                                                }
                                                <span class="cov0" title="0">return</span>
                                        }
                                        <span class="cov8" title="1">dotProduct += val1 * val2</span>
                                }
                                <span class="cov8" title="1">err := result.Set(i, j, dotProduct)
                                if err != nil </span><span class="cov0" title="0">{
                                        cancel()
                                        select </span>{
                                        case errCh &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                        }()
                }
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Check for any errors
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// filename: strassenmatrixmultiply.go
// description: Implements matrix multiplication using the Strassen algorithm.
// details:
// This program takes two matrices as input and performs matrix multiplication
// using the Strassen algorithm, which is an optimized divide-and-conquer
// approach. It allows for efficient multiplication of large matrices.
// author(s): Mohit Raghav(https://github.com/mohit07raghav19)
// See strassenmatrixmultiply_test.go for test cases
package matrix

// Perform matrix multiplication using Strassen's algorithm
func (A Matrix[T]) StrassenMatrixMultiply(B Matrix[T]) (Matrix[T], error) <span class="cov8" title="1">{
        n := A.rows
        // Check if matrices are 2x2 or smaller
        if n == 1 </span><span class="cov8" title="1">{
                a1, err := A.Get(0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">b1, err := B.Get(0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">result := New(1, 1, a1*b1)
                return result, nil</span>
        } else<span class="cov8" title="1"> {
                // Calculate the size of submatrices
                mid := n / 2

                // Create submatrices
                A11, err := A.SubMatrix(0, 0, mid, mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A12, err := A.SubMatrix(0, mid, mid, n-mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A21, err := A.SubMatrix(mid, 0, n-mid, mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A22, err := A.SubMatrix(mid, mid, n-mid, n-mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">B11, err := B.SubMatrix(0, 0, mid, mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">B12, err := B.SubMatrix(0, mid, mid, n-mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">B21, err := B.SubMatrix(mid, 0, n-mid, mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">B22, err := B.SubMatrix(mid, mid, n-mid, n-mid)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                // Calculate result submatrices
                <span class="cov8" title="1">A1, err := A11.Add(A22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">A2, err := B11.Add(B22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">A3, err := A21.Add(A22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">A4, err := A11.Add(A12)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">A5, err := B11.Add(B12)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                <span class="cov8" title="1">A6, err := B21.Add(B22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                //
                <span class="cov8" title="1">S1, err := B12.Subtract(B22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">S2, err := B21.Subtract(B11)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">S3, err := A21.Subtract(A11)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">S4, err := A12.Subtract(A22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                // Recursive steps
                <span class="cov8" title="1">M1, err := A1.StrassenMatrixMultiply(A2)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M2, err := A3.StrassenMatrixMultiply(B11)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M3, err := A11.StrassenMatrixMultiply(S1)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M4, err := A22.StrassenMatrixMultiply(S2)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M5, err := A4.StrassenMatrixMultiply(B22)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M6, err := S3.StrassenMatrixMultiply(A5)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">M7, err := S4.StrassenMatrixMultiply(A6)

                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span> //
                <span class="cov8" title="1">A7, err := M1.Add(M4)

                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A8, err := A7.Add(M7)

                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A9, err := M1.Add(M3)

                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">A10, err := A9.Add(M6)

                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                // Calculate result submatrices
                <span class="cov8" title="1">C11, err := A8.Subtract(M5)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">C12, err := M3.Add(M5)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">C21, err := M2.Add(M4)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>
                <span class="cov8" title="1">C22, err := A10.Subtract(M2)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix[T]{}, err
                }</span>

                // Combine subMatrices into the result matrix
                <span class="cov8" title="1">var zeroVal T
                C := New(n, n, zeroVal)

                for i := 0; i &lt; mid; i++ </span><span class="cov8" title="1">{
                        for j := 0; j &lt; mid; j++ </span><span class="cov8" title="1">{
                                val, err := C11.Get(i, j)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err
                                }</span>

                                <span class="cov8" title="1">err = C.Set(i, j, val)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err
                                }</span>

                                <span class="cov8" title="1">val, err = C12.Get(i, j)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err
                                }</span>

                                <span class="cov8" title="1">err1 := C.Set(i, j+mid, val)
                                if err1 != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err1
                                }</span>
                                <span class="cov8" title="1">val, err = C21.Get(i, j)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err
                                }</span>

                                <span class="cov8" title="1">err2 := C.Set(i+mid, j, val)
                                if err2 != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err2
                                }</span>
                                <span class="cov8" title="1">val, err = C22.Get(i, j)
                                if err != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err
                                }</span>

                                <span class="cov8" title="1">err3 := C.Set(i+mid, j+mid, val)
                                if err3 != nil </span><span class="cov0" title="0">{
                                        return Matrix[T]{}, err3
                                }</span>
                        }
                }
                <span class="cov8" title="1">return C, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package matrix

import "fmt"

// String implements the fmt.Stringer interface for Matrix.
func (m Matrix[T]) String() string <span class="cov8" title="1">{
        var result string
        for i := range m.elements </span><span class="cov8" title="1">{
                for j := range m.elements[i] </span><span class="cov8" title="1">{
                        result += fmt.Sprintf("%v ", m.elements[i][j])
                }</span>
                <span class="cov8" title="1">result += "\n"</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package matrix

import (
        "context"
        "errors"
        "sync"
)

// SubMatrix extracts a submatrix from the current matrix.
func (m Matrix[T]) SubMatrix(rowStart, colStart, numRows, numCols int) (Matrix[T], error) <span class="cov8" title="1">{
        if rowStart &lt; 0 || colStart &lt; 0 || numRows &lt; 0 || numCols &lt; 0 </span><span class="cov0" title="0">{
                return Matrix[T]{}, errors.New("negative dimensions are not allowed")
        }</span>

        <span class="cov8" title="1">if rowStart+numRows &gt; m.rows || colStart+numCols &gt; m.columns </span><span class="cov8" title="1">{
                return Matrix[T]{}, errors.New("submatrix dimensions exceed matrix bounds")
        }</span>

        <span class="cov8" title="1">var zeroVal T
        if numRows == 0 || numCols == 0 </span><span class="cov0" title="0">{
                return New(numRows, numCols, zeroVal), nil // Return an empty matrix
        }</span>

        <span class="cov8" title="1">subMatrix := New(numRows, numCols, zeroVal)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        for i := 0; i &lt; numRows; i++ </span><span class="cov8" title="1">{
                i := i // Capture the loop variable for the goroutine
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for j := 0; j &lt; numCols; j++ </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span> // Context canceled; return without an error
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">val, err := m.Get(rowStart+i, colStart+j)
                                if err != nil </span><span class="cov0" title="0">{
                                        cancel()
                                        select </span>{
                                        case errCh &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }

                                <span class="cov8" title="1">err = subMatrix.Set(i, j, val)
                                if err != nil </span><span class="cov0" title="0">{
                                        cancel()
                                        select </span>{
                                        case errCh &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                }()
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Check for any errors
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>

        <span class="cov8" title="1">return subMatrix, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package matrix

import (
        "context"
        "errors"
        "sync"
)

// Subtract subtracts two matrices.
func (m1 Matrix[T]) Subtract(m2 Matrix[T]) (Matrix[T], error) <span class="cov8" title="1">{
        // Check if the matrices have the same dimensions.
        if !m1.MatchDimensions(m2) </span><span class="cov8" title="1">{
                return Matrix[T]{}, errors.New("matrices are not compatible for subtraction")
        }</span>

        // Create a new matrix to store the result.
        <span class="cov8" title="1">var zeroVal T
        result := New(m1.Rows(), m1.Columns(), zeroVal)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        var wg sync.WaitGroup
        errCh := make(chan error, 1)

        for i := 0; i &lt; m1.rows; i++ </span><span class="cov8" title="1">{
                i := i // Capture the loop variable for the goroutine
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for j := 0; j &lt; m1.columns; j++ </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span> // Context canceled; return without an error
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">diff := m1.elements[i][j] - m2.elements[i][j]
                                err := result.Set(i, j, diff)
                                if err != nil </span><span class="cov0" title="0">{
                                        cancel() // Cancel the context on error
                                        select </span>{
                                        case errCh &lt;- err:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                }()
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(errCh)
        }</span>()

        // Check for any errors
        <span class="cov8" title="1">if err := &lt;-errCh; err != nil </span><span class="cov0" title="0">{
                return Matrix[T]{}, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// bitwiseMax.go
// description: Gives max of two integers
// details:
// implementation of finding the maximum of two numbers using only binary operations without using conditions
// author(s) [red_byte](https://github.com/i-redbyte)
// see bitwiseMax_test.go

package max

// Bitwise computes using bitwise operator the maximum of all the integer input and returns it
func Bitwise(a int, b int, base int) int <span class="cov8" title="1">{
        z := a - b
        i := (z &gt;&gt; base) &amp; 1
        return a - (i * z)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package max

import "github.com/TheAlgorithms/Go/constraints"

// Int is a function which returns the maximum of all the integers provided as arguments.
func Int[T constraints.Integer](values ...T) T <span class="cov8" title="1">{
        max := values[0]
        for _, value := range values </span><span class="cov8" title="1">{
                if value &gt; max </span><span class="cov8" title="1">{
                        max = value
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package math

import (
        "github.com/TheAlgorithms/Go/constraints"
)

func Mean[T constraints.Number](values []T) float64 <span class="cov8" title="1">{

        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var summation float64 = 0

        for _, singleValue := range values </span><span class="cov8" title="1">{
                summation += float64(singleValue)
        }</span>

        <span class="cov8" title="1">return summation / float64(len(values))</span>

}
</pre>
		
		<pre class="file" id="file95" style="display: none">// author(s) [jo3zeph](https://github.com/jo3zeph)
// description: Find the median from a set of values
// see median_test.go

package math

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/sort"
)

func Median[T constraints.Number](values []T) float64 <span class="cov8" title="1">{

        sort.Bubble(values)

        l := len(values)

        switch </span>{
        case l == 0:<span class="cov8" title="1">
                return 0</span>

        case l%2 == 0:<span class="cov8" title="1">
                return float64((values[l/2-1] + values[l/2]) / 2)</span>

        default:<span class="cov8" title="1">
                return float64(values[l/2])</span>
        }
}
</pre>
		
		<pre class="file" id="file96" style="display: none">// bitwisemin.go
// description: Gives min of two integers
// details:
// implementation of finding the minimum of two numbers using only binary operations without using conditions
// author(s) [red_byte](https://github.com/i-redbyte)
// see bitwisemin_test.go

package min

// Bitwise This function returns the minimum integer using bit operations
func Bitwise(base int, value int, values ...int) int <span class="cov8" title="1">{
        min := value
        for _, val := range values </span><span class="cov8" title="1">{
                min = min&amp;((min-val)&gt;&gt;base) | val&amp;(^(min-val)&gt;&gt;base)
        }</span>
        <span class="cov8" title="1">return min</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package min

import "github.com/TheAlgorithms/Go/constraints"

// Int is a function which returns the minimum of all the integers provided as arguments.
func Int[T constraints.Integer](values ...T) T <span class="cov8" title="1">{
        min := values[0]
        for _, value := range values </span><span class="cov8" title="1">{
                if value &lt; min </span><span class="cov8" title="1">{
                        min = value
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// mobius.go
// description: Returns μ(n)
// details:
// For any positive integer n, define μ(n) as the sum of the primitive nth roots of unity.
// It has values in {−1, 0, 1} depending on the factorization of n into prime factors:
//   μ(n) = +1 if n is a square-free positive integer with an even number of prime factors.
//   μ(n) = −1 if n is a square-free positive integer with an odd number of prime factors.
//   μ(n) = 0 if n has a squared prime factor.
// wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see mobius_test.go

package math

import (
        "github.com/TheAlgorithms/Go/math/prime"
)

// Mu is the Mobius function
// This function returns μ(n) for given number
func Mu(n int) int <span class="cov8" title="1">{
        if n &lt;= 1 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">var primeFactorCount int
        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                if n%i == 0 &amp;&amp; prime.OptimizedTrialDivision(int64(i)) </span><span class="cov8" title="1">{
                        if n%(i*i) == 0 </span><span class="cov8" title="1">{
                                return 0
                        }</span>
                        <span class="cov8" title="1">primeFactorCount += 1</span>
                }
        }
        <span class="cov8" title="1">if primeFactorCount%2 == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// mode.go
// author(s): [CalvinNJK] (https://github.com/CalvinNJK)
// description: Finding Mode Value In an Array
// see mode.go

package math

import (
        "errors"

        "github.com/TheAlgorithms/Go/constraints"
)

// ErrEmptySlice is the error returned by functions in math package when
// an empty slice is provided to it as argument when the function expects
// a non-empty slice.
var ErrEmptySlice = errors.New("empty slice provided")

func Mode[T constraints.Number](numbers []T) (T, error) <span class="cov8" title="1">{

        countMap := make(map[T]int)

        n := len(numbers)

        if n == 0 </span><span class="cov8" title="1">{
                return 0, ErrEmptySlice
        }</span>

        <span class="cov8" title="1">for _, number := range numbers </span><span class="cov8" title="1">{
                countMap[number]++
        }</span>

        <span class="cov8" title="1">var mode T
        count := 0

        for k, v := range countMap </span><span class="cov8" title="1">{
                if v &gt; count </span><span class="cov8" title="1">{
                        count = v
                        mode = k
                }</span>
        }

        <span class="cov8" title="1">return mode, nil</span>

}
</pre>
		
		<pre class="file" id="file100" style="display: none">// exponentiation.go
// description: Implementation of Modular Exponentiation Algorithm
// details:
// A simple implementation of Modular Exponentiation - [Modular Exponenetation wiki](https://en.wikipedia.org/wiki/Modular_exponentiation)
// author(s) [Taj](https://github.com/tjgurwara99)
// see exponentiation_test.go

package modular

import (
        "errors"
        "math"
)

// ErrorIntOverflow For asserting that the values do not overflow in Int64
var ErrorIntOverflow = errors.New("integer overflow")

// ErrorNegativeExponent for asserting that the exponent we receive is positive
var ErrorNegativeExponent = errors.New("negative Exponent provided")

// Exponentiation returns base^exponent % mod
func Exponentiation(base, exponent, mod int64) (int64, error) <span class="cov8" title="1">{
        if mod == 1 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">if exponent &lt; 0 </span><span class="cov8" title="1">{
                return -1, ErrorNegativeExponent
        }</span>
        <span class="cov8" title="1">_, err := Multiply64BitInt(mod-1, mod-1)

        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov8" title="1">var result int64 = 1

        base = base % mod

        for exponent &gt; 0 </span><span class="cov8" title="1">{
                if exponent%2 == 1 </span><span class="cov8" title="1">{
                        result = (result * base) % mod
                }</span>
                <span class="cov8" title="1">exponent = exponent &gt;&gt; 1
                base = (base * base) % mod</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// Multiply64BitInt Checking if the integer multiplication overflows
func Multiply64BitInt(left, right int64) (int64, error) <span class="cov8" title="1">{
        if math.Abs(float64(left)) &gt; float64(math.MaxInt64)/math.Abs(float64(right)) </span><span class="cov0" title="0">{
                return 0, ErrorIntOverflow
        }</span>
        <span class="cov8" title="1">return left * right, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// inverse.go
// description: Implementation of Modular Inverse Algorithm
// details:
// A simple implementation of Modular Inverse - [Modular Inverse wiki](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)
// author(s) [Taj](https://github.com/tjgurwara99)
// see inverse_test.go

package modular

import (
        "errors"

        "github.com/TheAlgorithms/Go/math/gcd"
)

var ErrorInverse = errors.New("no Modular Inverse exists")

// Inverse Modular function
func Inverse(a, m int64) (int64, error) <span class="cov8" title="1">{
        gcd, x, _ := gcd.Extended(a, m)
        if gcd != 1 || m == 0 </span><span class="cov8" title="1">{
                return 0, ErrorInverse
        }</span>

        <span class="cov8" title="1">return ((m + (x % m)) % m), nil</span> // this is necessary because of Go's use of architecture specific instruction for the % operator.
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// The Moser-de Bruijn sequence is the sequence obtained by
// adding up the distinct powers of the number 4 (For example 1, 4, 16, 64, etc).
// You can get more details on https://en.wikipedia.org/wiki/Moser%E2%80%93de_Bruijn_sequence.

package moserdebruijnsequence

func MoserDeBruijnSequence(number int) []int <span class="cov8" title="1">{
        sequence := []int{}

        for i := 0; i &lt; number; i++ </span><span class="cov8" title="1">{
                res := generateNthTerm(i)
                sequence = append(sequence, res)
        }</span>

        <span class="cov8" title="1">return sequence</span>
}

func generateNthTerm(num int) int <span class="cov8" title="1">{
        if num == 0 || num == 1 </span><span class="cov8" title="1">{
                return num
        }</span>

        //number is even
        <span class="cov8" title="1">if num%2 == 0 </span><span class="cov8" title="1">{
                return 4 * generateNthTerm(num/2)
        }</span>

        //number is odd
        <span class="cov8" title="1">return 4*generateNthTerm(num/2) + 1</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// pascaltriangle.go
// description: Pascal's triangle
// details:
// Pascal's triangle is a triangular array of the binomial coefficients that arises in probability theory, combinatorics, and algebra. - [Pascal's triangle](https://en.wikipedia.org/wiki/Pascal%27s_triangle)
// example:
//1
//1 1
//1 2 1
//1 3 3 1
//1 4 6 4 1
//1 5 10 10 5 1
//1 6 15 20 15 6 1
//1 7 21 35 35 21 7 1
//1 8 28 56 70 56 28 8 1
//1 9 36 84 126 126 84 36 9 1
//1 10 45 120 210 252 210 120 45 10 1
//...
// author(s) [red_byte](https://github.com/i-redbyte)
// see pascaltriangle_test.go

package pascal

// GenerateTriangle This function generates a Pascal's triangle of n lines
func GenerateTriangle(n int) [][]int <span class="cov8" title="1">{
        var triangle = make([][]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                triangle[i] = make([]int, i+1)
                triangle[i][0], triangle[i][i] = 1, 1
                for j := 1; j &lt; i; j++ </span><span class="cov8" title="1">{
                        triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]
                }</span>
        }
        <span class="cov8" title="1">return triangle</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// perfectnumber.go
// description: provides the function IsPerfectNumber and related utilities
// details:
// provides the functions
// - IsPerfectNumber which checks if the input is a perfect number,
// - SumOfProperDivisors which returns the sum of proper divisors of the input.
// A number is called perfect, if it is a sum of its proper divisors,
// cf. https://en.wikipedia.org/wiki/Perfect_number,
// https://mathworld.wolfram.com/PerfectNumber.html
// https://oeis.org/A000396
// author(s) [Piotr Idzik](https://github.com/vil02)
// see perfectnumber_test.go

package math

// Returns the sum of proper divisors of inNumber.
func SumOfProperDivisors(inNumber uint) uint <span class="cov8" title="1">{
        var res = uint(0)
        if inNumber &gt; 1 </span><span class="cov8" title="1">{
                res = uint(1)
        }</span>
        <span class="cov8" title="1">for curDivisor := uint(2); curDivisor*curDivisor &lt;= inNumber; curDivisor++ </span><span class="cov8" title="1">{
                if inNumber%curDivisor == 0 </span><span class="cov8" title="1">{
                        res += curDivisor
                        if curDivisor*curDivisor != inNumber </span><span class="cov8" title="1">{
                                res += inNumber / curDivisor
                        }</span>
                }
        }
        <span class="cov8" title="1">return res</span>
}

// Checks if inNumber is a perfect number
func IsPerfectNumber(inNumber uint) bool <span class="cov8" title="1">{
        return inNumber &gt; 0 &amp;&amp; SumOfProperDivisors(inNumber) == inNumber
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package permutation

import (
        "strings"
)

// Heap's Algorithm for generating all permutations of n objects
func Heaps(out chan []string, n int) <span class="cov8" title="1">{
        elementSetCh := make(chan []string)
        go GenerateElementSet(elementSetCh, n)
        elementSet := &lt;-elementSetCh

        var recursiveGenerate func([]string, int, []string)
        var permutations []string
        recursiveGenerate = func(previousIteration []string, n int, elements []string) </span><span class="cov8" title="1">{
                if n == 1 </span><span class="cov8" title="1">{
                        permutations = append(permutations, strings.Join(elements, ""))
                }</span> else<span class="cov8" title="1"> {
                        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                                recursiveGenerate(previousIteration, n-1, elements)
                                if n%2 == 1 </span><span class="cov8" title="1">{
                                        tmp := elements[i]
                                        elements[i] = elements[n-1]
                                        elements[n-1] = tmp
                                }</span> else<span class="cov8" title="1"> {
                                        tmp := elements[0]
                                        elements[0] = elements[n-1]
                                        elements[n-1] = tmp
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">recursiveGenerate(permutations, n, elementSet)
        out &lt;- permutations</span>
}

func GenerateElementSet(out chan []string, n int) <span class="cov8" title="1">{
        elementSet := make([]string, n)
        for i := range elementSet </span><span class="cov8" title="1">{
                elementSet[i] = string(rune(i + 49)) // Adjust this if you want to change your charset
        }</span>
        <span class="cov8" title="1">out &lt;- elementSet</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// montecarlopi.go
// description: Calculating pi by the Monte Carlo method
// details:
// implementations of Monte Carlo Algorithm for the calculating of Pi - [Monte Carlo method](https://en.wikipedia.org/wiki/Monte_Carlo_method)
// author(s): [red_byte](https://github.com/i-redbyte), [Paul Leydier] (https://github.com/paul-leydier)
// see montecarlopi_test.go

package pi

import (
        "fmt"       // Used for error formatting
        "math/rand" // Used for random number generation in Monte Carlo method
        "runtime"   // Used to get information on available CPUs
        "time"      // Used for seeding the random number generation
)

func MonteCarloPi(randomPoints int) float64 <span class="cov8" title="1">{
        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
        inside := 0
        for i := 0; i &lt; randomPoints; i++ </span><span class="cov8" title="1">{
                x := rnd.Float64()
                y := rnd.Float64()
                if x*x+y*y &lt;= 1 </span><span class="cov8" title="1">{
                        inside += 1
                }</span>
        }
        <span class="cov8" title="1">pi := float64(inside) / float64(randomPoints) * 4
        return pi</span>
}

// MonteCarloPiConcurrent approximates the value of pi using the Monte Carlo method.
// Unlike the MonteCarloPi function (first version), this implementation uses
// goroutines and channels to parallelize the computation.
// More details on the Monte Carlo method available at https://en.wikipedia.org/wiki/Monte_Carlo_method.
// More details on goroutines parallelization available at https://go.dev/doc/effective_go#parallel.
func MonteCarloPiConcurrent(n int) (float64, error) <span class="cov8" title="1">{
        numCPU := runtime.GOMAXPROCS(0)
        c := make(chan int, numCPU)
        pointsToDraw, err := splitInt(n, numCPU) // split the task in sub-tasks of approximately equal sizes
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // launch numCPU parallel tasks
        <span class="cov8" title="1">for _, p := range pointsToDraw </span><span class="cov8" title="1">{
                go drawPoints(p, c)
        }</span>

        // collect the tasks results
        <span class="cov8" title="1">inside := 0
        for i := 0; i &lt; numCPU; i++ </span><span class="cov8" title="1">{
                inside += &lt;-c
        }</span>
        <span class="cov8" title="1">return float64(inside) / float64(n) * 4, nil</span>
}

// drawPoints draws n random two-dimensional points in the interval [0, 1), [0, 1) and sends through c
// the number of points which where within the circle of center 0 and radius 1 (unit circle)
func drawPoints(n int, c chan&lt;- int) <span class="cov8" title="1">{
        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
        inside := 0
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                x, y := rnd.Float64(), rnd.Float64()
                if x*x+y*y &lt;= 1 </span><span class="cov8" title="1">{
                        inside++
                }</span>
        }
        <span class="cov8" title="1">c &lt;- inside</span>
}

// splitInt takes an integer x and splits it within an integer slice of length n in the most uniform
// way possible.
// For example, splitInt(10, 3) will return []int{4, 3, 3}, nil
func splitInt(x int, n int) ([]int, error) <span class="cov8" title="1">{
        if x &lt; n </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("x must be &lt; n - given values are x=%d, n=%d", x, n)
        }</span>
        <span class="cov8" title="1">split := make([]int, n)
        if x%n == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        split[i] = x / n
                }</span>
        } else<span class="cov8" title="1"> {
                limit := x % n
                for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                        split[i] = x/n + 1
                }</span>
                <span class="cov8" title="1">for i := limit; i &lt; n; i++ </span><span class="cov8" title="1">{
                        split[i] = x / n
                }</span>
        }
        <span class="cov8" title="1">return split, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// spigotpi.go
// description: A Spigot Algorithm for the Digits of Pi
// details:
// implementation of Spigot Algorithm for the Digits of Pi - [Spigot algorithm](https://en.wikipedia.org/wiki/Spigot_algorithm)
// author(s) [red_byte](https://github.com/i-redbyte)
// see spigotpi_test.go

package pi

import "strconv"

func Spigot(n int) string <span class="cov8" title="1">{
        pi := ""
        boxes := n * 10 / 3
        remainders := make([]int, boxes)
        for i := 0; i &lt; boxes; i++ </span><span class="cov8" title="1">{
                remainders[i] = 2
        }</span>
        <span class="cov8" title="1">digitsHeld := 0
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                carriedOver := 0
                sum := 0
                for j := boxes - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                        remainders[j] *= 10
                        sum = remainders[j] + carriedOver
                        quotient := sum / (j*2 + 1)
                        remainders[j] = sum % (j*2 + 1)
                        carriedOver = quotient * j
                }</span>
                <span class="cov8" title="1">remainders[0] = sum % 10
                q := sum / 10
                switch q </span>{
                case 9:<span class="cov8" title="1">
                        digitsHeld++</span>
                case 10:<span class="cov8" title="1">
                        q = 0
                        for k := 1; k &lt;= digitsHeld; k++ </span><span class="cov8" title="1">{
                                replaced, _ := strconv.Atoi(pi[i-k : i-k+1])
                                if replaced == 9 </span><span class="cov8" title="1">{
                                        replaced = 0
                                }</span> else<span class="cov8" title="1"> {
                                        replaced++
                                }</span>
                                <span class="cov8" title="1">pi = delChar(pi, i-k)
                                pi = pi[:i-k] + strconv.Itoa(replaced) + pi[i-k:]</span>
                        }
                        <span class="cov8" title="1">digitsHeld = 1</span>
                default:<span class="cov8" title="1">
                        digitsHeld = 1</span>
                }
                <span class="cov8" title="1">pi += strconv.Itoa(q)</span>
        }
        <span class="cov8" title="1">return pi</span>
}

func delChar(s string, index int) string <span class="cov8" title="1">{
        tmp := []rune(s)
        return string(append(tmp[0:index], tmp[index+1:]...))
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">// pollard.go
// description: Pollard's rho algorithm
// details:
// implementation of Pollard's rho algorithm for integer factorization-[Pollard's rho algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm)
// author(s) [red_byte](https://github.com/i-redbyte)
// see pollard_test.go

package math

import (
        "errors"
        "math/big"
)

// DefaultPolynomial is the commonly used polynomial g(x) = (x^2 + 1) mod n
func DefaultPolynomial(n *big.Int) func(*big.Int) *big.Int <span class="cov8" title="1">{
        bigOne := big.NewInt(1)
        bigTwo := big.NewInt(2)
        return func(x *big.Int) *big.Int </span><span class="cov8" title="1">{
                xSquared := new(big.Int).Exp(x, bigTwo, n) // see: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#Core_ideas
                xSquared.Add(xSquared, bigOne)
                xSquared.Mod(xSquared, n)
                return xSquared
        }</span>
}

// PollardsRhoFactorization is an implementation of Pollard's rho factorization algorithm
// using the default parameters x = y = 2
func PollardsRhoFactorization(n *big.Int, f func(n *big.Int) func(x *big.Int) *big.Int) (*big.Int, error) <span class="cov8" title="1">{
        x, y, d := big.NewInt(2), big.NewInt(2), big.NewInt(1)
        bigOne := big.NewInt(1)
        g := f(n)
        for d.Cmp(bigOne) == 0 </span><span class="cov8" title="1">{
                x = g(x)
                y = g(g(y))
                sub := new(big.Int).Sub(x, y)
                d.GCD(nil, nil, sub.Abs(sub), n)
        }</span>
        <span class="cov8" title="1">if d.Cmp(n) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("factorization failed")
        }</span>
        <span class="cov8" title="1">return d, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package power

// IterativePower is iterative O(logn) function for pow(x, y)
func IterativePower(n uint, power uint) uint <span class="cov8" title="1">{
        var res uint = 1
        for power &gt; 0 </span><span class="cov8" title="1">{
                if (power &amp; 1) != 0 </span><span class="cov8" title="1">{
                        res = res * n
                }</span>

                <span class="cov8" title="1">power = power &gt;&gt; 1
                n *= n</span>
        }
        <span class="cov8" title="1">return res</span>
}

// RecursivePower is recursive O(logn) function for pow(x, y)
func RecursivePower(n uint, power uint) uint <span class="cov8" title="1">{
        if power == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">var temp = RecursivePower(n, power/2)
        if power%2 == 0 </span><span class="cov8" title="1">{
                return temp * temp
        }</span>
        <span class="cov8" title="1">return n * temp * temp</span>
}

// RecursivePower1 is recursive O(n) function for pow(x, y)
func RecursivePower1(n uint, power uint) uint <span class="cov8" title="1">{
        if power == 0 </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> if power%2 == 0 </span><span class="cov8" title="1">{
                return RecursivePower1(n, power/2) * RecursivePower1(n, power/2)
        }</span> else<span class="cov8" title="1"> {
                return n * RecursivePower1(n, power/2) * RecursivePower1(n, power/2)
        }</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// powvialogarithm.go
// description: Powers in terms of logarithms
// details:
// implementation of exponentiation using exponent and logarithm, without using loops  - [Powers via logarithms wiki](https://en.wikipedia.org/wiki/Exponentiation#Powers_via_logarithms)
// author(s) [red_byte](https://github.com/i-redbyte)
// see powvialogarithm_test.go

package power

import (
        "math"
)

func UsingLog(a float64, b float64) float64 <span class="cov8" title="1">{
        var p float64
        p = 1
        if a &lt; 0 &amp;&amp; int(b)&amp;1 != 0 </span><span class="cov8" title="1">{
                p = -1
        }</span>
        <span class="cov8" title="1">log := math.Log(math.Abs(a))
        exp := math.Exp(b * log)
        result := exp * p
        return math.Round(result)</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// This file implements two versions of the Miller-Rabin primality test.
// One of the implementations is deterministic and the other is probabilistic.
// The Miller-Rabin test is one of the simplest and fastest known primality
// tests and is widely used.
//
// Authors:
// [Taj](https://github.com/tjgurwara99)
// [Rak](https://github.com/raklaptudirm)

package prime

import (
        "math/rand"

        "github.com/TheAlgorithms/Go/math/modular"
)

// formatNum accepts a number and returns the
// odd number d such that num = 2^s * d + 1
func formatNum(num int64) (d int64, s int64) <span class="cov8" title="1">{
        d = num - 1
        for num%2 == 0 </span><span class="cov0" title="0">{
                d /= 2
                s++
        }</span>
        <span class="cov8" title="1">return</span>
}

// isTrivial checks if num's primality is easy to determine.
// If it is, it returns true and num's primality. Otherwise
// it returns false and false.
func isTrivial(num int64) (prime bool, trivial bool) <span class="cov8" title="1">{
        if num &lt;= 4 </span><span class="cov8" title="1">{
                // 2 and 3 are primes
                prime = num == 2 || num == 3
                trivial = true
        }</span> else<span class="cov8" title="1"> {
                prime = false
                // number is trivial prime if
                // it is divisible by 2
                trivial = num%2 == 0
        }</span>

        <span class="cov8" title="1">return</span>
}

// MillerTest tests whether num is a strong probable prime to a witness.
// Formally: a^d ≡ 1 (mod n) or a^(2^r * d) ≡ -1 (mod n), 0 &lt;= r &lt;= s
func MillerTest(num, witness int64) (bool, error) <span class="cov8" title="1">{
        d, _ := formatNum(num)
        res, err := modular.Exponentiation(witness, d, num)

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // miller conditions checks
        <span class="cov8" title="1">if res == 1 || res == num-1 </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">for d != num-1 </span><span class="cov0" title="0">{
                res = (res * res) % num
                d *= 2
                if res == 1 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">if res == num-1 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// MillerRandomTest This is the intermediate step that repeats within the
// miller rabin primality test for better probabilitic chances of
// receiving the correct result with random witnesses.
func MillerRandomTest(num int64) (bool, error) <span class="cov8" title="1">{
        random := rand.Int63n(num-2) + 2
        return MillerTest(num, random)
}</span>

// MillerTestMultiple is like MillerTest but runs the test for multiple
// witnesses.
func MillerTestMultiple(num int64, witnesses ...int64) (bool, error) <span class="cov0" title="0">{
        for _, witness := range witnesses </span><span class="cov0" title="0">{
                prime, err := MillerTest(num, witness)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if !prime </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// MillerRabinProbabilistic is a probabilistic test for primality
// of an integer based of the algorithm devised by Miller and Rabin.
func MillerRabinProbabilistic(num, rounds int64) (bool, error) <span class="cov8" title="1">{
        if prime, trivial := isTrivial(num); trivial </span><span class="cov8" title="1">{
                // num is a trivial number
                return prime, nil
        }</span>

        <span class="cov8" title="1">for i := int64(0); i &lt; rounds; i++ </span><span class="cov8" title="1">{
                val, err := MillerRandomTest(num)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if !val </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// MillerRabinDeterministic is a Deterministic version of the Miller-Rabin
// test, which returns correct results for all valid int64 numbers.
func MillerRabinDeterministic(num int64) (bool, error) <span class="cov8" title="1">{
        if prime, trivial := isTrivial(num); trivial </span><span class="cov8" title="1">{
                // num is a trivial number
                return prime, nil
        }</span>

        <span class="cov8" title="1">switch </span>{
        case num &lt; 2047:<span class="cov8" title="1">
                // witness 2 can determine the primality of any number less than 2047
                return MillerTest(num, 2)</span>
        case num &lt; 1_373_653:<span class="cov0" title="0">
                // witnesses 2 and 3 can determine the primality
                // of any number less than 1,373,653
                return MillerTestMultiple(num, 2, 3)</span>
        case num &lt; 9_080_191:<span class="cov0" title="0">
                // witnesses 31 and 73 can determine the primality
                // of any number less than 9,080,191
                return MillerTestMultiple(num, 31, 73)</span>
        case num &lt; 25_326_001:<span class="cov0" title="0">
                // witnesses 2, 3, and 5 can determine the
                // primality of any number less than 25,326,001
                return MillerTestMultiple(num, 2, 3, 5)</span>
        case num &lt; 1_122_004_669_633:<span class="cov0" title="0">
                // witnesses 2, 13, 23, and 1,662,803 can determine the
                // primality of any number less than 1,122,004,669,633
                return MillerTestMultiple(num, 2, 13, 23, 1_662_803)</span>
        case num &lt; 2_152_302_898_747:<span class="cov0" title="0">
                // witnesses 2, 3, 5, 7, and 11 can determine the primality
                // of any number less than 2,152,302,898,747
                return MillerTestMultiple(num, 2, 3, 5, 7, 11)</span>
        case num &lt; 341_550_071_728_321:<span class="cov0" title="0">
                // witnesses 2, 3, 5, 7, 11, 13, and 17 can determine the
                // primality of any number less than 341,550,071,728,321
                return MillerTestMultiple(num, 2, 3, 5, 7, 11, 13, 17)</span>
        default:<span class="cov0" title="0">
                // witnesses 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37 can determine
                // the primality of any number less than 318,665,857,834,031,151,167,461
                // which is well above the max int64 9,223,372,036,854,775,807
                return MillerTestMultiple(num, 2, 3, 5, 7, 11, 13, 17, 19, 23, 31, 37)</span>
        }
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package prime

// A primality test is an algorithm for determining whether an input number is prime. Among other
// fields of mathematics, it is used for cryptography. Unlike integer factorization, primality
// tests do not generally give prime factors, only stating whether the input number is prime or not.
// Source - Wikipedia https://en.wikipedia.org/wiki/Primality_test

// TrialDivision tests whether a number is prime by trying to divide it by the numbers less than it.
func TrialDivision(n int64) bool <span class="cov8" title="1">{
        if n &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := int64(2); i &lt; n; i++ </span><span class="cov8" title="1">{

                if n%i == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// OptimizedTrialDivision checks primality of an integer using an optimized trial division method.
// The optimizations include not checking divisibility by the even numbers and only checking up to
// the square root of the given number.
func OptimizedTrialDivision(n int64) bool <span class="cov8" title="1">{
        // 0 and 1 are not prime
        if n &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        // 2 and 3 are prime
        <span class="cov8" title="1">if n &lt; 4 </span><span class="cov8" title="1">{
                return true
        }</span>

        // all numbers divisible by 2 except 2 are not prime
        <span class="cov8" title="1">if n%2 == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := int64(3); i*i &lt;= n; i += 2 </span><span class="cov8" title="1">{
                if n%i == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package prime

// Factorize is a function that computes the exponents
// of each prime in the prime factorization of n
func Factorize(n int64) map[int64]int64 <span class="cov8" title="1">{
        result := make(map[int64]int64)

        for i := int64(2); i*i &lt;= n; i += 1 </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        if n%i != 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">result[i] += 1
                        n /= i</span>
                }

        }
        <span class="cov8" title="1">if n &gt; 1 </span><span class="cov8" title="1">{
                result[n] += 1
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// sieve.go
// description: Algorithms for generating prime numbers efficiently
// author(s) [Taj](https://github.com/tjgurwara99)
// see sieve_test.go

package prime

// Generate generates the sequence of integers starting at 2 and sends it to the channel `ch`
func GenerateChannel(ch chan&lt;- int) <span class="cov8" title="1">{
        for i := 2; ; i++ </span><span class="cov8" title="1">{
                ch &lt;- i
        }</span>
}

// Sieve Sieving the numbers that are not prime from the channel - basically removing them from the channels
func Sieve(in &lt;-chan int, out chan&lt;- int, prime int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                i := &lt;-in
                if i%prime != 0 </span><span class="cov8" title="1">{
                        out &lt;- i
                }</span>
        }
}

// Generate returns a int slice of prime numbers up to the limit
func Generate(limit int) []int <span class="cov8" title="1">{
        var primes []int

        ch := make(chan int)
        go GenerateChannel(ch)

        for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                primes = append(primes, &lt;-ch)
                ch1 := make(chan int)
                go Sieve(ch, ch1, primes[i])
                ch = ch1
        }</span>

        <span class="cov8" title="1">return primes</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// twin.go
// description: Returns Twin Prime of n
// details:
// For any integer n, twin prime is (n + 2)
// if and only if both n and (n + 2) both are prime
// wikipedia: https://en.wikipedia.org/wiki/Twin_prime
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see twin_test.go

package prime

// This function returns twin prime for given number
// returns (n + 2) if both n and (n + 2) are prime
// -1 otherwise
func Twin(n int) (int, bool) <span class="cov8" title="1">{
        if OptimizedTrialDivision(int64(n)) &amp;&amp; OptimizedTrialDivision(int64(n+2)) </span><span class="cov8" title="1">{
                return n + 2, true
        }</span>
        <span class="cov8" title="1">return -1, false</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// pronicnumber.go
// description: Returns true if the number is pronic and false otherwise
// details:
//  Pronic number: For any integer n, if there exists integer m
//  such that n = m * (m + 1) then n is called a pronic number.
// wikipedia: https://en.wikipedia.org/wiki/Pronic_number
// author: Akshay Dubey (https://github.com/itsAkshayDubey)
// see pronicnumber_test.go

package math

import stdMath "math"

// PronicNumber returns true if argument passed to the function is pronic and false otherwise.
func PronicNumber(n int) bool <span class="cov8" title="1">{
        if n &lt; 0 || n%2 == 1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">x := int(stdMath.Sqrt(float64(n)))
        return n == x*(x+1)</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package pythagoras

import (
        "math"
)

// Vector defines a tuple with 3 values in 3d-space
type Vector struct {
        x float64
        y float64
        z float64
}

// Distance calculates the distance between to vectors with the   Pythagoras theorem
func Distance(a, b Vector) float64 <span class="cov8" title="1">{
        res := math.Pow(b.x-a.x, 2.0) + math.Pow(b.y-a.y, 2.0) + math.Pow(b.z-a.z, 2.0)
        return math.Sqrt(res)
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">// author(s) [red_byte](https://github.com/i-redbyte)
// see sin_test.go

package math

import "math"

// Sin returns the sine of the radian argument x. [See more](https://en.wikipedia.org/wiki/Sine_and_cosine)
func Sin(x float64) float64 <span class="cov8" title="1">{
        return Cos((math.Pi / 2) - x)
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">/* O(n) solution, for calculating
maximum contiguous sum in the given array. */

// Package maxsubarraysum is a package containing a solution to a common
// problem of finding max contiguous sum within a array of ints.
package maxsubarraysum

import (
        "github.com/TheAlgorithms/Go/math/max"
)

// MaxSubarraySum returns the maximum subarray sum
func MaxSubarraySum(array []int) int <span class="cov8" title="1">{
        var currentMax int
        var maxTillNow int
        if len(array) != 0 </span><span class="cov8" title="1">{
                currentMax = array[0]
                maxTillNow = array[0]
        }</span>
        <span class="cov8" title="1">for _, v := range array </span><span class="cov8" title="1">{
                currentMax = max.Int(v, currentMax+v)
                maxTillNow = max.Int(maxTillNow, currentMax)
        }</span>
        <span class="cov8" title="1">return maxTillNow</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Package nested provides functions for testing
// strings proper brackets nesting.
package nested

// IsBalanced returns true if provided input string is properly nested.
//
// Input is a sequence of brackets: '(', ')', '[', ']', '{', '}'.
//
// A sequence of brackets `s` is considered properly nested
// if any of the following conditions are true:
//   - `s` is empty;
//   - `s` has the form (U) or [U] or {U} where U is a properly nested string;
//   - `s` has the form VW where V and W are properly nested strings.
//
// For example, the string "()()[()]" is properly nested but "[(()]" is not.
//
// **Note** Providing characters other then brackets would return false,
// despite brackets sequence in the string. Make sure to filter
// input before usage.
func IsBalanced(input string) bool <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(input)%2 != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Brackets such as '{', '[', '(' are valid UTF-8 characters,
        // which means that only one byte is required to code them,
        // so can be stored as bytes.
        <span class="cov8" title="1">var stack []byte

        for i := 0; i &lt; len(input); i++ </span><span class="cov8" title="1">{
                if input[i] == '(' || input[i] == '{' || input[i] == '[' </span><span class="cov8" title="1">{
                        stack = append(stack, input[i])
                }</span> else<span class="cov8" title="1"> {
                        if len(stack) &gt; 0 </span><span class="cov8" title="1">{
                                pair := string(stack[len(stack)-1]) + string(input[i])
                                stack = stack[:len(stack)-1]

                                if pair != "[]" &amp;&amp; pair != "{}" &amp;&amp; pair != "()" </span><span class="cov8" title="1">{
                                        // This means that two types of brackets has
                                        // been mixed together, for example "([)]",
                                        // which makes seuqence invalid by definition.
                                        return false
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // This means that closing bracket is encountered
                                // before opening one, which makes all sequence
                                // invalid by definition.
                                return false
                        }</span>
                }
        }

        // If sequence is properly nested, all elements in stack
        // has been paired with closing elements. If even one
        // element has not been paired with a closing bracket,
        // means that sequence is invalid by definition.
        <span class="cov8" title="1">return len(stack) == 0</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package search

// Binary search for target within a sorted array by repeatedly dividing the array in half and comparing the midpoint with the target.
// This function uses recursive call to itself.
// If a target is found, the index of the target is returned. Else the function return -1 and ErrNotFound.
func Binary(array []int, target int, lowIndex int, highIndex int) (int, error) <span class="cov8" title="1">{
        if highIndex &lt; lowIndex || len(array) == 0 </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>
        <span class="cov8" title="1">mid := int(lowIndex + (highIndex-lowIndex)/2)
        if array[mid] &gt; target </span><span class="cov8" title="1">{
                return Binary(array, target, lowIndex, mid-1)
        }</span> else<span class="cov8" title="1"> if array[mid] &lt; target </span><span class="cov8" title="1">{
                return Binary(array, target, mid+1, highIndex)
        }</span> else<span class="cov8" title="1"> {
                return mid, nil
        }</span>
}

// BinaryIterative search for target within a sorted array by repeatedly dividing the array in half and comparing the midpoint with the target.
// Unlike Binary, this function uses iterative method and not recursive.
// If a target is found, the index of the target is returned. Else the function return -1 and ErrNotFound.
func BinaryIterative(array []int, target int) (int, error) <span class="cov8" title="1">{
        startIndex := 0
        endIndex := len(array) - 1
        var mid int
        for startIndex &lt;= endIndex </span><span class="cov8" title="1">{
                mid = int(startIndex + (endIndex-startIndex)/2)
                if array[mid] &gt; target </span><span class="cov8" title="1">{
                        endIndex = mid - 1
                }</span> else<span class="cov8" title="1"> if array[mid] &lt; target </span><span class="cov8" title="1">{
                        startIndex = mid + 1
                }</span> else<span class="cov8" title="1"> {
                        return mid, nil
                }</span>
        }
        <span class="cov8" title="1">return -1, ErrNotFound</span>
}

// LowerBound returns index to the first element in the range [0, len(array)-1] that is not less than (i.e. greater or equal to) target.
// return -1 and ErrNotFound if no such element is found.
func LowerBound(array []int, target int) (int, error) <span class="cov8" title="1">{
        startIndex := 0
        endIndex := len(array) - 1
        var mid int
        for startIndex &lt;= endIndex </span><span class="cov8" title="1">{
                mid = int(startIndex + (endIndex-startIndex)/2)
                if array[mid] &lt; target </span><span class="cov8" title="1">{
                        startIndex = mid + 1
                }</span> else<span class="cov8" title="1"> {
                        endIndex = mid - 1
                }</span>
        }

        //when target greater than every element in array, startIndex will out of bounds
        <span class="cov8" title="1">if startIndex &gt;= len(array) </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>
        <span class="cov8" title="1">return startIndex, nil</span>
}

// UpperBound returns index to the first element in the range [lowIndex, len(array)-1] that is greater than target.
// return -1 and ErrNotFound if no such element is found.
func UpperBound(array []int, target int) (int, error) <span class="cov8" title="1">{
        startIndex := 0
        endIndex := len(array) - 1
        var mid int
        for startIndex &lt;= endIndex </span><span class="cov8" title="1">{
                mid = int(startIndex + (endIndex-startIndex)/2)
                if array[mid] &gt; target </span><span class="cov8" title="1">{
                        endIndex = mid - 1
                }</span> else<span class="cov8" title="1"> {
                        startIndex = mid + 1
                }</span>
        }

        //when target greater or equal than every element in array, startIndex will out of bounds
        <span class="cov8" title="1">if startIndex &gt;= len(array) </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>
        <span class="cov8" title="1">return startIndex, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package search

// Interpolation searches for the entity in the given sortedData.
// if the entity is present, it will return the index of the entity, if not -1 will be returned.
// see: https://en.wikipedia.org/wiki/Interpolation_search
// Complexity
//
//        Worst: O(N)
//        Average: O(log(log(N))  if the elements are uniformly distributed
//        Best: O(1)
//
// Example
//
//        fmt.Println(InterpolationSearch([]int{1, 2, 9, 20, 31, 45, 63, 70, 100},100))
func Interpolation(sortedData []int, guess int) (int, error) <span class="cov8" title="1">{
        if len(sortedData) == 0 </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>

        <span class="cov8" title="1">var (
                low, high       = 0, len(sortedData) - 1
                lowVal, highVal = sortedData[low], sortedData[high]
        )

        for lowVal != highVal &amp;&amp; (lowVal &lt;= guess) &amp;&amp; (guess &lt;= highVal) </span><span class="cov8" title="1">{
                mid := low + int(float64(float64((guess-lowVal)*(high-low))/float64(highVal-lowVal)))

                // if guess is found, array can also have duplicate values, so scan backwards and find the first index
                if sortedData[mid] == guess </span><span class="cov8" title="1">{
                        for mid &gt; 0 &amp;&amp; sortedData[mid-1] == guess </span><span class="cov0" title="0">{
                                mid--
                        }</span>
                        <span class="cov8" title="1">return mid, nil</span>

                }

                // adjust our guess and continue
                <span class="cov0" title="0">if sortedData[mid] &gt; guess </span><span class="cov0" title="0">{
                        high, highVal = mid-1, sortedData[high]

                }</span> else<span class="cov0" title="0"> {
                        low, lowVal = mid+1, sortedData[low]
                }</span>

        }

        <span class="cov8" title="1">if guess == lowVal </span><span class="cov0" title="0">{
                return low, nil
        }</span>
        <span class="cov8" title="1">return -1, ErrNotFound</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// jump.go
// description: Implementation of jump search
// details:
// A search algorithm for ordered list that jump through the list to narrow down the range
// before performing a linear search
// reference: https://en.wikipedia.org/wiki/Jump_search
// see jump_test.go for a test implementation, test function TestJump

package search

import "math"

// Jump search works by jumping multiple steps ahead in sorted list until it find an item larger than target,
// then create a sublist of item from the last searched item up to the current item and perform a linear search.
func Jump(array []int, target int) (int, error) <span class="cov8" title="1">{
        n := len(array)
        if n == 0 </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>

        // the optimal value of step is square root of the length of list
        <span class="cov8" title="1">step := int(math.Round(math.Sqrt(float64(n))))

        prev := 0    // previous index
        curr := step // current index
        for array[curr-1] &lt; target </span><span class="cov8" title="1">{
                prev = curr
                if prev &gt;= len(array) </span><span class="cov8" title="1">{
                        return -1, ErrNotFound
                }</span>

                <span class="cov8" title="1">curr += step

                // prevent jumping over list range
                if curr &gt; n </span><span class="cov8" title="1">{
                        curr = n
                }</span>
        }

        // perform linear search from index prev to index curr
        <span class="cov8" title="1">for array[prev] &lt; target </span><span class="cov8" title="1">{
                prev++

                // if reach end of range, indicate target not found
                if prev == curr </span><span class="cov0" title="0">{
                        return -1, ErrNotFound
                }</span>
        }
        <span class="cov8" title="1">if array[prev] == target </span><span class="cov8" title="1">{
                return prev, nil
        }</span>

        <span class="cov8" title="1">return -1, ErrNotFound</span>

}
</pre>
		
		<pre class="file" id="file124" style="display: none">package search

import "math"

func Jump2(arr []int, target int) (int, error) <span class="cov8" title="1">{
        step := int(math.Round(math.Sqrt(float64(len(arr)))))
        rbound := len(arr)
        for i := step; i &lt; len(arr); i += step </span><span class="cov8" title="1">{
                if arr[i] &gt; target </span><span class="cov8" title="1">{
                        rbound = i
                        break</span>
                }
        }

        <span class="cov8" title="1">for i := rbound - step; i &lt; rbound; i++ </span><span class="cov8" title="1">{
                if arr[i] == target </span><span class="cov8" title="1">{
                        return i, nil
                }</span>
                <span class="cov8" title="1">if arr[i] &gt; target </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return -1, ErrNotFound</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package search

// Linear Simple linear search algorithm that iterates over all elements of an array in the worst case scenario
func Linear(array []int, query int) (int, error) <span class="cov8" title="1">{
        for i, item := range array </span><span class="cov8" title="1">{
                if item == query </span><span class="cov8" title="1">{
                        return i, nil
                }</span>
        }
        <span class="cov8" title="1">return -1, ErrNotFound</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package search

func SelectK(array []int, k int) (int, error) <span class="cov8" title="1">{
        if k &gt; len(array) </span><span class="cov8" title="1">{
                return -1, ErrNotFound
        }</span>
        <span class="cov8" title="1">return selectK(array, 0, len(array), len(array)-k), nil</span>
}

// search the element which index is idx
func selectK(array []int, l, r, idx int) int <span class="cov8" title="1">{
        index := partition(array, l, r)
        if index == idx </span><span class="cov8" title="1">{
                return array[index]
        }</span>
        <span class="cov8" title="1">if index &lt; idx </span><span class="cov8" title="1">{
                return selectK(array, index+1, r, idx)
        }</span>
        <span class="cov8" title="1">return selectK(array, l, index, idx)</span>
}

func partition(array []int, l, r int) int <span class="cov8" title="1">{
        elem, j := array[l], l+1
        for i := l + 1; i &lt; r; i++ </span><span class="cov8" title="1">{
                if array[i] &lt;= elem </span><span class="cov8" title="1">{
                        array[i], array[j] = array[j], array[i]
                        j++
                }</span>
        }
        <span class="cov8" title="1">array[l], array[j-1] = array[j-1], array[l]
        return j - 1</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package search

import (
        "fmt"
        "math"
)

// TernaryMax is a function to search for maximum value of a uni-modal function `f`
// in the interval [a, b]. a and b should be finit numbers
func TernaryMax(a, b, epsilon float64, f func(x float64) float64) (float64, error) <span class="cov8" title="1">{
        if a == math.Inf(-1) || b == math.Inf(1) </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("interval boundaries should be finite numbers")
        }</span>
        <span class="cov8" title="1">if math.Abs(a-b) &lt;= epsilon </span><span class="cov8" title="1">{
                return f((a + b) / 2), nil
        }</span>
        <span class="cov8" title="1">left := (2*a + b) / 3
        right := (a + 2*b) / 3
        if f(left) &lt; f(right) </span><span class="cov8" title="1">{
                return TernaryMax(left, b, epsilon, f)
        }</span>
        <span class="cov8" title="1">return TernaryMax(a, right, epsilon, f)</span>
}

// TernaryMin is a function to search for minimum value of a uni-modal function `f`
// in the interval [a, b]. a and b should be finit numbers.
func TernaryMin(a, b, epsilon float64, f func(x float64) float64) (float64, error) <span class="cov8" title="1">{
        if a == math.Inf(-1) || b == math.Inf(1) </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("interval boundaries should be finite numbers")
        }</span>
        <span class="cov8" title="1">if math.Abs(a-b) &lt;= epsilon </span><span class="cov8" title="1">{
                return f((a + b) / 2), nil
        }</span>
        <span class="cov8" title="1">left := (2*a + b) / 3
        right := (a + 2*b) / 3
        if f(left) &gt; f(right) </span><span class="cov8" title="1">{
                return TernaryMin(left, b, epsilon, f)
        }</span>
        <span class="cov8" title="1">return TernaryMin(a, right, epsilon, f)</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package search

type searchTest struct {
        data          []int
        key           int
        expected      int
        expectedError error
        name          string
}

// Note that these are immutable therefore they are shared among all the search tests.
// If your algorithm is mutating these then it is advisable to create separate test cases.
var searchTests = []searchTest{
        //Sanity
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10, 9, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 9, 8, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 8, 7, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 7, 6, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 6, 5, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5, 4, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 4, 3, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3, 2, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 2, 1, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1, 0, nil, "Sanity"},
        //Absent
        {[]int{1, 4, 5, 6, 7, 10}, -25, -1, ErrNotFound, "Absent"},
        {[]int{1, 4, 5, 6, 7, 10}, 25, -1, ErrNotFound, "Absent"},
        //Empty slice
        {[]int{}, 2, -1, ErrNotFound, "Empty"},
}

var lowerBoundTests = []searchTest{
        //Sanity
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, -25, 0, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1, 0, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5, 4, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10, 9, nil, "Sanity"},
        {[]int{1, 2, 2, 2, 2, 6, 7, 8, 9, 10}, 2, 1, nil, "Sanity"},
        {[]int{2, 2, 2, 2, 2, 2, 2, 2, 2, 2}, 2, 0, nil, "Sanity"},
        //Absent
        {[]int{1, 4, 5, 6, 7, 10}, 25, -1, ErrNotFound, "Absent"},
        //Empty slice
        {[]int{}, 2, -1, ErrNotFound, "Empty"},
}

var upperBoundTests = []searchTest{
        //Sanity
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, -25, 0, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1, 1, nil, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5, 5, nil, "Sanity"},
        {[]int{1, 2, 2, 2, 2, 6, 7, 8, 9, 10}, 2, 5, nil, "Sanity"},
        //Absent
        {[]int{2, 2, 2, 2, 2, 2, 2, 2, 2, 2}, 2, -1, ErrNotFound, "Sanity"},
        {[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10, -1, ErrNotFound, "Sanity"},
        {[]int{1, 4, 5, 6, 7, 10}, 25, -1, ErrNotFound, "Absent"},
        //Empty slice
        {[]int{}, 2, -1, ErrNotFound, "Empty"},
}

// This function generate consistent testcase for benchmark test.
func generateBenchmarkTestCase() []int <span class="cov0" title="0">{
        var testCase []int
        for i := 0; i &lt; 1000; i++ </span><span class="cov0" title="0">{
                testCase = append(testCase, i)
        }</span>
        <span class="cov0" title="0">return testCase</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">// Binary Insertion Sort
// description: Implementation of binary insertion sort in Go
// details: Binary Insertion Sort is a variation of
// Insertion sort in which proper location to
// insert the selected element is found using the
// Binary search algorithm.
// ref: https://www.geeksforgeeks.org/binary-insertion-sort

package sort

import "github.com/TheAlgorithms/Go/constraints"

func BinaryInsertion[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for currentIndex := 1; currentIndex &lt; len(arr); currentIndex++ </span><span class="cov8" title="1">{
                temporary := arr[currentIndex]
                low := 0
                high := currentIndex - 1

                for low &lt;= high </span><span class="cov8" title="1">{
                        mid := low + (high-low)/2
                        if arr[mid] &gt; temporary </span><span class="cov8" title="1">{
                                high = mid - 1
                        }</span> else<span class="cov8" title="1"> {
                                low = mid + 1
                        }</span>
                }

                <span class="cov8" title="1">for itr := currentIndex; itr &gt; low; itr-- </span><span class="cov8" title="1">{
                        arr[itr] = arr[itr-1]
                }</span>

                <span class="cov8" title="1">arr[low] = temporary</span>
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// This is a pure Go implementation of the bogosort algorithm,
// also known as permutation sort, stupid sort, slowsort, shotgun sort, or monkey sort.
// Bogosort generates random permutations until it guesses the correct one.

// More info on: https://en.wikipedia.org/wiki/Bogosort

package sort

import (
        "math/rand"

        "github.com/TheAlgorithms/Go/constraints"
)

func isSorted[T constraints.Number](arr []T) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(arr)-1; i++ </span><span class="cov0" title="0">{
                if arr[i] &gt; arr[i+1] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func shuffle[T constraints.Number](arr []T) <span class="cov0" title="0">{
        for i := range arr </span><span class="cov0" title="0">{
                j := rand.Intn(i + 1)
                arr[i], arr[j] = arr[j], arr[i]
        }</span>
}

func Bogo[T constraints.Number](arr []T) []T <span class="cov0" title="0">{
        for !isSorted(arr) </span><span class="cov0" title="0">{
                shuffle(arr)
        }</span>

        <span class="cov0" title="0">return arr</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Implementation of basic bubble sort algorithm
// Reference: https://en.wikipedia.org/wiki/Bubble_sort

package sort

import "github.com/TheAlgorithms/Go/constraints"

// Bubble is a simple generic definition of Bubble sort algorithm.
func Bubble[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        swapped := true
        for swapped </span><span class="cov8" title="1">{
                swapped = false
                for i := 0; i &lt; len(arr)-1; i++ </span><span class="cov8" title="1">{
                        if arr[i+1] &lt; arr[i] </span><span class="cov8" title="1">{
                                arr[i+1], arr[i] = arr[i], arr[i+1]
                                swapped = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

// Bucket sorts a slice. It is mainly useful
// when input is uniformly distributed over a range.
func Bucket[T constraints.Number](arr []T) []T <span class="cov8" title="1">{
        // early return if the array too small
        if len(arr) &lt;= 1 </span><span class="cov8" title="1">{
                return arr
        }</span>

        // find the maximum and minimum elements in arr
        <span class="cov8" title="1">max := arr[0]
        min := arr[0]
        for _, v := range arr </span><span class="cov8" title="1">{
                if v &gt; max </span><span class="cov8" title="1">{
                        max = v
                }</span>
                <span class="cov8" title="1">if v &lt; min </span><span class="cov8" title="1">{
                        min = v
                }</span>
        }

        // create an empty bucket for each element in arr
        <span class="cov8" title="1">bucket := make([][]T, len(arr))

        // put each element in the appropriate bucket
        for _, v := range arr </span><span class="cov8" title="1">{
                bucketIndex := int((v - min) / (max - min) * T(len(arr)-1))
                bucket[bucketIndex] = append(bucket[bucketIndex], v)
        }</span>

        // use insertion sort to sort each bucket
        <span class="cov8" title="1">for i := range bucket </span><span class="cov8" title="1">{
                bucket[i] = Insertion(bucket[i])
        }</span>

        // concatenate the sorted buckets
        <span class="cov8" title="1">sorted := make([]T, 0, len(arr))
        for _, v := range bucket </span><span class="cov8" title="1">{
                sorted = append(sorted, v...)
        }</span>

        <span class="cov8" title="1">return sorted</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Implementation of Cocktail sorting
// reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort

package sort

import "github.com/TheAlgorithms/Go/constraints"

// Cocktail sort is a variation of bubble sort, operating in two directions (beginning to end, end to beginning)
func Cocktail[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov8" title="1">{ // ignore 0 length arrays
                return arr
        }</span>

        <span class="cov8" title="1">swapped := true // true if swapped two or more elements in the last loop
        // if it loops through the array without swapping, the array is sorted

        // start and end indexes, this will be updated excluding already sorted elements
        start := 0
        end := len(arr) - 1

        for swapped </span><span class="cov8" title="1">{
                swapped = false
                var new_start int
                var new_end int

                for i := start; i &lt; end; i++ </span><span class="cov8" title="1">{ // first loop, from start to end
                        if arr[i] &gt; arr[i+1] </span><span class="cov8" title="1">{ // if current and next elements are unordered
                                arr[i], arr[i+1] = arr[i+1], arr[i] // swap two elements
                                new_end = i
                                swapped = true
                        }</span>
                }

                <span class="cov8" title="1">end = new_end

                if !swapped </span><span class="cov8" title="1">{ // early exit, skipping the second loop
                        break</span>
                }

                <span class="cov8" title="1">swapped = false

                for i := end; i &gt; start; i-- </span><span class="cov8" title="1">{ // second loop, from end to start
                        if arr[i] &lt; arr[i-1] </span><span class="cov8" title="1">{ // same process of the first loop, now going 'backwards'
                                arr[i], arr[i-1] = arr[i-1], arr[i]
                                new_start = i
                                swapped = true
                        }</span>
                }

                <span class="cov8" title="1">start = new_start</span>
        }

        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">// Implementation of comb sort algorithm, an improvement of bubble sort
// Reference: https://www.geeksforgeeks.org/comb-sort/

package sort

import "github.com/TheAlgorithms/Go/constraints"

func getNextGap(gap int) int <span class="cov8" title="1">{
        gap = (gap * 10) / 13
        if gap &lt; 1 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return gap</span>
}

// Comb is a simple sorting algorithm which is an improvement of the bubble sorting algorithm.
func Comb[T constraints.Ordered](data []T) []T <span class="cov8" title="1">{
        n := len(data)
        gap := n
        swapped := true

        for gap != 1 || swapped </span><span class="cov8" title="1">{
                gap = getNextGap(gap)
                swapped = false
                for i := 0; i &lt; n-gap; i++ </span><span class="cov8" title="1">{
                        if data[i] &gt; data[i+gap] </span><span class="cov8" title="1">{
                                data[i], data[i+gap] = data[i+gap], data[i]
                                swapped = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return data</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">// countingsort.go
// description: Implementation of counting sort algorithm
// details: A simple counting sort algorithm implementation
// author [Phil](https://github.com/pschik)
// see sort_test.go for a test implementation, test function TestQuickSort

package sort

import "github.com/TheAlgorithms/Go/constraints"

func Count[T constraints.Integer](data []T) []T <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return data
        }</span>
        <span class="cov8" title="1">var aMin, aMax = data[0], data[0]
        for _, x := range data </span><span class="cov8" title="1">{
                if x &lt; aMin </span><span class="cov8" title="1">{
                        aMin = x
                }</span>
                <span class="cov8" title="1">if x &gt; aMax </span><span class="cov8" title="1">{
                        aMax = x
                }</span>
        }
        <span class="cov8" title="1">count := make([]int, aMax-aMin+1)
        for _, x := range data </span><span class="cov8" title="1">{
                count[x-aMin]++ // this is the reason for having only Integer constraint instead of Ordered.
        }</span>
        <span class="cov8" title="1">z := 0
        for i, c := range count </span><span class="cov8" title="1">{
                for c &gt; 0 </span><span class="cov8" title="1">{
                        data[z] = T(i) + aMin
                        z++
                        c--
                }</span>
        }
        <span class="cov8" title="1">return data</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package sort

import (
        "github.com/TheAlgorithms/Go/constraints"
)

// Cycle sort is an in-place, unstable sorting algorithm that is particularly useful
// when sorting arrays containing elements with a small range of values. It is theoretically
// optimal in terms of the total number of writes to the original array.
func Cycle[T constraints.Number](arr []T) []T <span class="cov8" title="1">{
        counter, cycle, len := 0, 0, len(arr)
        // Early return if the array too small
        if len &lt;= 1 </span><span class="cov8" title="1">{
                return arr
        }</span>

        <span class="cov8" title="1">for cycle = 0; cycle &lt; len-1; cycle++ </span><span class="cov8" title="1">{
                elem := arr[cycle]
                // Find total smaller elements to right
                pos := cycle
                for counter = cycle + 1; counter &lt; len; counter++ </span><span class="cov8" title="1">{
                        if arr[counter] &lt; elem </span><span class="cov8" title="1">{
                                pos++
                        }</span>
                }
                // In case this element is already in correct position, let's skip processing
                <span class="cov8" title="1">if pos == cycle </span><span class="cov8" title="1">{
                        continue</span>
                }
                // In case we have same elements, we want to skip to the end of that list as well, ignoring order
                // This makes the algorithm unstable for composite elements
                <span class="cov8" title="1">for elem == arr[pos] </span><span class="cov0" title="0">{
                        pos++
                }</span>
                // Now let us put the item to it's right position
                <span class="cov8" title="1">arr[pos], elem = elem, arr[pos]

                //We need to rotate the array till we have reached the start of the cycle again
                for pos != cycle </span><span class="cov8" title="1">{
                        pos = cycle
                        // Find smaller elements to right again
                        for counter = cycle + 1; counter &lt; len; counter++ </span><span class="cov8" title="1">{
                                if arr[counter] &lt; elem </span><span class="cov8" title="1">{
                                        pos++
                                }</span>
                        }
                        <span class="cov8" title="1">for elem == arr[pos] </span><span class="cov8" title="1">{
                                pos++
                        }</span>
                        //We can do this unconditionally, but the check helps prevent redundant writes to the array
                        <span class="cov8" title="1">if elem != arr[pos] </span><span class="cov8" title="1">{
                                arr[pos], elem = elem, arr[pos]
                        }</span>
                }
        }

        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Implementation of exchange sort algorithm, a variant of bubble sort
// Reference: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort

package sort

import "github.com/TheAlgorithms/Go/constraints"

func Exchange[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for i := 0; i &lt; len(arr)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(arr); j++ </span><span class="cov8" title="1">{
                        if arr[i] &gt; arr[j] </span><span class="cov8" title="1">{
                                arr[i], arr[j] = arr[j], arr[i]
                        }</span>
                }
        }

        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

type MaxHeap struct {
        slice    []Comparable
        heapSize int
        indices  map[int]int
}

func (h *MaxHeap) Init(slice []Comparable) <span class="cov0" title="0">{
        if slice == nil </span><span class="cov0" title="0">{
                slice = make([]Comparable, 0)
        }</span>

        <span class="cov0" title="0">h.slice = slice
        h.heapSize = len(slice)
        h.indices = make(map[int]int)
        h.Heapify()</span>
}

func (h MaxHeap) Heapify() <span class="cov0" title="0">{
        for i, v := range h.slice </span><span class="cov0" title="0">{
                h.indices[v.Idx()] = i
        }</span>
        <span class="cov0" title="0">for i := h.heapSize / 2; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                h.heapifyDown(i)
        }</span>
}

func (h *MaxHeap) Pop() Comparable <span class="cov0" title="0">{
        if h.heapSize == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">i := h.slice[0]
        h.heapSize--

        h.slice[0] = h.slice[h.heapSize]
        h.updateidx(0)
        h.heapifyDown(0)

        h.slice = h.slice[0:h.heapSize]
        return i</span>
}

func (h *MaxHeap) Push(i Comparable) <span class="cov0" title="0">{
        h.slice = append(h.slice, i)
        h.updateidx(h.heapSize)
        h.heapifyUp(h.heapSize)
        h.heapSize++
}</span>

func (h MaxHeap) Size() int <span class="cov0" title="0">{
        return h.heapSize
}</span>

func (h MaxHeap) Update(i Comparable) <span class="cov0" title="0">{
        h.slice[h.indices[i.Idx()]] = i
        h.heapifyUp(h.indices[i.Idx()])
        h.heapifyDown(h.indices[i.Idx()])
}</span>

func (h MaxHeap) updateidx(i int) <span class="cov0" title="0">{
        h.indices[h.slice[i].Idx()] = i
}</span>

func (h *MaxHeap) swap(i, j int) <span class="cov0" title="0">{
        h.slice[i], h.slice[j] = h.slice[j], h.slice[i]
        h.updateidx(i)
        h.updateidx(j)
}</span>

func (h MaxHeap) more(i, j int) bool <span class="cov0" title="0">{
        return h.slice[i].More(h.slice[j])
}</span>

func (h MaxHeap) heapifyUp(i int) <span class="cov0" title="0">{
        if i == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">p := i / 2

        if h.slice[i].More(h.slice[p]) </span><span class="cov0" title="0">{
                h.swap(i, p)
                h.heapifyUp(p)
        }</span>
}

func (h MaxHeap) heapifyDown(i int) <span class="cov0" title="0">{
        heapifyDown(h.slice, h.heapSize, i, h.more, h.swap)
}</span>

func heapifyDown[T any](slice []T, N, i int, moreFunc func(i, j int) bool, swapFunc func(i, j int)) <span class="cov8" title="1">{
        l, r := 2*i+1, 2*i+2
        max := i

        if l &lt; N &amp;&amp; moreFunc(l, max) </span><span class="cov8" title="1">{
                max = l
        }</span>
        <span class="cov8" title="1">if r &lt; N &amp;&amp; moreFunc(r, max) </span><span class="cov8" title="1">{
                max = r
        }</span>
        <span class="cov8" title="1">if max != i </span><span class="cov8" title="1">{
                swapFunc(i, max)

                heapifyDown(slice, N, max, moreFunc, swapFunc)
        }</span>
}

type Comparable interface {
        Idx() int
        More(any) bool
}

func HeapSort[T constraints.Ordered](slice []T) []T <span class="cov8" title="1">{
        N := len(slice)

        moreFunc := func(i, j int) bool </span><span class="cov8" title="1">{
                return slice[i] &gt; slice[j]
        }</span>
        <span class="cov8" title="1">swapFunc := func(i, j int) </span><span class="cov8" title="1">{
                slice[i], slice[j] = slice[j], slice[i]
        }</span>

        // build a maxheap
        <span class="cov8" title="1">for i := N/2 - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                heapifyDown(slice, N, i, moreFunc, swapFunc)
        }</span>

        <span class="cov8" title="1">for i := N - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                slice[i], slice[0] = slice[0], slice[i]
                heapifyDown(slice, i, 0, moreFunc, swapFunc)
        }</span>

        <span class="cov8" title="1">return slice</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

func Insertion[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for currentIndex := 1; currentIndex &lt; len(arr); currentIndex++ </span><span class="cov8" title="1">{
                temporary := arr[currentIndex]
                iterator := currentIndex
                for ; iterator &gt; 0 &amp;&amp; arr[iterator-1] &gt; temporary; iterator-- </span><span class="cov8" title="1">{
                        arr[iterator] = arr[iterator-1]
                }</span>
                <span class="cov8" title="1">arr[iterator] = temporary</span>
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package sort

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/math/min"
        "sync"
)

func merge[T constraints.Ordered](a []T, b []T) []T <span class="cov8" title="1">{

        var r = make([]T, len(a)+len(b))
        var i = 0
        var j = 0

        for i &lt; len(a) &amp;&amp; j &lt; len(b) </span><span class="cov8" title="1">{

                if a[i] &lt;= b[j] </span><span class="cov8" title="1">{
                        r[i+j] = a[i]
                        i++
                }</span> else<span class="cov8" title="1"> {
                        r[i+j] = b[j]
                        j++
                }</span>

        }

        <span class="cov8" title="1">for i &lt; len(a) </span><span class="cov8" title="1">{
                r[i+j] = a[i]
                i++
        }</span>
        <span class="cov8" title="1">for j &lt; len(b) </span><span class="cov8" title="1">{
                r[i+j] = b[j]
                j++
        }</span>

        <span class="cov8" title="1">return r</span>

}

// Merge Perform merge sort on a slice
func Merge[T constraints.Ordered](items []T) []T <span class="cov8" title="1">{

        if len(items) &lt; 2 </span><span class="cov8" title="1">{
                return items

        }</span>

        <span class="cov8" title="1">var middle = len(items) / 2
        var a = Merge(items[:middle])
        var b = Merge(items[middle:])
        return merge(a, b)</span>

}

func MergeIter[T constraints.Ordered](items []T) []T <span class="cov8" title="1">{
        for step := 1; step &lt; len(items); step += step </span><span class="cov8" title="1">{
                for i := 0; i+step &lt; len(items); i += 2 * step </span><span class="cov8" title="1">{
                        tmp := merge(items[i:i+step], items[i+step:min.Int(i+2*step, len(items))])
                        copy(items[i:], tmp)
                }</span>
        }
        <span class="cov8" title="1">return items</span>
}

// ParallelMerge Perform merge sort on a slice using goroutines
func ParallelMerge[T constraints.Ordered](items []T) []T <span class="cov8" title="1">{
        if len(items) &lt; 2 </span><span class="cov8" title="1">{
                return items
        }</span>

        <span class="cov8" title="1">if len(items) &lt; 2048 </span><span class="cov8" title="1">{
                return Merge(items)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        wg.Add(1)

        var middle = len(items) / 2
        var a []T
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                a = ParallelMerge(items[:middle])
        }</span>()
        <span class="cov8" title="1">var b = ParallelMerge(items[middle:])

        wg.Wait()
        return merge(a, b)</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

// Pancake sorts a slice using flip operations,
// where flip refers to the idea of reversing the
// slice from index `0` to `i`.
func Pancake[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        // early return if the array too small
        if len(arr) &lt;= 1 </span><span class="cov8" title="1">{
                return arr
        }</span>

        // start from the end of the array
        <span class="cov8" title="1">for i := len(arr) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                // find the index of the maximum element in arr
                max := 0
                for j := 1; j &lt;= i; j++ </span><span class="cov8" title="1">{
                        if arr[j] &gt; arr[max] </span><span class="cov8" title="1">{
                                max = j
                        }</span>
                }

                // if the maximum element is not at the end of the array
                <span class="cov8" title="1">if max != i </span><span class="cov8" title="1">{
                        // flip the maximum element to the beginning of the array
                        arr = flip(arr, max)

                        // flip the maximum element to the end of the array by flipping the whole array
                        arr = flip(arr, i)
                }</span>
        }

        <span class="cov8" title="1">return arr</span>
}

// flip reverses the input slice from `0` to `i`.
func flip[T constraints.Ordered](arr []T, i int) []T <span class="cov8" title="1">{
        for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                arr[j], arr[i] = arr[i], arr[j]
                i--
        }</span>
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Patience sorting is a sorting algorithm inspired by the card game patience.
//
// For more details check out those links below here:
// GeeksForGeeks article : https://www.geeksforgeeks.org/patience-sorting/
// Wikipedia article: https://en.wikipedia.org/wiki/Patience_sorting
// authors [guuzaa](https://github.com/guuzaa)
// see patiencesort.go

package sort

import "github.com/TheAlgorithms/Go/constraints"

func Patience[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        if len(arr) &lt;= 1 </span><span class="cov8" title="1">{
                return arr
        }</span>

        <span class="cov8" title="1">var piles [][]T

        for _, card := range arr </span><span class="cov8" title="1">{
                left, right := 0, len(piles)
                for left &lt; right </span><span class="cov8" title="1">{
                        mid := left + (right-left)/2
                        if piles[mid][len(piles[mid])-1] &gt;= card </span><span class="cov8" title="1">{
                                right = mid
                        }</span> else<span class="cov8" title="1"> {
                                left = mid + 1
                        }</span>
                }

                <span class="cov8" title="1">if left == len(piles) </span><span class="cov8" title="1">{
                        piles = append(piles, []T{card})
                }</span> else<span class="cov8" title="1"> {
                        piles[left] = append(piles[left], card)
                }</span>
        }

        <span class="cov8" title="1">return mergePiles(piles)</span>
}

func mergePiles[T constraints.Ordered](piles [][]T) []T <span class="cov8" title="1">{
        var ret []T

        for len(piles) &gt; 0 </span><span class="cov8" title="1">{
                minID := 0
                minValue := piles[minID][len(piles[minID])-1]

                for i := 1; i &lt; len(piles); i++ </span><span class="cov8" title="1">{
                        if minValue &lt;= piles[i][len(piles[i])-1] </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">minValue = piles[i][len(piles[i])-1]
                        minID = i</span>
                }

                <span class="cov8" title="1">ret = append(ret, minValue)

                piles[minID] = piles[minID][:len(piles[minID])-1]

                if len(piles[minID]) == 0 </span><span class="cov8" title="1">{
                        piles = append(piles[:minID], piles[minID+1:]...)
                }</span>
        }

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">// Pigeonhole algorithm's working at wikipedia.
// https://en.wikipedia.org/wiki/Pigeonhole_sort

package sort

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/math/max"
        "github.com/TheAlgorithms/Go/math/min"
)

// Pigeonhole sorts a slice using pigeonhole sorting algorithm.
// NOTE: To maintain time complexity O(n + N), this is the reason for having
// only Integer constraint instead of Ordered.
func Pigeonhole[T constraints.Integer](arr []T) []T <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov8" title="1">{
                return arr
        }</span>

        <span class="cov8" title="1">max := max.Int(arr...)
        min := min.Int(arr...)

        size := max - min + 1

        holes := make([]T, size)

        for _, element := range arr </span><span class="cov8" title="1">{
                holes[element-min]++
        }</span>

        <span class="cov8" title="1">i := 0

        for j := T(0); j &lt; size; j++ </span><span class="cov8" title="1">{
                for holes[j] &gt; 0 </span><span class="cov8" title="1">{
                        holes[j]--
                        arr[i] = j + min
                        i++
                }</span>
        }

        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">// quicksort.go
// description: Implementation of in-place quicksort algorithm
// details:
// A simple in-place quicksort algorithm implementation. [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)
// author(s) [Taj](https://github.com/tjgurwara99)
// see sort_test.go for a test implementation, test function TestQuickSort.

package sort

import "github.com/TheAlgorithms/Go/constraints"

func Partition[T constraints.Ordered](arr []T, low, high int) int <span class="cov8" title="1">{
        index := low - 1
        pivotElement := arr[high]
        for i := low; i &lt; high; i++ </span><span class="cov8" title="1">{
                if arr[i] &lt;= pivotElement </span><span class="cov8" title="1">{
                        index += 1
                        arr[index], arr[i] = arr[i], arr[index]
                }</span>
        }
        <span class="cov8" title="1">arr[index+1], arr[high] = arr[high], arr[index+1]
        return index + 1</span>
}

// QuicksortRange Sorts the specified range within the array
func QuicksortRange[T constraints.Ordered](arr []T, low, high int) <span class="cov8" title="1">{
        if len(arr) &lt;= 1 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if low &lt; high </span><span class="cov8" title="1">{
                pivot := Partition(arr, low, high)
                QuicksortRange(arr, low, pivot-1)
                QuicksortRange(arr, pivot+1, high)
        }</span>
}

// Quicksort Sorts the entire array
func Quicksort[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        QuicksortRange(arr, 0, len(arr)-1)
        return arr
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">// radixsort.go
// description: Implementation of in-place radixsort algorithm
// details:
// A simple in-place quicksort algorithm implementation. [Wikipedia](https://en.wikipedia.org/wiki/Radix_sort)

package sort

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/math/max"
)

func countSort[T constraints.Integer](arr []T, exp T) []T <span class="cov8" title="1">{
        var digits [10]int
        var output = make([]T, len(arr))

        for _, item := range arr </span><span class="cov8" title="1">{
                digits[(item/exp)%10]++
        }</span>
        <span class="cov8" title="1">for i := 1; i &lt; 10; i++ </span><span class="cov8" title="1">{
                digits[i] += digits[i-1]
        }</span>

        <span class="cov8" title="1">for i := len(arr) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                output[digits[(arr[i]/exp)%10]-1] = arr[i]
                digits[(arr[i]/exp)%10]--
        }</span>

        <span class="cov8" title="1">return output</span>
}

func unsignedRadixSort[T constraints.Integer](arr []T) []T <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov8" title="1">{
                return arr
        }</span>
        <span class="cov8" title="1">maxElement := max.Int(arr...)
        for exp := T(1); maxElement/exp &gt; 0; exp *= 10 </span><span class="cov8" title="1">{
                arr = countSort(arr, exp)
        }</span>
        <span class="cov8" title="1">return arr</span>
}

func RadixSort[T constraints.Integer](arr []T) []T <span class="cov8" title="1">{
        if len(arr) &lt; 1 </span><span class="cov8" title="1">{
                return arr
        }</span>
        <span class="cov8" title="1">var negatives, nonNegatives []T

        for _, item := range arr </span><span class="cov8" title="1">{
                if item &lt; 0 </span><span class="cov8" title="1">{
                        negatives = append(negatives, -item)
                }</span> else<span class="cov8" title="1"> {
                        nonNegatives = append(nonNegatives, item)
                }</span>
        }
        <span class="cov8" title="1">negatives = unsignedRadixSort(negatives)

        // Reverse the negative array and restore signs
        for i, j := 0, len(negatives)-1; i &lt;= j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                negatives[i], negatives[j] = -negatives[j], -negatives[i]
        }</span>
        <span class="cov8" title="1">return append(negatives, unsignedRadixSort(nonNegatives)...)</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

func Selection[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for i := 0; i &lt; len(arr); i++ </span><span class="cov8" title="1">{
                min := i
                for j := i + 1; j &lt; len(arr); j++ </span><span class="cov8" title="1">{
                        if arr[j] &lt; arr[min] </span><span class="cov8" title="1">{
                                min = j
                        }</span>
                }

                <span class="cov8" title="1">arr[i], arr[min] = arr[min], arr[i]</span>
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package sort

import "github.com/TheAlgorithms/Go/constraints"

func Shell[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for d := int(len(arr) / 2); d &gt; 0; d /= 2 </span><span class="cov8" title="1">{
                for i := d; i &lt; len(arr); i++ </span><span class="cov8" title="1">{
                        for j := i; j &gt;= d &amp;&amp; arr[j-d] &gt; arr[j]; j -= d </span><span class="cov8" title="1">{
                                arr[j], arr[j-d] = arr[j-d], arr[j]
                        }</span>
                }
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">// simplesort.go
// description: Implementation of a simple sorting algorithm
// details:
// A simple sorting algorithm that look counter intuitive at first glance and very similar to Exchange Sort
// An improved version is included with slight changes to make the sort slightly more efficient
// reference: https://arxiv.org/abs/2110.01111v1
// see sort_test.go for a test implementation, test function TestSimple and TestImprovedSimple

package sort

import "github.com/TheAlgorithms/Go/constraints"

func Simple[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for i := 0; i &lt; len(arr); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; len(arr); j++ </span><span class="cov8" title="1">{
                        if arr[i] &lt; arr[j] </span><span class="cov8" title="1">{
                                // swap arr[i] and arr[j]
                                arr[i], arr[j] = arr[j], arr[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return arr</span>
}

// ImprovedSimple is a improve SimpleSort by skipping an unnecessary comparison of the first and last.
// This improved version is more similar to implementation of insertion sort
func ImprovedSimple[T constraints.Ordered](arr []T) []T <span class="cov8" title="1">{
        for i := 1; i &lt; len(arr); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; len(arr)-1; j++ </span><span class="cov8" title="1">{
                        if arr[i] &lt; arr[j] </span><span class="cov8" title="1">{
                                // swap arr[i] and arr[j]
                                arr[i], arr[j] = arr[j], arr[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return arr</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">// Implementation of Timsort algorithm
// Reference: https://en.wikipedia.org/wiki/Timsort

package sort

import (
        "github.com/TheAlgorithms/Go/constraints"
)

const runSizeThreshold = 8

// Timsort is a simple generic implementation of Timsort algorithm.
func Timsort[T constraints.Ordered](data []T) []T <span class="cov8" title="1">{
        runSize := calculateRunSize(len(data))
        insertionSortRuns(data, runSize)
        mergeRuns(data, runSize)
        return data
}</span>

// calculateRunSize returns a run size parameter that is further used
// to slice the data slice.
func calculateRunSize(dataLength int) int <span class="cov8" title="1">{
        remainder := 0
        for dataLength &gt;= runSizeThreshold </span><span class="cov8" title="1">{
                if dataLength%2 == 1 </span><span class="cov8" title="1">{
                        remainder = 1
                }</span>

                <span class="cov8" title="1">dataLength = dataLength / 2</span>
        }

        <span class="cov8" title="1">return dataLength + remainder</span>
}

// insertionSortRuns runs insertion sort on all the data runs one by one.
func insertionSortRuns[T constraints.Ordered](data []T, runSize int) <span class="cov8" title="1">{
        for lower := 0; lower &lt; len(data); lower += runSize </span><span class="cov8" title="1">{
                upper := lower + runSize
                if upper &gt;= len(data) </span><span class="cov8" title="1">{
                        upper = len(data)
                }</span>

                <span class="cov8" title="1">Insertion(data[lower:upper])</span>
        }
}

// mergeRuns merge sorts all the data runs into a single sorted data slice.
func mergeRuns[T constraints.Ordered](data []T, runSize int) <span class="cov8" title="1">{
        for size := runSize; size &lt; len(data); size *= 2 </span><span class="cov8" title="1">{
                for lowerBound := 0; lowerBound &lt; len(data); lowerBound += size * 2 </span><span class="cov8" title="1">{
                        middleBound := lowerBound + size - 1
                        upperBound := lowerBound + 2*size - 1
                        if len(data)-1 &lt; upperBound </span><span class="cov8" title="1">{
                                upperBound = len(data) - 1
                        }</span>

                        <span class="cov8" title="1">mergeRun(data, lowerBound, middleBound, upperBound)</span>
                }
        }
}

// mergeRun uses merge sort to sort adjacent data runs.
func mergeRun[T constraints.Ordered](data []T, lower, mid, upper int) <span class="cov8" title="1">{
        left := data[lower : mid+1]
        right := data[mid+1 : upper+1]
        merged := merge(left, right)
        // rewrite original data slice values with sorted values from merged slice
        for i, value := range merged </span><span class="cov8" title="1">{
                data[lower+i] = value
        }</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Package sqrt contains algorithms and data structures that contains a √n in their complexity
package sqrt

import "math"

// Sqrt (or Square Root) Decomposition is a technique used for query an array and perform updates
// Inside this package is described its most simple data structure, you can find more at: https://cp-algorithms.com/data_structures/sqrt_decomposition.html
//
// Formally, You can use SqrtDecomposition only if:
//
// Given a function $Query:E_1,...,E_n\rightarrow Q$
//
// if $\exist unionQ:Q,Q\rightarrow Q$
//
// s.t.
//
// - $\forall n\in \N &gt; 1, 1\le i&lt;n, E_1,..., E_n\in E \\ query(E_1,..., E_n)=unionQ(query(E_1,..., E_i), query(E_{i+1},...,E_n))$
//
// - (Only if you want use $update$ function)
// $\forall n\in \N &gt; 0, E_1,..., E_n\in E \\ query(E_1,...,E_{new},..., E_n)=updateQ(query(E_1,...,E_{old},...,E_n), indexof(E_{old}), E_{new})$
type SqrtDecomposition[E any, Q any] struct {
        querySingleElement func(element E) Q
        unionQ             func(q1 Q, q2 Q) Q
        updateQ            func(oldQ Q, oldE E, newE E) (newQ Q)

        elements  []E
        blocks    []Q
        blockSize uint64
}

// Create a new SqrtDecomposition instance with the parameters as specified by SqrtDecomposition comment
// Assumptions:
//   - len(elements) &gt; 0
func NewSqrtDecomposition[E any, Q any](
        elements []E,
        querySingleElement func(element E) Q,
        unionQ func(q1 Q, q2 Q) Q,
        updateQ func(oldQ Q, oldE E, newE E) (newQ Q),
) *SqrtDecomposition[E, Q] <span class="cov8" title="1">{
        sqrtDec := &amp;SqrtDecomposition[E, Q]{
                querySingleElement: querySingleElement,
                unionQ:             unionQ,
                updateQ:            updateQ,
                elements:           elements,
        }
        sqrt := math.Sqrt(float64(len(sqrtDec.elements)))
        blockSize := uint64(sqrt)
        numBlocks := uint64(math.Ceil(float64(len(elements)) / float64(blockSize)))
        sqrtDec.blocks = make([]Q, numBlocks)
        for i := uint64(0); i &lt; uint64(len(elements)); i++ </span><span class="cov8" title="1">{
                if i%blockSize == 0 </span><span class="cov8" title="1">{
                        sqrtDec.blocks[i/blockSize] = sqrtDec.querySingleElement(elements[i])
                }</span> else<span class="cov8" title="1"> {
                        sqrtDec.blocks[i/blockSize] = sqrtDec.unionQ(sqrtDec.blocks[i/blockSize], sqrtDec.querySingleElement(elements[i]))
                }</span>
        }
        <span class="cov8" title="1">sqrtDec.blockSize = blockSize
        return sqrtDec</span>
}

// Performs a query from index start to index end (non included)
// Assumptions:
//   - start &lt; end
//   - start and end are valid
func (s *SqrtDecomposition[E, Q]) Query(start uint64, end uint64) Q <span class="cov8" title="1">{
        firstIndexNextBlock := ((start / s.blockSize) + 1) * s.blockSize
        q := s.querySingleElement(s.elements[start])
        if firstIndexNextBlock &gt; end </span><span class="cov8" title="1">{ // if in same block
                start++
                for start &lt; end </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[start]))
                        start++
                }</span>
        } else<span class="cov8" title="1"> {
                // left side
                start++
                for start &lt; firstIndexNextBlock </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[start]))
                        start++
                }</span>

                //middle part
                <span class="cov8" title="1">endBlock := end / s.blockSize
                for i := firstIndexNextBlock / s.blockSize; i &lt; endBlock; i++ </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.blocks[i])
                }</span>

                // right part
                <span class="cov8" title="1">for i := endBlock * s.blockSize; i &lt; end; i++ </span><span class="cov8" title="1">{
                        q = s.unionQ(q, s.querySingleElement(s.elements[i]))
                }</span>
        }
        <span class="cov8" title="1">return q</span>
}

// Assumptions:
//   - index is valid
func (s *SqrtDecomposition[E, Q]) Update(index uint64, newElement E) <span class="cov8" title="1">{
        i := index / s.blockSize
        s.blocks[i] = s.updateQ(s.blocks[i], s.elements[index], newElement)
        s.elements[index] = newElement
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">package ahocorasick

import (
        "fmt"
        "time"
)

// Advanced Function performing the Advanced Aho-Corasick algorithm.
// Finds and prints occurrences of each pattern.
func Advanced(t string, p []string) Result <span class="cov0" title="0">{
        startTime := time.Now()
        occurrences := make(map[int][]int)
        ac, f := BuildExtendedAc(p)
        current := 0
        for pos := 0; pos &lt; len(t); pos++ </span><span class="cov0" title="0">{
                if GetTransition(current, t[pos], ac) != -1 </span><span class="cov0" title="0">{
                        current = GetTransition(current, t[pos], ac)
                }</span> else<span class="cov0" title="0"> {
                        current = 0
                }</span>
                <span class="cov0" title="0">_, ok := f[current]
                if ok </span><span class="cov0" title="0">{
                        for i := range f[current] </span><span class="cov0" title="0">{
                                if p[f[current][i]] == GetWord(pos-len(p[f[current][i]])+1, pos, t) </span><span class="cov0" title="0">{ //check for word match
                                        newOccurrences := IntArrayCapUp(occurrences[f[current][i]])
                                        occurrences[f[current][i]] = newOccurrences
                                        occurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">elapsed := time.Since(startTime)
        fmt.Printf("\n\nElapsed %f secs\n", elapsed.Seconds())

        var resultOccurrences = make(map[string][]int)
        for key, value := range occurrences </span><span class="cov0" title="0">{
                resultOccurrences[p[key]] = value
        }</span>

        <span class="cov0" title="0">return Result{
                resultOccurrences,
        }</span>
}

// BuildExtendedAc Functions that builds extended Aho Corasick automaton.
func BuildExtendedAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int) <span class="cov0" title="0">{
        acTrie, stateIsTerminal, f := ConstructTrie(p)
        s := make([]int, len(stateIsTerminal)) //supply function
        i := 0                                 //root of acTrie
        acToReturn = acTrie
        s[i] = -1
        for current := 1; current &lt; len(stateIsTerminal); current++ </span><span class="cov0" title="0">{
                o, parent := GetParent(current, acTrie)
                down := s[parent]
                for StateExists(down, acToReturn) &amp;&amp; GetTransition(down, o, acToReturn) == -1 </span><span class="cov0" title="0">{
                        down = s[down]
                }</span>
                <span class="cov0" title="0">if StateExists(down, acToReturn) </span><span class="cov0" title="0">{
                        s[current] = GetTransition(down, o, acToReturn)
                        if stateIsTerminal[s[current]] </span><span class="cov0" title="0">{
                                stateIsTerminal[current] = true
                                f[current] = ArrayUnion(f[current], f[s[current]]) //F(Current) &lt;- F(Current) union F(S(Current))
                        }</span>
                } else<span class="cov0" title="0"> {
                        s[current] = i //initial state?
                }</span>
        }
        <span class="cov0" title="0">a := ComputeAlphabet(p) // concat of all patterns in p
        for j := range a </span><span class="cov0" title="0">{
                if GetTransition(i, a[j], acToReturn) == -1 </span><span class="cov0" title="0">{
                        CreateTransition(i, a[j], i, acToReturn)
                }</span>
        }
        <span class="cov0" title="0">for current := 1; current &lt; len(stateIsTerminal); current++ </span><span class="cov0" title="0">{
                for j := range a </span><span class="cov0" title="0">{
                        if GetTransition(current, a[j], acToReturn) == -1 </span><span class="cov0" title="0">{
                                CreateTransition(current, a[j], GetTransition(s[current], a[j], acToReturn), acToReturn)
                        }</span>
                }
        }
        <span class="cov0" title="0">return acToReturn, f</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package ahocorasick

import (
        "fmt"
        "time"
)

// Result structure to hold occurrences
type Result struct {
        occurrences map[string][]int
}

// AhoCorasick Function performing the Basic Aho-Corasick algorithm.
// Finds and prints occurrences of each pattern.
func AhoCorasick(t string, p []string) Result <span class="cov8" title="1">{
        startTime := time.Now()
        occurrences := make(map[int][]int)
        ac, f, s := BuildAc(p)
        current := 0
        for pos := 0; pos &lt; len(t); pos++ </span><span class="cov8" title="1">{
                for GetTransition(current, t[pos], ac) == -1 &amp;&amp; s[current] != -1 </span><span class="cov8" title="1">{
                        current = s[current]
                }</span>
                <span class="cov8" title="1">if GetTransition(current, t[pos], ac) != -1 </span><span class="cov8" title="1">{
                        current = GetTransition(current, t[pos], ac)
                        fmt.Printf(" (Continue) \n")
                }</span> else<span class="cov8" title="1"> {
                        current = 0
                }</span>
                <span class="cov8" title="1">_, ok := f[current]
                if ok </span><span class="cov8" title="1">{
                        for i := range f[current] </span><span class="cov8" title="1">{
                                if p[f[current][i]] == GetWord(pos-len(p[f[current][i]])+1, pos, t) </span><span class="cov8" title="1">{ //check for word match
                                        newOccurrences := IntArrayCapUp(occurrences[f[current][i]])
                                        occurrences[f[current][i]] = newOccurrences
                                        occurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">elapsed := time.Since(startTime)
        fmt.Printf("\n\nElapsed %f secs\n", elapsed.Seconds())
        var resultOccurrences = make(map[string][]int)
        for key, value := range occurrences </span><span class="cov8" title="1">{
                resultOccurrences[p[key]] = value
        }</span>

        <span class="cov8" title="1">return Result{
                resultOccurrences,
        }</span>
}

// Functions that builds Aho Corasick automaton.
func BuildAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int, s []int) <span class="cov8" title="1">{
        acTrie, stateIsTerminal, f := ConstructTrie(p)
        s = make([]int, len(stateIsTerminal)) //supply function
        i := 0                                //root of acTrie
        acToReturn = acTrie
        s[i] = -1
        for current := 1; current &lt; len(stateIsTerminal); current++ </span><span class="cov8" title="1">{
                o, parent := GetParent(current, acTrie)
                down := s[parent]
                for StateExists(down, acToReturn) &amp;&amp; GetTransition(down, o, acToReturn) == -1 </span><span class="cov8" title="1">{
                        down = s[down]
                }</span>
                <span class="cov8" title="1">if StateExists(down, acToReturn) </span><span class="cov8" title="1">{
                        s[current] = GetTransition(down, o, acToReturn)
                        if stateIsTerminal[s[current]] </span><span class="cov0" title="0">{
                                stateIsTerminal[current] = true
                                f[current] = ArrayUnion(f[current], f[s[current]]) //F(Current) &lt;- F(Current) union F(S(Current))
                        }</span>
                } else<span class="cov8" title="1"> {
                        s[current] = i //initial state?
                }</span>
        }
        <span class="cov8" title="1">return acToReturn, f, s</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package ahocorasick

// ConstructTrie Function that constructs Trie as an automaton for a set of reversed &amp; trimmed strings.
func ConstructTrie(p []string) (trie map[int]map[uint8]int, stateIsTerminal []bool, f map[int][]int) <span class="cov8" title="1">{
        trie = make(map[int]map[uint8]int)
        stateIsTerminal = make([]bool, 1)
        f = make(map[int][]int)
        state := 1
        CreateNewState(0, trie)
        for i := 0; i &lt; len(p); i++ </span><span class="cov8" title="1">{
                current := 0
                j := 0
                for j &lt; len(p[i]) &amp;&amp; GetTransition(current, p[i][j], trie) != -1 </span><span class="cov8" title="1">{
                        current = GetTransition(current, p[i][j], trie)
                        j++
                }</span>
                <span class="cov8" title="1">for j &lt; len(p[i]) </span><span class="cov8" title="1">{
                        stateIsTerminal = BoolArrayCapUp(stateIsTerminal)
                        CreateNewState(state, trie)
                        stateIsTerminal[state] = false
                        CreateTransition(current, p[i][j], state, trie)
                        current = state
                        j++
                        state++
                }</span>
                <span class="cov8" title="1">if stateIsTerminal[current] </span><span class="cov0" title="0">{
                        newArray := IntArrayCapUp(f[current])
                        newArray[len(newArray)-1] = i
                        f[current] = newArray // F(Current) &lt;- F(Current) union {i}
                }</span> else<span class="cov8" title="1"> {
                        stateIsTerminal[current] = true
                        f[current] = []int{i} // F(Current) &lt;- {i}
                }</span>
        }
        <span class="cov8" title="1">return trie, stateIsTerminal, f</span>
}

// Contains Returns 'true' if array of int's 's' contains int 'e', 'false' otherwise.
func Contains(s []int, e int) bool <span class="cov0" title="0">{
        for _, a := range s </span><span class="cov0" title="0">{
                if a == e </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetWord Function that returns word found in text 't' at position range 'begin' to 'end'.
func GetWord(begin, end int, t string) string <span class="cov8" title="1">{
        for end &gt;= len(t) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">d := make([]uint8, end-begin+1)
        for j, i := 0, begin; i &lt;= end; i, j = i+1, j+1 </span><span class="cov8" title="1">{
                d[j] = t[i]
        }</span>
        <span class="cov8" title="1">return string(d)</span>
}

// ComputeAlphabet Function that returns string of all the possible characters in given patterns.
func ComputeAlphabet(p []string) (s string) <span class="cov0" title="0">{
        s = p[0]
        for i := 1; i &lt; len(p); i++ </span><span class="cov0" title="0">{
                s = s + p[i]
        }</span>
        <span class="cov0" title="0">return s</span>
}

// IntArrayCapUp Dynamically increases an array size of int's by 1.
func IntArrayCapUp(old []int) (new []int) <span class="cov8" title="1">{
        new = make([]int, cap(old)+1)
        copy(new, old) //copy(dst,src)
        // old = new
        return new
}</span>

// BoolArrayCapUp Dynamically increases an array size of bool's by 1.
func BoolArrayCapUp(old []bool) (new []bool) <span class="cov8" title="1">{
        new = make([]bool, cap(old)+1)
        copy(new, old)
        // old = new
        return new
}</span>

// ArrayUnion Concats two arrays of int's into one.
func ArrayUnion(to, from []int) (concat []int) <span class="cov0" title="0">{
        concat = to
        for i := range from </span><span class="cov0" title="0">{
                if !Contains(concat, from[i]) </span><span class="cov0" title="0">{
                        concat = IntArrayCapUp(concat)
                        concat[len(concat)-1] = from[i]
                }</span>
        }
        <span class="cov0" title="0">return concat</span>
}

// GetParent Function that finds the first previous state of a state and returns it.
// Used for trie where there is only one parent.
func GetParent(state int, at map[int]map[uint8]int) (uint8, int) <span class="cov8" title="1">{
        for beginState, transitions := range at </span><span class="cov8" title="1">{
                for c, endState := range transitions </span><span class="cov8" title="1">{
                        if endState == state </span><span class="cov8" title="1">{
                                return c, beginState
                        }</span>
                }
        }
        <span class="cov0" title="0">return 0, 0</span> //unreachable
}

// CreateNewState Automaton function for creating a new state 'state'.
func CreateNewState(state int, at map[int]map[uint8]int) <span class="cov8" title="1">{
        at[state] = make(map[uint8]int)
}</span>

// CreateTransition Creates a transition for function σ(state,letter) = end.
func CreateTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) <span class="cov8" title="1">{
        at[fromState][overChar] = toState
}</span>

// GetTransition Returns ending state for transition σ(fromState,overChar), '-1' if there is none.
func GetTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) <span class="cov8" title="1">{
        if !StateExists(fromState, at) </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">toState, ok := at[fromState][overChar]
        if !ok </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return toState</span>
}

// StateExists Checks if state 'state' exists. Returns 'true' if it does, 'false' otherwise.
func StateExists(state int, at map[int]map[uint8]int) bool <span class="cov8" title="1">{
        _, ok := at[state]
        if !ok || state == -1 || at[state] == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// charoccurrence.go
// description: An algorithm which counts the number
// of times a character occurred in a string.
// author(s) [Moein](https://github.com/mo1ein)
// see charoccurrence_test.go

package strings

// CountChars counts the number of a times a character
// has occurred in the provided string argument and
// returns a map with `rune` as keys and the count as value.
func CountChars(text string) map[rune]int <span class="cov8" title="1">{
        charMap := make(map[rune]int, 0)
        for _, c := range text </span><span class="cov8" title="1">{
                if _, ok := charMap[c]; !ok </span><span class="cov8" title="1">{
                        charMap[c] = 0
                }</span>
                <span class="cov8" title="1">charMap[c]++</span>
        }
        <span class="cov8" title="1">return charMap</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// generateparenthesesgo
// description: Generate Parentheses
// details:
// Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
// author(s) [red_byte](https://github.com/i-redbyte)
// see generateparentheses_test.go

package generateparentheses

import "strings"

func GenerateParenthesis(n int) []string <span class="cov8" title="1">{
        result := make([]string, 0)
        maxLen := 2 * n
        var recursiveComputation func(s []string, left int, right int)
        recursiveComputation = func(s []string, left int, right int) </span><span class="cov8" title="1">{
                if len(s) == maxLen </span><span class="cov8" title="1">{
                        result = append(result, strings.Join(s, ""))
                        return
                }</span>
                <span class="cov8" title="1">if left &lt; n </span><span class="cov8" title="1">{
                        s = append(s, "(")
                        recursiveComputation(s, left+1, right)
                        s = s[:len(s)-1]
                }</span>
                <span class="cov8" title="1">if right &lt; left </span><span class="cov8" title="1">{
                        s = append(s, ")")
                        recursiveComputation(s, left, right+1)
                        _ = s[:len(s)-1]
                }</span>
        }
        <span class="cov8" title="1">recursiveComputation(make([]string, 0), 0, 0)
        return result</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// Package genetic provides functions to work with strings
// using genetic algorithm. https://en.wikipedia.org/wiki/Genetic_algorithm
//
// Author: D4rkia
package genetic

import (
        "errors"
        "fmt"
        "math/rand"
        "sort"
        "strconv"
        "time"
        "unicode/utf8"
)

// Population item represent a single step in the evolution process.
// One can think of population item as a single species.
// Key stands for the actual data entity of the species, which is a string
// in current implementation. Key can be interpreted as species DNA.
// Value shows how close this species to the desired target, where 1 means,
// that species DNA equals to the targeted one, 0 for no matchings in the DNA.
//
// **Note** In the current implementation species DNA length is suppose to be
// equal to the target length for algorithm to work.
type PopulationItem struct {
        Key   string
        Value float64
}

// Conf stands for configurations set provided to GeneticString function.
type Conf struct {
        // Maximum size of the population.
        // Bigger could be faster but more memory expensive.
        PopulationNum int

        // Number of elements selected in every generation for evolution
        // the selection takes. Place from the best to the worst of that
        // generation must be smaller than PopulationNum.
        SelectionNum int

        // Probability that an element of a generation can mutate changing one of
        // its genes this guarantees that all genes will be used during evolution.
        MutationProb float64

        // Enables debugging output to the console.
        Debug bool
}

// Result structure contains generation process statistics, as well as the
// best resulted population item.
type Result struct {
        // Number of generations steps performed.
        Generation int

        // Number of generated population items.
        Analyzed int

        // Result of generation with the best Value.
        Best PopulationItem
}

// GeneticString generates PopulationItem based on the imputed target
// string, and a set of possible runes to build a string with. In order
// to optimise string generation additional configurations can be provided
// with Conf instance. Empty instance of Conf (&amp;Conf{}) can be provided,
// then default values would be set.
//
// Link to the same algorithm implemented in python:
// https://github.com/TheAlgorithms/Python/blob/master/genetic_algorithm/basic_string.py
func GeneticString(target string, charmap []rune, conf *Conf) (*Result, error) <span class="cov8" title="1">{
        populationNum := conf.PopulationNum
        if populationNum == 0 </span><span class="cov8" title="1">{
                populationNum = 200
        }</span>

        <span class="cov8" title="1">selectionNum := conf.SelectionNum
        if selectionNum == 0 </span><span class="cov8" title="1">{
                selectionNum = 50
        }</span>

        // Verify if 'populationNum' s bigger than 'selectionNum'
        <span class="cov8" title="1">if populationNum &lt; selectionNum </span><span class="cov0" title="0">{
                return nil, errors.New("populationNum must be bigger than selectionNum")
        }</span>

        <span class="cov8" title="1">mutationProb := conf.MutationProb
        if mutationProb == .0 </span><span class="cov8" title="1">{
                mutationProb = .4
        }</span>

        <span class="cov8" title="1">debug := conf.Debug

        // Just a seed to improve randomness required by the algorithm
        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))

        // Verify that the target contains no genes besides the ones inside genes variable.
        for position, r := range target </span><span class="cov8" title="1">{
                invalid := true
                for _, n := range charmap </span><span class="cov8" title="1">{
                        if n == r </span><span class="cov8" title="1">{
                                invalid = false
                        }</span>
                }
                <span class="cov8" title="1">if invalid </span><span class="cov0" title="0">{
                        message := fmt.Sprintf("character not available in charmap at position: %v", position)
                        return nil, errors.New(message)
                }</span>
        }

        // Generate random starting population
        <span class="cov8" title="1">pop := make([]PopulationItem, populationNum)
        for i := 0; i &lt; populationNum; i++ </span><span class="cov8" title="1">{
                key := ""
                for x := 0; x &lt; utf8.RuneCountInString(target); x++ </span><span class="cov8" title="1">{
                        choice := rnd.Intn(len(charmap))
                        key += string(charmap[choice])
                }</span>
                <span class="cov8" title="1">pop[i] = PopulationItem{key, 0}</span>
        }

        // Just some logs to know what the algorithms is doing
        <span class="cov8" title="1">gen, generatedPop := 0, 0

        // This loop will end when we will find a perfect match for our target
        for </span><span class="cov8" title="1">{
                gen++
                generatedPop += len(pop)

                // Random population created now it's time to evaluate
                for i, item := range pop </span><span class="cov8" title="1">{
                        pop[i].Value = 0
                        itemKey, targetRune := []rune(item.Key), []rune(target)
                        for x := 0; x &lt; len(target); x++ </span><span class="cov8" title="1">{
                                if itemKey[x] == targetRune[x] </span><span class="cov8" title="1">{
                                        pop[i].Value++
                                }</span>
                        }
                        <span class="cov8" title="1">pop[i].Value = pop[i].Value / float64(len(targetRune))</span>
                }
                <span class="cov8" title="1">sort.SliceStable(pop, func(i, j int) bool </span><span class="cov8" title="1">{ return pop[i].Value &gt; pop[j].Value }</span>)

                // Check if there is a matching evolution
                <span class="cov8" title="1">if pop[0].Key == target </span><span class="cov8" title="1">{
                        break</span>
                }

                // Print the best resultPrint the Best result every 10 generations
                // just to know that the algorithm is working
                <span class="cov8" title="1">if debug &amp;&amp; gen%10 == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Generation:", strconv.Itoa(gen), "Analyzed:", generatedPop, "Best:", pop[0])
                }</span>

                // Generate a new population vector keeping some of the best evolutions
                // Keeping this avoid regression of evolution
                <span class="cov8" title="1">var popChildren []PopulationItem
                popChildren = append(popChildren, pop[0:int(selectionNum/3)]...)

                // This is Selection
                for i := 0; i &lt; int(selectionNum); i++ </span><span class="cov8" title="1">{
                        parent1 := pop[i]
                        // Generate more child proportionally to the fitness score
                        nChild := (parent1.Value * 100) + 1
                        if nChild &gt;= 10 </span><span class="cov8" title="1">{
                                nChild = 10
                        }</span>
                        <span class="cov8" title="1">for x := 0.0; x &lt; nChild; x++ </span><span class="cov8" title="1">{
                                parent2 := pop[rnd.Intn(selectionNum)]
                                // Crossover
                                split := rnd.Intn(utf8.RuneCountInString(target))
                                child1 := append([]rune(parent1.Key)[:split], []rune(parent2.Key)[split:]...)
                                child2 := append([]rune(parent2.Key)[:split], []rune(parent1.Key)[split:]...)
                                // Clean fitness value
                                // Mutate
                                if rnd.Float64() &lt; mutationProb </span><span class="cov8" title="1">{
                                        child1[rnd.Intn(len(child1))] = charmap[rnd.Intn(len(charmap))]
                                }</span>
                                <span class="cov8" title="1">if rnd.Float64() &lt; mutationProb </span><span class="cov8" title="1">{
                                        child2[rnd.Intn(len(child2))] = charmap[rnd.Intn(len(charmap))]
                                }</span>
                                // Push into 'popChildren'
                                <span class="cov8" title="1">popChildren = append(popChildren, PopulationItem{string(child1), 0})
                                popChildren = append(popChildren, PopulationItem{string(child2), 0})

                                // Check if the population has already reached the maximum value and if so,
                                // break the cycle. If this check is disabled the algorithm will take
                                // forever to compute large strings but will also calculate small string in
                                // a lot fewer generationsù
                                if len(popChildren) &gt;= selectionNum </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">pop = popChildren</span>
        }
        <span class="cov8" title="1">return &amp;Result{gen, generatedPop, pop[0]}, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// guid.go
// description: Generate random globally unique identifiers (GUIDs).
// details:
// A GUID (globally unique identifier) is a 128-bit text string that
// represents an identification (ID). Organizations generate GUIDs when
// a unique reference number is needed to identify information on
// a computer or network. A GUID can be used to ID hardware, software,
// accounts, documents and other items. The term is also often used in
// software created by Microsoft.
// See more information on: https://en.wikipedia.org/wiki/Universally_unique_identifier
// author(s) [cheatsnake](https://github.com/cheatsnake)
// see guid_test.go

// Package guid provides facilities for generating random globally unique identifiers.
package guid

import (
        "crypto/rand"
        "fmt"
        "math/big"
        "strings"
)

const pattern string = "xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx"
const versionIndex int = 14

// New returns a randomly generated global unique identifier.
func New() (string, error) <span class="cov8" title="1">{
        var guid strings.Builder

        for i, ch := range pattern </span><span class="cov8" title="1">{
                if i == versionIndex </span><span class="cov8" title="1">{
                        guid.WriteRune(ch)
                        continue</span>
                }
                <span class="cov8" title="1">if ch == '-' </span><span class="cov8" title="1">{
                        guid.WriteRune(ch)
                        continue</span>
                }
                <span class="cov8" title="1">random, err := rand.Int(rand.Reader, big.NewInt(16))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">guid.WriteString(fmt.Sprintf("%x", random.Int64()))</span>
        }

        <span class="cov8" title="1">return guid.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">// Implementation of the
// [Boyer–Moore–Horspool algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm)

package horspool

import "errors"

var ErrNotFound = errors.New("pattern was not found in the input string")

func Horspool(t, p string) (int, error) <span class="cov8" title="1">{
        // in order to handle multy-byte character properly
        // the input is converted into rune arrays
        return horspool([]rune(t), []rune(p))
}</span>

func horspool(t, p []rune) (int, error) <span class="cov8" title="1">{
        shiftMap := computeShiftMap(t, p)
        pos := 0
        for pos &lt;= len(t)-len(p) </span><span class="cov8" title="1">{
                if isMatch(pos, t, p) </span><span class="cov8" title="1">{
                        return pos, nil
                }</span>
                <span class="cov8" title="1">if pos+len(p) &gt;= len(t) </span><span class="cov8" title="1">{
                        // because the remaining length of the input string
                        // is the same as the length of the pattern
                        // and it does not match the pattern
                        // it is impossible to find the pattern
                        break</span>
                }

                // because of the check above
                // t[pos+len(p)] is defined
                <span class="cov8" title="1">pos += shiftMap[t[pos+len(p)]]</span>
        }

        <span class="cov8" title="1">return -1, ErrNotFound</span>
}

// Checks if the array p matches the subarray of t starting at pos.
// Note that backward iteration.
// There are [other](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm#Tuning_the_comparison_loop)
// approaches possible.
func isMatch(pos int, t, p []rune) bool <span class="cov8" title="1">{
        j := len(p)
        for j &gt; 0 &amp;&amp; t[pos+j-1] == p[j-1] </span><span class="cov8" title="1">{
                j--
        }</span>
        <span class="cov8" title="1">return j == 0</span>
}

func computeShiftMap(t, p []rune) (res map[rune]int) <span class="cov8" title="1">{
        res = make(map[rune]int)
        for _, tCode := range t </span><span class="cov8" title="1">{
                res[tCode] = len(p)
        }</span>
        <span class="cov8" title="1">for i, pCode := range p </span><span class="cov8" title="1">{
                res[pCode] = len(p) - i
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">// Checks if a given string is an isogram.
// A first-order isogram is a word in which no letter of the alphabet occurs more than once.
// A second-order isogram is a word in which each letter appears twice.
// A third-order isogram is a word in which each letter appears three times.
// wiki: https://en.wikipedia.org/wiki/Heterogram_(literature)#Isograms
// Author: M3talM0nk3y

package strings

import (
        "errors"
        "regexp"
        "strings"
)

type IsogramOrder int

const (
        First IsogramOrder = iota + 1
        Second
        Third
)

func hasDigit(text string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`\d`)
        return re.MatchString(text)
}</span>

func hasSymbol(text string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`[-!@#$%^&amp;*()+]`)
        return re.MatchString(text)
}</span>

func IsIsogram(text string, order IsogramOrder) (bool, error) <span class="cov8" title="1">{
        if order &lt; First || order &gt; Third </span><span class="cov8" title="1">{
                return false, errors.New("Invalid isogram order provided")
        }</span>

        <span class="cov8" title="1">text = strings.ToLower(text)
        text = strings.Join(strings.Fields(text), "")

        if hasDigit(text) || hasSymbol(text) </span><span class="cov8" title="1">{
                return false, errors.New("Cannot contain numbers or symbols")
        }</span>

        <span class="cov8" title="1">letters := make(map[string]int)
        for _, c := range text </span><span class="cov8" title="1">{
                l := string(c)
                if _, ok := letters[l]; ok </span><span class="cov8" title="1">{
                        letters[l] += 1

                        if letters[l] &gt; 3 </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>

                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">letters[l] = 1</span>
        }

        <span class="cov8" title="1">mapVals := make(map[int]bool)
        for _, v := range letters </span><span class="cov8" title="1">{
                mapVals[v] = true
        }</span>

        <span class="cov8" title="1">if _, ok := mapVals[int(order)]; ok &amp;&amp; len(mapVals) == 1 </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">// Checks if a given string is a subsequence of another string.
// A subsequence of a given string is a string that can be derived from the given
// string by deleting some or no characters without changing the order of the
// remaining characters. (i.e., "dpr" is a subsequence of "depqr" while "drp" is not).
// Author: sanjibgirics

package strings

// Returns true if s is subsequence of t, otherwise return false.
func IsSubsequence(s string, t string) bool <span class="cov8" title="1">{
        if len(s) &gt; len(t) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if s == t </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">sIndex := 0
        for tIndex := 0; tIndex &lt; len(t); tIndex++ </span><span class="cov8" title="1">{
                if s[sIndex] == t[tIndex] </span><span class="cov8" title="1">{
                        sIndex++
                }</span>

                <span class="cov8" title="1">if sIndex == len(s) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package kmp

// Kmp Function kmp performing the Knuth-Morris-Pratt algorithm.
func Kmp(word, text string, patternTable []int) []int <span class="cov8" title="1">{
        if len(word) &gt; len(text) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var (
                i, j    int
                matches []int
        )
        for i+j &lt; len(text) </span><span class="cov8" title="1">{

                if word[j] == text[i+j] </span><span class="cov8" title="1">{
                        j++
                        if j == len(word) </span><span class="cov8" title="1">{
                                matches = append(matches, i)

                                i = i + j
                                j = 0
                        }</span>
                } else<span class="cov8" title="1"> {
                        i = i + j - patternTable[j]
                        if patternTable[j] &gt; -1 </span><span class="cov8" title="1">{
                                j = patternTable[j]
                        }</span> else<span class="cov8" title="1"> {
                                j = 0
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// table building for kmp algorithm.
func table(w string) []int <span class="cov8" title="1">{
        var (
                t []int = []int{-1}
                k int
        )
        for j := 1; j &lt; len(w); j++ </span><span class="cov8" title="1">{
                k = j - 1
                for w[0:k] != w[j-k:j] &amp;&amp; k &gt; 0 </span><span class="cov8" title="1">{
                        k--
                }</span>
                <span class="cov8" title="1">t = append(t, k)</span>
        }
        <span class="cov8" title="1">return t</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">/*
This algorithm calculates the distance between two strings.
Parameters: two strings to compare and weights of insertion, substitution and deletion.
Output: distance between both strings
*/

package levenshtein

// Distance Function that gives Levenshtein Distance
func Distance(str1, str2 string, icost, scost, dcost int) int <span class="cov8" title="1">{
        row1 := make([]int, len(str2)+1)
        row2 := make([]int, len(str2)+1)

        for i := 1; i &lt;= len(str2); i++ </span><span class="cov8" title="1">{
                row1[i] = i * icost
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= len(str1); i++ </span><span class="cov8" title="1">{
                row2[0] = i * dcost

                for j := 1; j &lt;= len(str2); j++ </span><span class="cov8" title="1">{
                        if str1[i-1] == str2[j-1] </span><span class="cov8" title="1">{
                                row2[j] = row1[j-1]
                        }</span> else<span class="cov8" title="1"> {
                                ins := row2[j-1] + icost
                                del := row1[j] + dcost
                                sub := row1[j-1] + scost

                                if ins &lt; del &amp;&amp; ins &lt; sub </span><span class="cov8" title="1">{
                                        row2[j] = ins
                                }</span> else<span class="cov8" title="1"> if del &lt; sub </span><span class="cov8" title="1">{
                                        row2[j] = del
                                }</span> else<span class="cov8" title="1"> {
                                        row2[j] = sub
                                }</span>
                        }
                }
                <span class="cov8" title="1">row1, row2 = row2, row1</span>
        }

        <span class="cov8" title="1">return row1[len(row1)-1]</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// longestpalindrome.go
// description: Manacher's algorithm (Longest palindromic substring)
// details:
// An algorithm with linear running time that allows you to get compressed information about all palindromic substrings of a given string. - [Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)
// author(s) [red_byte](https://github.com/i-redbyte)
// see longestpalindrome_test.go

package manacher

import (
        "github.com/TheAlgorithms/Go/math/min"
        "strings"
)

func makeBoundaries(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        result.WriteRune('#')
        for _, ch := range s </span><span class="cov8" title="1">{
                if ch != ' ' </span><span class="cov8" title="1">{ //ignore space as palindrome character
                        result.WriteRune(ch)
                }</span>
                <span class="cov8" title="1">result.WriteRune('#')</span>
        }
        <span class="cov8" title="1">return result.String()</span>
}

func nextBoundary(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        for _, ch := range s </span><span class="cov8" title="1">{
                if ch != '#' </span><span class="cov8" title="1">{
                        result.WriteRune(ch)
                }</span>
        }
        <span class="cov8" title="1">return result.String()</span>
}

func LongestPalindrome(s string) string <span class="cov8" title="1">{
        boundaries := makeBoundaries(s)
        b := make([]int, len(boundaries))
        k := 0
        index := 0
        maxLen := 0
        maxCenterSize := 0
        for i := range b </span><span class="cov8" title="1">{
                if i &lt; k </span><span class="cov8" title="1">{
                        b[i] = min.Int(b[2*index-i], k-i)
                }</span> else<span class="cov8" title="1"> {
                        b[i] = 1
                }</span>
                <span class="cov8" title="1">for i-b[i] &gt;= 0 &amp;&amp; i+b[i] &lt; len(boundaries) &amp;&amp; boundaries[i-b[i]] == boundaries[i+b[i]] </span><span class="cov8" title="1">{
                        b[i] += 1
                }</span>
                <span class="cov8" title="1">if maxLen &lt; b[i]-1 </span><span class="cov8" title="1">{
                        maxLen = b[i] - 1
                        maxCenterSize = i
                }</span>
                <span class="cov8" title="1">if b[i]+i-1 &gt; k </span><span class="cov8" title="1">{
                        k = b[i] + i - 1
                        index = i
                }</span>
        }
        <span class="cov8" title="1">return nextBoundary(boundaries[maxCenterSize-maxLen : maxCenterSize+maxLen])</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// ispalindrome.go
// description: Checks if a given string is palindrome or not
// details:
// Palindromes are expressions that read the same way forwards and backwards.
// They can be words/phrases (like "racecar" and "Do geese see God?"), or even
// numbers (like "02/02/2020"). Usually punctuation signs, capitalization
// and spaces are ignored. A regular expression was used to achieve that.
// See more information on: https://en.wikipedia.org/wiki/Palindrome
// author(s) [Fernanda Kawasaki](https://github.com/fernandakawasaki)
// see ispalindrome_test.go

package palindrome

import (
        "regexp"
        "strings"
)

func cleanString(text string) string <span class="cov8" title="1">{
        clean_text := strings.ToLower(text)
        clean_text = strings.Join(strings.Fields(clean_text), "") // Remove spaces
        regex, _ := regexp.Compile(`[^\p{L}\p{N} ]+`)             // Regular expression for alphanumeric only characters
        return regex.ReplaceAllString(clean_text, "")
}</span>

func IsPalindrome(text string) bool <span class="cov8" title="1">{
        clean_text := cleanString(text)
        var i, j int
        rune := []rune(clean_text)
        for i = 0; i &lt; len(rune)/2; i++ </span><span class="cov8" title="1">{
                j = len(rune) - 1 - i
                if string(rune[i]) != string(rune[j]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func IsPalindromeRecursive(text string) bool <span class="cov8" title="1">{
        clean_text := cleanString(text)
        runes := []rune(clean_text)
        return isPalindromeRecursiveHelper(runes, 0, int64(len(runes)))
}</span>

func isPalindromeRecursiveHelper(runes []rune, start int64, end int64) bool <span class="cov8" title="1">{
        if start &gt;= end </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if runes[start] != runes[end-1] </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">start = start + 1
        end = end - 1
        return isPalindromeRecursiveHelper(runes, start, end)</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">// ispangram.go
// description: Checks if a given string is pangram or not
// details: A pangram is a sentence or expression that uses all the letters of the alphabet.
// Reference: https://www.geeksforgeeks.org/pangram-checking/
// Author : Kavitha J

package pangram

import (
        "regexp"
        "strings"
)

func cleanString(text string) string <span class="cov8" title="1">{
        cleanText := strings.ToLower(text)                      // Convert to lowercase
        cleanText = strings.Join(strings.Fields(cleanText), "") // Remove spaces
        regex, _ := regexp.Compile(`[^\p{L}\p{N} ]+`)           // Regular expression for alphanumeric only characters
        return regex.ReplaceAllString(cleanText, "")
}</span>

func IsPangram(text string) bool <span class="cov8" title="1">{
        cleanText := cleanString(text)
        if len(cleanText) &lt; 26 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">var data = make(map[rune]bool)
        for _, i := range cleanText </span><span class="cov8" title="1">{
                data[i] = true
        }</span>
        <span class="cov8" title="1">return len(data) == 26</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package parenthesis

// Parenthesis algorithm checks if every opened parenthesis
// is closed correctly. When parcounter is less than 0 when a closing
// parenthesis is detected without an opening parenthesis
// that surrounds it and parcounter will be 0 if all open
// parenthesis are closed correctly.
func Parenthesis(text string) bool <span class="cov8" title="1">{
        parcounter := 0

        for _, r := range text </span><span class="cov8" title="1">{
                switch r </span>{
                case '(':<span class="cov8" title="1">
                        parcounter++</span>
                case ')':<span class="cov8" title="1">
                        parcounter--</span>
                }
                <span class="cov8" title="1">if parcounter &lt; 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return parcounter == 0</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package search

// Implementation of boyer moore string search
// O(l) where l=len(text)
func BoyerMoore(text string, pattern string) []int <span class="cov8" title="1">{
        var positions []int

        l := len(text)
        n := len(pattern)

        // using booyer moore horspool modification
        // O(n) space instead of O(n**2)
        bcr := make(map[byte]int)
        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                bcr[pattern[i]] = n - i - 1
        }</span>

        // Apostolico–Giancarlo modification
        // allow to skip patterns that we know matches
        // let us do O(l) instead of O(ln)
        <span class="cov8" title="1">skips := make(map[int]int)
        for _, s := range bcr </span><span class="cov8" title="1">{
                i := 0
                for ; i &lt; n-s; i++ </span><span class="cov8" title="1">{
                        if pattern[n-1-i] != pattern[n-1-s-i] </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">skips[s] = i</span>
        }

        <span class="cov8" title="1">skip := 0
        jump := n
        for i := 0; i &lt; l-n+1; </span><span class="cov8" title="1">{
                skip = skips[jump]
                for k := n - 1; k &gt; -1; k-- </span><span class="cov8" title="1">{
                        if text[i+k] != pattern[k] </span><span class="cov8" title="1">{
                                jump, ok := bcr[text[i+k]]
                                if !ok </span><span class="cov8" title="1">{
                                        jump = n
                                }</span>
                                <span class="cov8" title="1">i += jump
                                break</span>
                        }
                        <span class="cov8" title="1">if k == n-jump </span><span class="cov8" title="1">{
                                k -= skip
                        }</span>
                        <span class="cov8" title="1">if k == 0 </span><span class="cov8" title="1">{
                                positions = append(positions, i)
                                jump = 1
                                i += jump
                        }</span>
                }
        }

        <span class="cov8" title="1">return positions</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package search

// Implementation of naive string search
// O(n*m) where n=len(txt) and m=len(pattern)
func Naive(text string, pattern string) []int <span class="cov8" title="1">{
        var positions []int
        for i := 0; i &lt;= len(text)-len(pattern); i++ </span><span class="cov8" title="1">{
                var match bool = true
                for j := 0; j &lt; len(pattern); j++ </span><span class="cov8" title="1">{
                        if text[i+j] != pattern[j] </span><span class="cov8" title="1">{
                                match = false
                                break</span>
                        }

                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        positions = append(positions, i)
                }</span>
        }
        <span class="cov8" title="1">return positions</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// description: Double Ended Queue is a generalized version of Queue data structure that allows insert and delete at both ends.
// References:
//        Wikipedia : https://en.wikipedia.org/wiki/Double-ended_queue
//        Github: https://www.geeksforgeeks.org/deque-set-1-introduction-applications/
// author [Sayan](https://github.com/bose-sayan)

// Package deque implements a Double Ended Queue data structure.
package deque

import (
        "errors"
)

// ErrEmptyDequeue is a custom error for handling cases when some dequeuing operation is performed on an empty deque.
var ErrEmptyDequeue = errors.New("DoublyEnded queue is empty, so can't perform this operation")

type DoublyEndedQueue[T any] struct {
        deque []T
}

// New returns a new DoublyEndedQueue.
func New[T any]() *DoublyEndedQueue[T] <span class="cov8" title="1">{
        return &amp;DoublyEndedQueue[T]{deque: make([]T, 0)}
}</span>

// EnqueueFront adds an item at the front of Deque.
func (dq *DoublyEndedQueue[T]) EnqueueFront(item T) <span class="cov8" title="1">{
        dq.deque = append([]T{item}, dq.deque...)
}</span>

// EnqueueRear adds an item at the rear of Deque.
func (dq *DoublyEndedQueue[T]) EnqueueRear(item T) <span class="cov8" title="1">{
        dq.deque = append(dq.deque, item)
}</span>

// DequeueFront deletes an item from front of Deque and returns it.
func (dq *DoublyEndedQueue[T]) DequeueFront() (T, error) <span class="cov8" title="1">{
        if len(dq.deque) == 0 </span><span class="cov8" title="1">{
                var zeroVal T
                return zeroVal, ErrEmptyDequeue
        }</span>
        <span class="cov8" title="1">frontElement := dq.deque[0]
        dq.deque = dq.deque[1:]
        return frontElement, nil</span>
}

// DequeueRear deletes an item from rear of Deque and returns it.
func (dq *DoublyEndedQueue[T]) DequeueRear() (T, error) <span class="cov8" title="1">{
        if len(dq.deque) == 0 </span><span class="cov8" title="1">{
                var zeroVal T
                return zeroVal, ErrEmptyDequeue
        }</span>
        <span class="cov8" title="1">rearElement := dq.deque[len(dq.deque)-1]
        dq.deque = dq.deque[:len(dq.deque)-1]
        return rearElement, nil</span>
}

// Front gets the front item from queue.
func (dq *DoublyEndedQueue[T]) Front() (T, error) <span class="cov8" title="1">{
        if (len(dq.deque)) == 0 </span><span class="cov8" title="1">{
                var zeroVal T
                return zeroVal, ErrEmptyDequeue
        }</span>
        <span class="cov8" title="1">return dq.deque[0], nil</span>
}

// Rear gets the last item from queue.
func (dq *DoublyEndedQueue[T]) Rear() (T, error) <span class="cov8" title="1">{
        if (len(dq.deque)) == 0 </span><span class="cov8" title="1">{
                var zeroVal T
                return zeroVal, ErrEmptyDequeue
        }</span>
        <span class="cov8" title="1">return dq.deque[len(dq.deque)-1], nil</span>
}

// IsEmpty checks whether Deque is empty or not.
func (dq *DoublyEndedQueue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(dq.deque) == 0
}</span>

// Length gets the length of Deque.
func (dq *DoublyEndedQueue[T]) Length() int <span class="cov8" title="1">{
        return len(dq.deque)
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">// Package dynamicarray
// A dynamic array is quite similar to a regular array, but its Size is modifiable during program runtime,
// very similar to how a slice in Go works. The implementation is for educational purposes and explains
// how one might go about implementing their own version of slices.
//
// For more details check out those links below here:
// GeeksForGeeks article : https://www.geeksforgeeks.org/how-do-dynamic-arrays-work/
// Go blog: https://blog.golang.org/slices-intro
// Go blog: https://blog.golang.org/slices
// authors [Wesllhey Holanda](https://github.com/wesllhey), [Milad](https://github.com/miraddo)
// see dynamicarray.go, dynamicarray_test.go
package dynamicarray

import (
        "errors"
)

var defaultCapacity = 10

// DynamicArray structure
type DynamicArray struct {
        Size        int
        Capacity    int
        ElementData []any
}

// Put function is change/update the value in array with the index and new value
func (da *DynamicArray) Put(index int, element any) error <span class="cov8" title="1">{
        err := da.CheckRangeFromIndex(index)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">da.ElementData[index] = element

        return nil</span>
}

// Add function is add new element to our array
func (da *DynamicArray) Add(element any) <span class="cov8" title="1">{
        if da.Size == da.Capacity </span><span class="cov8" title="1">{
                da.NewCapacity()
        }</span>

        <span class="cov8" title="1">da.ElementData[da.Size] = element
        da.Size++</span>
}

// Remove function is remove an element with the index
func (da *DynamicArray) Remove(index int) error <span class="cov8" title="1">{
        err := da.CheckRangeFromIndex(index)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">copy(da.ElementData[index:], da.ElementData[index+1:da.Size])
        da.ElementData[da.Size-1] = nil

        da.Size--

        return nil</span>
}

// Get function is return one element with the index of array
func (da *DynamicArray) Get(index int) (any, error) <span class="cov8" title="1">{
        err := da.CheckRangeFromIndex(index)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return da.ElementData[index], nil</span>
}

// IsEmpty function is check that the array has value or not
func (da *DynamicArray) IsEmpty() bool <span class="cov8" title="1">{
        return da.Size == 0
}</span>

// GetData function return all value of array
func (da *DynamicArray) GetData() []any <span class="cov8" title="1">{
        return da.ElementData[:da.Size]
}</span>

// CheckRangeFromIndex function it will check the range from the index
func (da *DynamicArray) CheckRangeFromIndex(index int) error <span class="cov8" title="1">{
        if index &gt;= da.Size || index &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("index out of range")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewCapacity function increase the Capacity
func (da *DynamicArray) NewCapacity() <span class="cov8" title="1">{
        if da.Capacity == 0 </span><span class="cov8" title="1">{
                da.Capacity = defaultCapacity
        }</span> else<span class="cov0" title="0"> {
                da.Capacity = da.Capacity &lt;&lt; 1
        }</span>

        <span class="cov8" title="1">newDataElement := make([]any, da.Capacity)

        copy(newDataElement, da.ElementData)

        da.ElementData = newDataElement</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">// Fenwick Tree Data Structure for efficient range queries on an array of integers.
// Also known as Binary Indexed Tree. It can query the sum of any range of the array and
// can update the array at a specific position by adding a value to it (point update).
// Build: O(N)
// Query: O(log(N))
// Update: O(log(N))
// reference: https://brilliant.org/wiki/fenwick-tree/
package fenwicktree

// FenwickTree represents the data structure of the Fenwick Tree
type FenwickTree struct {
        n     int   // n: Size of the input array.
        array []int // array: the input array on which queries are made.
        bit   []int // bit: store the sum of ranges.
}

// NewFenwickTree creates a new Fenwick tree, initializes bit with
// the values of the array. Note that the queries and updates should have
// one based indexing.
func NewFenwickTree(array []int) *FenwickTree <span class="cov8" title="1">{
        newArray := []int{0} // Appending a 0 to the beginning as this implementation uses 1 based indexing
        fenwickTree := &amp;FenwickTree{
                n:     len(array),
                array: append(newArray, array...),
                bit:   append(newArray, array...),
        }
        for i := 1; i &lt; fenwickTree.n; i++ </span><span class="cov8" title="1">{
                nextPos := i + (i &amp; -i)
                if nextPos &lt;= fenwickTree.n </span><span class="cov8" title="1">{
                        fenwickTree.bit[nextPos] += fenwickTree.bit[i]
                }</span>
        }
        <span class="cov8" title="1">return fenwickTree</span>
}

// PrefixSum returns the sum of the prefix ending at position pos.
func (f *FenwickTree) PrefixSum(pos int) int <span class="cov8" title="1">{
        if pos &gt; f.n </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">prefixSum := 0
        for i := pos; i &gt; 0; i -= (i &amp; -i) </span><span class="cov8" title="1">{
                prefixSum += f.bit[i]
        }</span>
        <span class="cov8" title="1">return prefixSum</span>
}

// RangeSum returns the sum of the elements in the range l to r
// both inclusive.
func (f *FenwickTree) RangeSum(l int, r int) int <span class="cov8" title="1">{
        return f.PrefixSum(r) - f.PrefixSum(l-1)
}</span>

// Add Adds value to the element at position pos of the array
// and recomputes the range sums.
func (f *FenwickTree) Add(pos int, value int) <span class="cov8" title="1">{
        for i := pos; i &lt;= f.n; i += (i &amp; -i) </span><span class="cov8" title="1">{
                f.bit[i] += value
        }</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package hashmap

import (
        "fmt"
        "hash/fnv"
)

var defaultCapacity uint64 = 1 &lt;&lt; 10

type node struct {
        key   any
        value any
        next  *node
}

// HashMap is golang implementation of hashmap
type HashMap struct {
        capacity uint64
        size     uint64
        table    []*node
}

// New return new HashMap instance
func New() *HashMap <span class="cov8" title="1">{
        return &amp;HashMap{
                capacity: defaultCapacity,
                table:    make([]*node, defaultCapacity),
        }
}</span>

// Make creates a new HashMap instance with input size and capacity
func Make(size, capacity uint64) HashMap <span class="cov8" title="1">{
        return HashMap{
                size:     size,
                capacity: capacity,
                table:    make([]*node, capacity),
        }
}</span>

// Get returns value associated with given key
func (hm *HashMap) Get(key any) any <span class="cov8" title="1">{
        node := hm.getNodeByHash(hm.hash(key))

        if node != nil </span><span class="cov8" title="1">{
                return node.value
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Put puts new key value in hashmap
func (hm *HashMap) Put(key any, value any) any <span class="cov8" title="1">{
        return hm.putValue(hm.hash(key), key, value)
}</span>

// Contains checks if given key is stored in hashmap
func (hm *HashMap) Contains(key any) bool <span class="cov8" title="1">{
        node := hm.getNodeByHash(hm.hash(key))
        return node != nil
}</span>

func (hm *HashMap) putValue(hash uint64, key any, value any) any <span class="cov8" title="1">{
        if hm.capacity == 0 </span><span class="cov0" title="0">{
                hm.capacity = defaultCapacity
                hm.table = make([]*node, defaultCapacity)
        }</span>

        <span class="cov8" title="1">node := hm.getNodeByHash(hash)

        if node == nil </span><span class="cov8" title="1">{
                hm.table[hash] = newNode(key, value)

        }</span> else<span class="cov8" title="1"> if node.key == key </span><span class="cov8" title="1">{
                hm.table[hash] = newNodeWithNext(key, value, node)
                return value

        }</span> else<span class="cov8" title="1"> {
                hm.resize()
                return hm.putValue(hash, key, value)
        }</span>

        <span class="cov8" title="1">hm.size++

        return value</span>

}

func (hm *HashMap) getNodeByHash(hash uint64) *node <span class="cov8" title="1">{
        return hm.table[hash]
}</span>

func (hm *HashMap) resize() <span class="cov8" title="1">{
        hm.capacity &lt;&lt;= 1

        tempTable := hm.table

        hm.table = make([]*node, hm.capacity)

        for i := 0; i &lt; len(tempTable); i++ </span><span class="cov8" title="1">{
                node := tempTable[i]
                if node == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">hm.table[hm.hash(node.key)] = node</span>
        }
}

func newNode(key any, value any) *node <span class="cov8" title="1">{
        return &amp;node{
                key:   key,
                value: value,
        }
}</span>

func newNodeWithNext(key any, value any, next *node) *node <span class="cov8" title="1">{
        return &amp;node{
                key:   key,
                value: value,
                next:  next,
        }
}</span>

func (hm *HashMap) hash(key any) uint64 <span class="cov8" title="1">{
        h := fnv.New64a()
        _, _ = h.Write([]byte(fmt.Sprintf("%v", key)))

        hashValue := h.Sum64()

        return (hm.capacity - 1) &amp; (hashValue ^ (hashValue &gt;&gt; 16))
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">package heap

import (
        "errors"
        "github.com/TheAlgorithms/Go/constraints"
)

// Heap heap implementation using generic.
type Heap[T any] struct {
        heaps    []T
        lessFunc func(a, b T) bool
}

// New gives a new heap object.
func New[T constraints.Ordered]() *Heap[T] <span class="cov8" title="1">{
        less := func(a, b T) bool </span><span class="cov0" title="0">{
                return a &lt; b
        }</span>
        <span class="cov8" title="1">h, _ := NewAny[T](less)
        return h</span>
}

// NewAny gives a new heap object. element can be anything, but must provide less function.
func NewAny[T any](less func(a, b T) bool) (*Heap[T], error) <span class="cov8" title="1">{
        if less == nil </span><span class="cov0" title="0">{
                return nil, errors.New("less func is necessary")
        }</span>
        <span class="cov8" title="1">return &amp;Heap[T]{
                lessFunc: less,
        }, nil</span>
}

// Push pushes the element t onto the heap.
// The complexity is O(log n) where n = h.Len().
func (h *Heap[T]) Push(t T) <span class="cov8" title="1">{
        h.heaps = append(h.heaps, t)
        h.up(len(h.heaps) - 1)
}</span>

// Top returns the minimum element (according to Less) from the heap.
// Top panics if the heap is empty.
func (h *Heap[T]) Top() T <span class="cov8" title="1">{
        return h.heaps[0]
}</span>

// Pop removes the minimum element (according to Less) from the heap.
// The complexity is O(log n) where n = h.Len().
func (h *Heap[T]) Pop() <span class="cov8" title="1">{
        if len(h.heaps) &lt;= 1 </span><span class="cov8" title="1">{
                h.heaps = nil
                return
        }</span>
        <span class="cov8" title="1">h.swap(0, len(h.heaps)-1)
        h.heaps = h.heaps[:len(h.heaps)-1]
        h.down(0)</span>
}

// Empty returns the heap is empty or not.
func (h *Heap[T]) Empty() bool <span class="cov8" title="1">{
        return len(h.heaps) == 0
}</span>

// Size returns the size of the heap
func (h *Heap[T]) Size() int <span class="cov8" title="1">{
        return len(h.heaps)
}</span>

func (h *Heap[T]) swap(i, j int) <span class="cov8" title="1">{
        h.heaps[i], h.heaps[j] = h.heaps[j], h.heaps[i]
}</span>

func (h *Heap[T]) up(child int) <span class="cov8" title="1">{
        if child &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">parent := (child - 1) &gt;&gt; 1
        if !h.lessFunc(h.heaps[child], h.heaps[parent]) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">h.swap(child, parent)
        h.up(parent)</span>
}

func (h *Heap[T]) down(parent int) <span class="cov8" title="1">{
        lessIdx := parent
        lChild, rChild := (parent&lt;&lt;1)+1, (parent&lt;&lt;1)+2
        if lChild &lt; len(h.heaps) &amp;&amp; h.lessFunc(h.heaps[lChild], h.heaps[lessIdx]) </span><span class="cov8" title="1">{
                lessIdx = lChild
        }</span>
        <span class="cov8" title="1">if rChild &lt; len(h.heaps) &amp;&amp; h.lessFunc(h.heaps[rChild], h.heaps[lessIdx]) </span><span class="cov8" title="1">{
                lessIdx = rChild
        }</span>
        <span class="cov8" title="1">if lessIdx == parent </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">h.swap(lessIdx, parent)
        h.down(lessIdx)</span>
}
</pre>
		
		<pre class="file" id="file174" style="display: none">package linkedlist

import "fmt"

// Cyclic Struct which cycles the linked list in this implementation.
type Cyclic[T any] struct {
        Size int
        Head *Node[T]
}

// Create new list.
func NewCyclic[T any]() *Cyclic[T] <span class="cov8" title="1">{
        return &amp;Cyclic[T]{}
}</span>

// Inserting the first node is a special case. It will
// point to itself. For other cases, the node will be added
// to the end of the list. End of the list is Prev field of
// current item. Complexity O(1).
func (cl *Cyclic[T]) Add(val T) <span class="cov8" title="1">{
        n := NewNode(val)
        cl.Size++
        if cl.Head == nil </span><span class="cov8" title="1">{
                n.Prev = n
                n.Next = n
                cl.Head = n
        }</span> else<span class="cov8" title="1"> {
                n.Prev = cl.Head.Prev
                n.Next = cl.Head
                cl.Head.Prev.Next = n
                cl.Head.Prev = n
        }</span>
}

// Rotate list by P places.
// This method is interesting for optimization.
// For first optimization we must decrease
// P value so that it ranges from 0 to N-1.
// For this we need to use the operation of
// division modulo. But be careful if P is less than 0.
// if it is - make it positive. This can be done without
// violating the meaning of the number by adding to it
// a multiple of N. Now you can decrease P modulo N to
// rotate the list by the minimum number of places.
// We use the fact that moving forward in a circle by P
// places is the same as moving N - P places back.
// Therefore, if P &gt; N / 2, you can turn the list by N-P places back.
// Complexity O(n).
func (cl *Cyclic[T]) Rotate(places int) <span class="cov8" title="1">{
        if cl.Size &gt; 0 </span><span class="cov8" title="1">{
                if places &lt; 0 </span><span class="cov8" title="1">{
                        multiple := cl.Size - 1 - places/cl.Size
                        places += multiple * cl.Size
                }</span>
                <span class="cov8" title="1">places %= cl.Size

                if places &gt; cl.Size/2 </span><span class="cov8" title="1">{
                        places = cl.Size - places
                        for i := 0; i &lt; places; i++ </span><span class="cov8" title="1">{
                                cl.Head = cl.Head.Prev
                        }</span>
                } else<span class="cov8" title="1"> if places == 0 </span><span class="cov8" title="1">{
                        return
                }</span> else<span class="cov8" title="1"> {
                        for i := 0; i &lt; places; i++ </span><span class="cov8" title="1">{
                                cl.Head = cl.Head.Next
                        }</span>

                }
        }
}

// Delete the current item.
func (cl *Cyclic[T]) Delete() bool <span class="cov8" title="1">{
        var deleted bool
        var prevItem, thisItem, nextItem *Node[T]

        if cl.Size == 0 </span><span class="cov8" title="1">{
                return deleted
        }</span>

        <span class="cov8" title="1">deleted = true
        thisItem = cl.Head
        nextItem = thisItem.Next
        prevItem = thisItem.Prev

        if cl.Size == 1 </span><span class="cov8" title="1">{
                cl.Head = nil
        }</span> else<span class="cov8" title="1"> {
                cl.Head = nextItem
                nextItem.Prev = prevItem
                prevItem.Next = nextItem
        }</span>
        <span class="cov8" title="1">cl.Size--

        return deleted</span>
}

// Destroy all items in the list.
func (cl *Cyclic[T]) Destroy() <span class="cov8" title="1">{
        for cl.Delete() </span><span class="cov8" title="1">{
                continue</span>
        }
}

// Show list body.
func (cl *Cyclic[T]) Walk() *Node[T] <span class="cov8" title="1">{
        var start *Node[T]
        start = cl.Head

        for i := 0; i &lt; cl.Size; i++ </span><span class="cov8" title="1">{
                fmt.Printf("%v \n", start.Val)
                start = start.Next
        }</span>
        <span class="cov8" title="1">return start</span>
}

// https://en.wikipedia.org/wiki/Josephus_problem
// This is a struct-based solution for Josephus problem.
func JosephusProblem(cl *Cyclic[int], k int) int <span class="cov8" title="1">{
        for cl.Size &gt; 1 </span><span class="cov8" title="1">{
                cl.Rotate(k)
                cl.Delete()
                cl.Rotate(-1)
        }</span>
        <span class="cov8" title="1">retval := cl.Head.Val
        cl.Destroy()
        return retval</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package linkedlist

import "fmt"

// Doubly structure with just the Head Node
// We call it `Doubly` to make it easier to
// understand when calling this in peoples
// own local code to understand and experiment
// with this easily.
// For example, we can use gotools `go get` command to get
// this repository cloned inside the
// $GOPATH/src/github.com/TheAlgorithms/Go (you can do this
// manually as well) and use the import statement as follows:
//
// `import "github.com/TheAlgorithms/Go/structure/linkedlist"`
//
// and call linkedlist.Doubly to create a new doubly linked list.
type Doubly[T any] struct {
        Head *Node[T]
}

// Init initializes double linked list
func (ll *Doubly[T]) Init() *Doubly[T] <span class="cov8" title="1">{
        ll.Head = &amp;Node[T]{}
        ll.Head.Next = ll.Head
        ll.Head.Prev = ll.Head

        return ll
}</span>

func NewDoubly[T any]() *Doubly[T] <span class="cov8" title="1">{
        return new(Doubly[T]).Init()
}</span>

// lazyInit lazily initializes a zero List value.
func (ll *Doubly[T]) lazyInit() <span class="cov8" title="1">{
        if ll.Head.Next == nil </span><span class="cov0" title="0">{
                ll.Init()
        }</span>
}

func (ll *Doubly[T]) insert(n, at *Node[T]) *Node[T] <span class="cov8" title="1">{
        n.Prev = at
        n.Next = at.Next
        n.Prev.Next = n
        n.Next.Prev = n

        return n
}</span>

func (ll *Doubly[T]) insertValue(val T, at *Node[T]) *Node[T] <span class="cov8" title="1">{
        return ll.insert(NewNode(val), at)
}</span>

// AddAtBeg Add a node to the beginning of the linkedlist
func (ll *Doubly[T]) AddAtBeg(val T) <span class="cov8" title="1">{
        ll.lazyInit()
        ll.insertValue(val, ll.Head)
}</span>

// AddAtEnd Add a node at the end of the linkedlist
func (ll *Doubly[T]) AddAtEnd(val T) <span class="cov8" title="1">{
        ll.lazyInit()
        ll.insertValue(val, ll.Head.Prev)
}</span>

func (ll *Doubly[T]) Remove(n *Node[T]) T <span class="cov8" title="1">{
        n.Prev.Next = n.Next
        n.Next.Prev = n.Prev
        n.Next = nil
        n.Prev = nil

        return n.Val
}</span>

// DelAtBeg Delete the node at the beginning of the linkedlist
func (ll *Doubly[T]) DelAtBeg() (T, bool) <span class="cov8" title="1">{
        // no item
        if ll.Head.Next == nil </span><span class="cov0" title="0">{
                var r T
                return r, false
        }</span>

        <span class="cov8" title="1">n := ll.Head.Next
        val := n.Val
        ll.Remove(n)
        return val, true</span>
}

// DetAtEnd Delete a node at the end of the linkedlist
func (ll *Doubly[T]) DelAtEnd() (T, bool) <span class="cov8" title="1">{
        // no item
        if ll.Head.Prev == nil </span><span class="cov0" title="0">{
                var r T
                return r, false
        }</span>

        <span class="cov8" title="1">n := ll.Head.Prev
        val := n.Val
        ll.Remove(n)
        return val, true</span>
}

// DelByPos deletes node at middle based on position in list
// and returns value. If empty or position of node is less than linked list length, returns false
func (ll *Doubly[T]) DelByPos(pos int) (T, bool) <span class="cov0" title="0">{

        switch </span>{
        case ll.Head == nil:<span class="cov0" title="0">
                var r T
                return r, false</span>
        case pos-1 == 0:<span class="cov0" title="0">
                return ll.DelAtBeg()</span>
        case pos-1 == ll.Count():<span class="cov0" title="0">
                return ll.DelAtEnd()</span>
        case pos-1 &gt; ll.Count():<span class="cov0" title="0">
                var r T
                return r, false</span>
        }
        <span class="cov0" title="0">var prev *Node[T]
        var val T
        cur := ll.Head
        count := 0

        for count &lt; pos-1 </span><span class="cov0" title="0">{
                prev = cur
                cur = cur.Next
                count++
        }</span>

        <span class="cov0" title="0">cur.Next.Prev = prev
        val = cur.Val
        prev.Next = cur.Next
        return val, true</span>
}

// Count Number of nodes in the linkedlist
func (ll *Doubly[T]) Count() int <span class="cov8" title="1">{
        var ctr int = 0

        if ll.Head.Next == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">for cur := ll.Head.Next; cur != ll.Head; cur = cur.Next </span><span class="cov8" title="1">{
                ctr += 1
        }</span>

        <span class="cov8" title="1">return ctr</span>
}

// Reverse Reverse the order of the linkedlist
func (ll *Doubly[T]) Reverse() <span class="cov8" title="1">{
        var Prev, Next *Node[T]
        cur := ll.Head

        for cur != nil </span><span class="cov8" title="1">{
                Next = cur.Next
                cur.Next = Prev
                cur.Prev = Next
                Prev = cur
                cur = Next
        }</span>

        <span class="cov8" title="1">ll.Head = Prev</span>
}

// Display display the linked list
func (ll *Doubly[T]) Display() <span class="cov0" title="0">{
        for cur := ll.Head.Next; cur != ll.Head; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Print(cur.Val, " ")
        }</span>

        <span class="cov0" title="0">fmt.Print("\n")</span>
}

// DisplayReverse Display the linkedlist in reverse order
func (ll *Doubly[T]) DisplayReverse() <span class="cov0" title="0">{
        if ll.Head == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var cur *Node[T]
        for cur = ll.Head.Prev; cur != ll.Head; cur = cur.Prev </span><span class="cov0" title="0">{
                fmt.Print(cur.Val, " ")
        }</span>

        <span class="cov0" title="0">fmt.Print("\n")</span>
}

func (ll *Doubly[T]) Front() *Node[T] <span class="cov0" title="0">{
        if ll.Count() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return ll.Head.Next</span>
}

func (ll *Doubly[T]) Back() *Node[T] <span class="cov0" title="0">{
        if ll.Count() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return ll.Head.Prev</span>
}

func (ll *Doubly[T]) MoveToBack(n *Node[T]) <span class="cov0" title="0">{
        if ll.Head.Prev == n </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ll.move(n, ll.Head.Prev)</span>
}

func (ll *Doubly[T]) move(n, at *Node[T]) <span class="cov0" title="0">{
        if n == at </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">n.Prev.Next = n.Next
        n.Next.Prev = n.Prev

        n.Prev = at
        n.Next = at.Next
        n.Prev.Next = n
        n.Next.Prev = n</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package linkedlist

// Node Structure representing the linkedlist node.
// This node is shared across different implementations.
type Node[T any] struct {
        Val  T
        Prev *Node[T]
        Next *Node[T]
}

// Create new node.
func NewNode[T any](val T) *Node[T] <span class="cov8" title="1">{
        return &amp;Node[T]{val, nil, nil}
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">package linkedlist

// demonstration of singly linked list in golang
import (
        "errors"
        "fmt"
)

// Singly structure with length of the list and its head
type Singly[T any] struct {
        length int

        // Note that Node here holds both Next and Prev Node
        // however only the Next node is used in Singly methods.
        Head *Node[T]
}

// NewSingly returns a new instance of a linked list
func NewSingly[T any]() *Singly[T] <span class="cov8" title="1">{
        return &amp;Singly[T]{}
}</span>

// AddAtBeg adds a new snode with given value at the beginning of the list.
func (ll *Singly[T]) AddAtBeg(val T) <span class="cov8" title="1">{
        n := NewNode(val)
        n.Next = ll.Head
        ll.Head = n
        ll.length++
}</span>

// AddAtEnd adds a new snode with given value at the end of the list.
func (ll *Singly[T]) AddAtEnd(val T) <span class="cov8" title="1">{
        n := NewNode(val)

        if ll.Head == nil </span><span class="cov0" title="0">{
                ll.Head = n
                ll.length++
                return
        }</span>

        <span class="cov8" title="1">cur := ll.Head
        for ; cur.Next != nil; cur = cur.Next </span>{<span class="cov8" title="1">
        }</span>
        <span class="cov8" title="1">cur.Next = n
        ll.length++</span>
}

// DelAtBeg deletes the snode at the head(beginning) of the list
// and returns its value. Returns false if the list is empty.
func (ll *Singly[T]) DelAtBeg() (T, bool) <span class="cov8" title="1">{
        if ll.Head == nil </span><span class="cov0" title="0">{
                var r T
                return r, false
        }</span>

        <span class="cov8" title="1">cur := ll.Head
        ll.Head = cur.Next
        ll.length--

        return cur.Val, true</span>
}

// DelAtEnd deletes the snode at the tail(end) of the list
// and returns its value. Returns false if the list is empty.
func (ll *Singly[T]) DelAtEnd() (T, bool) <span class="cov8" title="1">{
        if ll.Head == nil </span><span class="cov0" title="0">{
                var r T
                return r, false
        }</span>

        <span class="cov8" title="1">if ll.Head.Next == nil </span><span class="cov0" title="0">{
                return ll.DelAtBeg()
        }</span>

        <span class="cov8" title="1">cur := ll.Head

        for ; cur.Next.Next != nil; cur = cur.Next </span>{<span class="cov8" title="1">
        }</span>

        <span class="cov8" title="1">retval := cur.Next.Val
        cur.Next = nil
        ll.length--
        return retval, true</span>

}

// DelByPos deletes the node at the middle based on position in the list
// and returns its value. Returns false if the list is empty or length is not more than given position
func (ll *Singly[T]) DelByPos(pos int) (T, bool) <span class="cov0" title="0">{
        switch </span>{
        case ll.Head == nil:<span class="cov0" title="0">
                var r T
                return r, false</span>
        case pos-1 &gt; ll.length:<span class="cov0" title="0">
                var r T
                return r, false</span>
        case pos-1 == 0:<span class="cov0" title="0">
                return ll.DelAtBeg()</span>
        case pos-1 == ll.Count():<span class="cov0" title="0">
                return ll.DelAtEnd()</span>
        }

        <span class="cov0" title="0">var prev *Node[T]
        var val T
        cur := ll.Head
        count := 0

        for count &lt; pos-1 </span><span class="cov0" title="0">{
                prev = cur
                cur = cur.Next
                count++
        }</span>

        <span class="cov0" title="0">val = cur.Val
        prev.Next = cur.Next
        ll.length--

        return val, true</span>
}

// Count returns the current size of the list.
func (ll *Singly[T]) Count() int <span class="cov8" title="1">{
        return ll.length
}</span>

// Reverse reverses the list.
func (ll *Singly[T]) Reverse() <span class="cov8" title="1">{
        var prev, Next *Node[T]
        cur := ll.Head

        for cur != nil </span><span class="cov8" title="1">{
                Next = cur.Next
                cur.Next = prev
                prev = cur
                cur = Next
        }</span>

        <span class="cov8" title="1">ll.Head = prev</span>
}

// ReversePartition Reverse the linked list from the ath to the bth node
func (ll *Singly[T]) ReversePartition(left, right int) error <span class="cov8" title="1">{
        err := ll.CheckRangeFromIndex(left, right)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tmpNode := &amp;Node[T]{}
        tmpNode.Next = ll.Head
        pre := tmpNode
        for i := 0; i &lt; left-1; i++ </span><span class="cov8" title="1">{
                pre = pre.Next
        }</span>
        <span class="cov8" title="1">cur := pre.Next
        for i := 0; i &lt; right-left; i++ </span><span class="cov8" title="1">{
                next := cur.Next
                cur.Next = next.Next
                next.Next = pre.Next
                pre.Next = next
        }</span>
        <span class="cov8" title="1">ll.Head = tmpNode.Next
        return nil</span>
}
func (ll *Singly[T]) CheckRangeFromIndex(left, right int) error <span class="cov8" title="1">{
        if left &gt; right </span><span class="cov0" title="0">{
                return errors.New("left boundary must smaller than right")
        }</span> else<span class="cov8" title="1"> if left &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("left boundary starts from the first node")
        }</span> else<span class="cov8" title="1"> if right &gt; ll.length </span><span class="cov0" title="0">{
                return errors.New("right boundary cannot be greater than the length of the linked list")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Display prints out the elements of the list.
func (ll *Singly[T]) Display() <span class="cov0" title="0">{
        for cur := ll.Head; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Print(cur.Val, " ")
        }</span>

        <span class="cov0" title="0">fmt.Print("\n")</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">// Queue Array
// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.
//         The order is First In First Out (FIFO).
// details:
//         Queue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/
//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see queuelinkedlist.go, queuelinkedlistwithlist.go, queue_test.go

package queue

var ListQueue []any

// EnQueue it will be added new value into our list
func EnQueue(n any) <span class="cov8" title="1">{
        ListQueue = append(ListQueue, n)
}</span>

// DeQueue it will be removed the first value that added into the list
func DeQueue() any <span class="cov8" title="1">{
        data := ListQueue[0]
        ListQueue = ListQueue[1:]
        return data
}</span>

// FrontQueue return the Front value
func FrontQueue() any <span class="cov8" title="1">{
        return ListQueue[0]
}</span>

// BackQueue return the Back value
func BackQueue() any <span class="cov0" title="0">{
        return ListQueue[len(ListQueue)-1]
}</span>

// LenQueue will return the length of the queue list
func LenQueue() int <span class="cov8" title="1">{
        return len(ListQueue)
}</span>

// IsEmptyQueue check our list is empty or not
func IsEmptyQueue() bool <span class="cov8" title="1">{
        return len(ListQueue) == 0
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">// Queue Linked-List
// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.
//         The order is First In First Out (FIFO).
// details:
//         Queue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/
//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see queuearray.go, queuelinkedlistwithlist.go, queue_test.go

package queue

// Node will be store the value and the next node as well
type Node struct {
        Data any
        Next *Node
}

// Queue structure is tell us what our head is and what tail should be with length of the list
type Queue struct {
        head   *Node
        tail   *Node
        length int
}

// enqueue it will be added new value into queue
func (ll *Queue) enqueue(n any) <span class="cov8" title="1">{
        var newNode Node // create new Node
        newNode.Data = n // set the data

        if ll.tail != nil </span><span class="cov8" title="1">{
                ll.tail.Next = &amp;newNode
        }</span>

        <span class="cov8" title="1">ll.tail = &amp;newNode

        if ll.head == nil </span><span class="cov8" title="1">{
                ll.head = &amp;newNode
        }</span>
        <span class="cov8" title="1">ll.length++</span>
}

// dequeue it will be removed the first value into queue (First In First Out)
func (ll *Queue) dequeue() any <span class="cov8" title="1">{
        if ll.isEmpty() </span><span class="cov0" title="0">{
                return -1 // if is empty return -1
        }</span>
        <span class="cov8" title="1">data := ll.head.Data

        ll.head = ll.head.Next

        if ll.head == nil </span><span class="cov0" title="0">{
                ll.tail = nil
        }</span>

        <span class="cov8" title="1">ll.length--
        return data</span>
}

// isEmpty it will check our list is empty or not
func (ll *Queue) isEmpty() bool <span class="cov8" title="1">{
        return ll.length == 0
}</span>

// len is return the length of queue
func (ll *Queue) len() int <span class="cov8" title="1">{
        return ll.length
}</span>

// frontQueue it will return the front data
func (ll *Queue) frontQueue() any <span class="cov8" title="1">{
        return ll.head.Data
}</span>

// backQueue it will return the back data
func (ll *Queue) backQueue() any <span class="cov0" title="0">{
        return ll.tail.Data
}</span>
</pre>
		
		<pre class="file" id="file180" style="display: none">// Queue Linked-List with standard library (Container/List)
// description: based on `geeksforgeeks` description A Queue is a linear structure which follows a particular order in which the operations are performed.
//         The order is First In First Out (FIFO).
// details:
//         Queue Data Structure : https://www.geeksforgeeks.org/queue-data-structure/
//  Queue (abstract data type) : https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see queuearray.go, queuelinkedlist.go, queue_test.go

package queue

// container/list: is used as linked-list
// fmt: used to return fmt.Errorf for the error part
import (
        "container/list"
        "fmt"
)

// LQueue will be store the value into the list
type LQueue struct {
        queue *list.List
}

// Enqueue will be added new value
func (lq *LQueue) Enqueue(value any) <span class="cov8" title="1">{
        lq.queue.PushBack(value)
}</span>

// Dequeue will be removed the first value that input (First In First Out - FIFO)
func (lq *LQueue) Dequeue() error <span class="cov8" title="1">{

        if !lq.Empty() </span><span class="cov8" title="1">{
                element := lq.queue.Front()
                lq.queue.Remove(element)

                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("dequeue is empty we got an error")</span>
}

// Front it will return the front value
func (lq *LQueue) Front() (any, error) <span class="cov8" title="1">{
        if !lq.Empty() </span><span class="cov8" title="1">{
                val := lq.queue.Front().Value
                return val, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("error queue is empty")</span>
}

// Back it will return the back value
func (lq *LQueue) Back() (any, error) <span class="cov8" title="1">{
        if !lq.Empty() </span><span class="cov8" title="1">{
                val := lq.queue.Back().Value
                return val, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("error queue is empty")</span>
}

// Len it will return the length of list
func (lq *LQueue) Len() int <span class="cov8" title="1">{
        return lq.queue.Len()
}</span>

// Empty is check our list is empty or not
func (lq *LQueue) Empty() bool <span class="cov8" title="1">{
        return lq.queue.Len() == 0
}</span>
</pre>
		
		<pre class="file" id="file181" style="display: none">// Segment Tree Data Structure for efficient range queries on an array of integers.
// It can query the sum and update the elements to a new value of any range of the array.
// Build: O(n*log(n))
// Query: O(log(n))
// Update: O(log(n))
// reference: https://cp-algorithms.com/data_structures/segment_tree.html
package segmenttree

import (
        "github.com/TheAlgorithms/Go/math/max"
        "github.com/TheAlgorithms/Go/math/min"
)

const emptyLazyNode = 0

// SegmentTree represents the data structure of a segment tree with lazy propagation
type SegmentTree struct {
        Array       []int // The original array
        SegmentTree []int // Stores the sum of different ranges
        LazyTree    []int // Stores the values of lazy propagation
}

// Propagate propagates the lazy updates to the child nodes
func (s *SegmentTree) Propagate(node int, leftNode int, rightNode int) <span class="cov8" title="1">{
        if s.LazyTree[node] != emptyLazyNode </span><span class="cov8" title="1">{
                //add lazy node value multiplied by (right-left+1), which represents all interval
                //this is the same of adding a value on each node
                s.SegmentTree[node] += (rightNode - leftNode + 1) * s.LazyTree[node]

                if leftNode == rightNode </span><span class="cov8" title="1">{
                        //leaf node
                        s.Array[leftNode] += s.LazyTree[node]
                }</span> else<span class="cov8" title="1"> {
                        //propagate lazy node value for children nodes
                        //may propagate multiple times, children nodes should accumulate lazy node value
                        s.LazyTree[2*node] += s.LazyTree[node]
                        s.LazyTree[2*node+1] += s.LazyTree[node]
                }</span>

                //clear lazy node
                <span class="cov8" title="1">s.LazyTree[node] = emptyLazyNode</span>
        }
}

// Query returns the sum of elements of the array in the interval [firstIndex, leftIndex].
// node, leftNode and rightNode should always start with 1, 0 and len(Array)-1, respectively.
func (s *SegmentTree) Query(node int, leftNode int, rightNode int, firstIndex int, lastIndex int) int <span class="cov8" title="1">{
        if (firstIndex &gt; lastIndex) || (leftNode &gt; rightNode) </span><span class="cov8" title="1">{
                //outside the interval
                return 0
        }</span>

        //propagate lazy tree
        <span class="cov8" title="1">s.Propagate(node, leftNode, rightNode)

        if (leftNode &gt;= firstIndex) &amp;&amp; (rightNode &lt;= lastIndex) </span><span class="cov8" title="1">{
                //inside the interval
                return s.SegmentTree[node]
        }</span>

        //get sum of left and right nodes
        <span class="cov8" title="1">mid := (leftNode + rightNode) / 2

        leftNodeSum := s.Query(2*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex))
        rightNodeSum := s.Query(2*node+1, mid+1, rightNode, max.Int(firstIndex, mid+1), lastIndex)

        return leftNodeSum + rightNodeSum</span>
}

// Update updates the elements of the array in the range [firstIndex, lastIndex]
// with the new value provided and recomputes the sum of different ranges.
// node, leftNode and rightNode should always start with 1, 0 and len(Array)-1, respectively.
func (s *SegmentTree) Update(node int, leftNode int, rightNode int, firstIndex int, lastIndex int, value int) <span class="cov8" title="1">{
        //propagate lazy tree
        s.Propagate(node, leftNode, rightNode)

        if (firstIndex &gt; lastIndex) || (leftNode &gt; rightNode) </span><span class="cov8" title="1">{
                //outside the interval
                return
        }</span>

        <span class="cov8" title="1">if (leftNode &gt;= firstIndex) &amp;&amp; (rightNode &lt;= lastIndex) </span><span class="cov8" title="1">{
                //inside the interval
                //accumulate the lazy node value
                s.LazyTree[node] += value
                s.Propagate(node, leftNode, rightNode)
        }</span> else<span class="cov8" title="1"> {
                //update left and right nodes
                mid := (leftNode + rightNode) / 2

                s.Update(2*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex), value)
                s.Update(2*node+1, mid+1, rightNode, max.Int(firstIndex, mid+1), lastIndex, value)

                s.SegmentTree[node] = s.SegmentTree[2*node] + s.SegmentTree[2*node+1]
        }</span>
}

// Build builds the SegmentTree by computing the sum of different ranges.
// node, leftNode and rightNode should always start with 1, 0 and len(Array)-1, respectively.
func (s *SegmentTree) Build(node int, left int, right int) <span class="cov8" title="1">{
        if left == right </span><span class="cov8" title="1">{
                //leaf node
                s.SegmentTree[node] = s.Array[left]
        }</span> else<span class="cov8" title="1"> {
                //get sum of left and right nodes
                mid := (left + right) / 2

                s.Build(2*node, left, mid)
                s.Build(2*node+1, mid+1, right)

                s.SegmentTree[node] = s.SegmentTree[2*node] + s.SegmentTree[2*node+1]
        }</span>
}

// NewSegmentTree returns a new instance of a SegmentTree. It takes an input
// array of integers representing Array, initializes and builds the SegmentTree.
func NewSegmentTree(Array []int) *SegmentTree <span class="cov8" title="1">{
        if len(Array) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">segTree := SegmentTree{
                Array:       Array,
                SegmentTree: make([]int, 4*len(Array)),
                LazyTree:    make([]int, 4*len(Array)),
        }

        for i := range segTree.LazyTree </span><span class="cov8" title="1">{
                //fill LazyTree with empty lazy nodes
                segTree.LazyTree[i] = emptyLazyNode
        }</span>

        //starts with node 1 and interval [0, len(arr)-1] inclusive
        <span class="cov8" title="1">segTree.Build(1, 0, len(Array)-1)

        return &amp;segTree</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">// package set implements a Set using a golang map.
// This implies that only the types that are accepted as valid map keys can be used as set elements.
// For instance, do not try to Add a slice, or the program will panic.
package set

// New gives new set.
func New[T comparable](items ...T) Set[T] <span class="cov8" title="1">{
        st := set[T]{
                elements: make(map[T]bool),
        }
        for _, item := range items </span><span class="cov8" title="1">{
                st.Add(item)
        }</span>
        <span class="cov8" title="1">return &amp;st</span>
}

// Set is an interface of possible methods on 'set'.
type Set[T comparable] interface {
        // Add: adds new element to the set
        Add(item T)
        // Delete: deletes the passed element from the set if present
        Delete(item T)
        // Len: gives the length of the set (total no. of elements in set)
        Len() int
        // GetItems: gives the array( []T ) of elements of the set.
        GetItems() []T
        // In: checks whether item is present in set or not.
        In(item T) bool
        // IsSubsetOf: checks whether set is subset of set2 or not.
        IsSubsetOf(set2 Set[T]) bool
        // IsProperSubsetOf: checks whether set is proper subset of set2 or not.
        // ex: [1,2,3] proper subset of [1,2,3,4] -&gt; true
        IsProperSubsetOf(set2 Set[T]) bool
        // IsSupersetOf: checks whether set is superset of set2 or not.
        IsSupersetOf(set2 Set[T]) bool
        // IsProperSupersetOf: checks whether set is proper superset of set2 or not.
        // ex: [1,2,3,4] proper superset of [1,2,3] -&gt; true
        IsProperSupersetOf(set2 Set[T]) bool
        // Union: gives new union set of both sets.
        // ex: [1,2,3] union [3,4,5] -&gt; [1,2,3,4,5]
        Union(set2 Set[T]) Set[T]
        // Intersection: gives new intersection set of both sets.
        // ex: [1,2,3] Intersection [3,4,5] -&gt; [3]
        Intersection(set2 Set[T]) Set[T]
        // Difference: gives new difference set of both sets.
        // ex: [1,2,3] Difference [3,4,5] -&gt; [1,2]
        Difference(set2 Set[T]) Set[T]
        // SymmetricDifference: gives new symmetric difference set of both sets.
        // ex: [1,2,3] SymmetricDifference [3,4,5] -&gt; [1,2,4,5]
        SymmetricDifference(set2 Set[T]) Set[T]
}

type set[T comparable] struct {
        elements map[T]bool
}

func (st *set[T]) Add(value T) <span class="cov8" title="1">{
        st.elements[value] = true
}</span>

func (st *set[T]) Delete(value T) <span class="cov8" title="1">{
        delete(st.elements, value)
}</span>

func (st *set[T]) GetItems() []T <span class="cov8" title="1">{
        keys := make([]T, 0, len(st.elements))
        for k := range st.elements </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

func (st *set[T]) Len() int <span class="cov8" title="1">{
        return len(st.elements)
}</span>

func (st *set[T]) In(value T) bool <span class="cov8" title="1">{
        if _, in := st.elements[value]; in </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (st *set[T]) IsSubsetOf(superSet Set[T]) bool <span class="cov8" title="1">{
        if st.Len() &gt; superSet.Len() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, item := range st.GetItems() </span><span class="cov8" title="1">{
                if !superSet.In(item) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (st *set[T]) IsProperSubsetOf(superSet Set[T]) bool <span class="cov8" title="1">{
        if st.Len() == superSet.Len() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return st.IsSubsetOf(superSet)</span>
}

func (st *set[T]) IsSupersetOf(subSet Set[T]) bool <span class="cov8" title="1">{
        return subSet.IsSubsetOf(st)
}</span>

func (st *set[T]) IsProperSupersetOf(subSet Set[T]) bool <span class="cov8" title="1">{
        if st.Len() == subSet.Len() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return st.IsSupersetOf(subSet)</span>
}

func (st *set[T]) Union(st2 Set[T]) Set[T] <span class="cov8" title="1">{
        unionSet := New[T]()
        for _, item := range st.GetItems() </span><span class="cov8" title="1">{
                unionSet.Add(item)
        }</span>
        <span class="cov8" title="1">for _, item := range st2.GetItems() </span><span class="cov8" title="1">{
                unionSet.Add(item)
        }</span>
        <span class="cov8" title="1">return unionSet</span>
}

func (st *set[T]) Intersection(st2 Set[T]) Set[T] <span class="cov8" title="1">{
        intersectionSet := New[T]()
        var minSet, maxSet Set[T]
        if st.Len() &gt; st2.Len() </span><span class="cov8" title="1">{
                minSet = st2
                maxSet = st
        }</span> else<span class="cov8" title="1"> {
                minSet = st
                maxSet = st2
        }</span>
        <span class="cov8" title="1">for _, item := range minSet.GetItems() </span><span class="cov8" title="1">{
                if maxSet.In(item) </span><span class="cov8" title="1">{
                        intersectionSet.Add(item)
                }</span>
        }
        <span class="cov8" title="1">return intersectionSet</span>
}

func (st *set[T]) Difference(st2 Set[T]) Set[T] <span class="cov8" title="1">{
        differenceSet := New[T]()
        for _, item := range st.GetItems() </span><span class="cov8" title="1">{
                if !st2.In(item) </span><span class="cov8" title="1">{
                        differenceSet.Add(item)
                }</span>
        }
        <span class="cov8" title="1">return differenceSet</span>
}

func (st *set[T]) SymmetricDifference(st2 Set[T]) Set[T] <span class="cov8" title="1">{
        symmetricDifferenceSet := New[T]()
        dropSet := New[T]()
        for _, item := range st.GetItems() </span><span class="cov8" title="1">{
                if st2.In(item) </span><span class="cov8" title="1">{
                        dropSet.Add(item)
                }</span> else<span class="cov8" title="1"> {
                        symmetricDifferenceSet.Add(item)
                }</span>
        }
        <span class="cov8" title="1">for _, item := range st2.GetItems() </span><span class="cov8" title="1">{
                if !dropSet.In(item) </span><span class="cov8" title="1">{
                        symmetricDifferenceSet.Add(item)
                }</span>
        }
        <span class="cov8" title="1">return symmetricDifferenceSet</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">// Stack Array
// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.
//        The order may be LIFO(Last In First Out) or FILO(First In Last Out).
// details:
//         Stack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/
//         Stack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see stacklinkedlist.go, stacklinkedlistwithlist.go, stack_test.go

package stack

type Array[T any] struct {
        elements []T
}

// NewStack creates and returns a new stack.
func NewStack[T any]() *Array[T] <span class="cov8" title="1">{
        return &amp;Array[T]{}
}</span>

// Push adds an element to the top of the stack.
func (s *Array[T]) Push(value T) <span class="cov8" title="1">{
        s.elements = append(s.elements, value)
}</span>

// Size returns the number of elements in the stack.
func (s *Array[T]) Length() int <span class="cov8" title="1">{
        return len(s.elements)
}</span>

// Peek returns the top element of the stack without removing it.
func (s *Array[T]) Peek() T <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov0" title="0">{
                var zeroValue T
                return zeroValue // Stack is empty
        }</span>
        <span class="cov8" title="1">return s.elements[len(s.elements)-1]</span>
}

// IsEmpty returns true if the stack is empty, false otherwise.
func (s *Array[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.elements) == 0
}</span>

// Pop removes and returns the top element from the stack.
func (s *Array[T]) Pop() T <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov0" title="0">{
                var zeroValue T
                return zeroValue // Stack is empty
        }</span>
        <span class="cov8" title="1">index := len(s.elements) - 1
        popped := s.elements[index]
        s.elements = s.elements[:index]
        return popped</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">// Stack Linked-List
// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.
//        The order may be LIFO(Last In First Out) or FILO(First In Last Out).
// details:
//         Stack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/
//         Stack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see stacklinkedlistwithlist.go, stackarray.go, stack_test.go

package stack

// Node structure
type Node struct {
        Val  any
        Next *Node
}

// Stack has jost top of node and with length
type Stack struct {
        top    *Node
        length int
}

// push add value to last index
func (ll *Stack) Push(n any) <span class="cov8" title="1">{
        newStack := &amp;Node{} // new node

        newStack.Val = n
        newStack.Next = ll.top

        ll.top = newStack
        ll.length++
}</span>

// pop remove last item as first output
func (ll *Stack) Pop() any <span class="cov8" title="1">{
        result := ll.top.Val
        if ll.top.Next == nil </span><span class="cov8" title="1">{
                ll.top = nil
        }</span> else<span class="cov8" title="1"> {
                ll.top.Val, ll.top.Next = ll.top.Next.Val, ll.top.Next.Next
        }</span>

        <span class="cov8" title="1">ll.length--
        return result</span>
}

// isEmpty to check our array is empty or not
func (ll *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return ll.length == 0
}</span>

// len use to return length of our stack
func (ll *Stack) Length() int <span class="cov8" title="1">{
        return ll.length
}</span>

// peak return last input value
func (ll *Stack) Peek() any <span class="cov8" title="1">{
        return ll.top.Val
}</span>

// show all value as an interface array
func (ll *Stack) Show() (in []any) <span class="cov8" title="1">{
        current := ll.top

        for current != nil </span><span class="cov8" title="1">{
                in = append(in, current.Val)
                current = current.Next
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file185" style="display: none">// Stack Linked-List with standard library (Container/List)
// description: based on `geeksforgeeks` description Stack is a linear data structure which follows a particular order in which the operations are performed.
//        The order may be LIFO(Last In First Out) or FILO(First In Last Out).
// details:
//         Stack Data Structure : https://www.geeksforgeeks.org/stack-data-structure-introduction-program/
//         Stack (abstract data type) : https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
// author [Milad](https://github.com/miraddo)
// see stacklinkedlist.go, stackarray.go, stack_test.go

package stack

import (
        "container/list"
        "fmt"
)

// SList is our struct that point to stack with container/list.List library
type SList struct {
        Stack *list.List
}

// Push add a value into our stack
func (sl *SList) Push(val any) <span class="cov8" title="1">{
        sl.Stack.PushFront(val)
}</span>

// Peak is return last value that insert into our stack
func (sl *SList) Peek() (any, error) <span class="cov8" title="1">{
        if !sl.IsEmpty() </span><span class="cov8" title="1">{
                element := sl.Stack.Front()
                return element.Value, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("stack list is empty")</span>
}

// Pop is return last value that insert into our stack
// also it will remove it in our stack
func (sl *SList) Pop() (any, error) <span class="cov8" title="1">{
        if !sl.IsEmpty() </span><span class="cov8" title="1">{
                // get last element that insert into stack
                element := sl.Stack.Front()
                // remove element in stack
                sl.Stack.Remove(element)
                // return element value
                return element.Value, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("stack list is empty")</span>
}

// Length return length of our stack
func (sl *SList) Length() int <span class="cov8" title="1">{
        return sl.Stack.Len()
}</span>

// Empty check our stack has value or not
func (sl *SList) IsEmpty() bool <span class="cov8" title="1">{
        // check our stack is empty or not
        // if is 0 it means our stack is empty otherwise is not empty
        return sl.Stack.Len() == 0
}</span>
</pre>
		
		<pre class="file" id="file186" style="display: none">// AVL tree is a self-balancing binary search tree.
//
// For more details check out those link below here:
// Wikipedia article: https://en.wikipedia.org/wiki/AVL_tree
// see avl.go

package tree

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/math/max"
)

// Verify Interface Compliance
var _ Node[int] = &amp;AVLNode[int]{}

// AVLNode represents a single node in the AVL.
type AVLNode[T constraints.Ordered] struct {
        key    T
        parent *AVLNode[T]
        left   *AVLNode[T]
        right  *AVLNode[T]
        height int
}

func (n *AVLNode[T]) Key() T <span class="cov8" title="1">{
        return n.key
}</span>

func (n *AVLNode[T]) Parent() Node[T] <span class="cov8" title="1">{
        return n.parent
}</span>

func (n *AVLNode[T]) Left() Node[T] <span class="cov8" title="1">{
        return n.left
}</span>

func (n *AVLNode[T]) Right() Node[T] <span class="cov8" title="1">{
        return n.right
}</span>

func (n *AVLNode[T]) Height() int <span class="cov8" title="1">{
        return n.height
}</span>

// AVL represents a AVL tree.
// By default, _NIL = nil.
type AVL[T constraints.Ordered] struct {
        Root *AVLNode[T]
        _NIL *AVLNode[T] // a sentinel value for nil
}

// NewAVL creates a novel AVL tree
func NewAVL[T constraints.Ordered]() *AVL[T] <span class="cov8" title="1">{
        return &amp;AVL[T]{
                Root: nil,
                _NIL: nil,
        }
}</span>

// Empty determines the AVL tree is empty
func (avl *AVL[T]) Empty() bool <span class="cov8" title="1">{
        return avl.Root == avl._NIL
}</span>

// Push a chain of Node's into the AVL Tree
func (avl *AVL[T]) Push(keys ...T) <span class="cov8" title="1">{
        for _, k := range keys </span><span class="cov8" title="1">{
                avl.Root = avl.pushHelper(avl.Root, k)
        }</span>
}

// Delete a Node from the AVL Tree
func (avl *AVL[T]) Delete(key T) bool <span class="cov8" title="1">{
        if !avl.Has(key) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">avl.Root = avl.deleteHelper(avl.Root, key)
        return true</span>
}

// Get a Node from the AVL Tree
func (avl *AVL[T]) Get(key T) (Node[T], bool) <span class="cov8" title="1">{
        return searchTreeHelper[T](avl.Root, avl._NIL, key)
}</span>

// Has Determines the tree has the node of Key
func (avl *AVL[T]) Has(key T) bool <span class="cov8" title="1">{
        _, ok := searchTreeHelper[T](avl.Root, avl._NIL, key)
        return ok
}</span>

// PreOrder Traverses the tree in the following order Root --&gt; Left --&gt; Right
func (avl *AVL[T]) PreOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        preOrderRecursive[T](avl.Root, avl._NIL, &amp;traversal)
        return traversal
}</span>

// InOrder Traverses the tree in the following order Left --&gt; Root --&gt; Right
func (avl *AVL[T]) InOrder() []T <span class="cov8" title="1">{
        return inOrderHelper[T](avl.Root, avl._NIL)
}</span>

// PostOrder traverses the tree in the following order Left --&gt; Right --&gt; Root
func (avl *AVL[T]) PostOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        postOrderRecursive[T](avl.Root, avl._NIL, &amp;traversal)
        return traversal
}</span>

// LevelOrder returns the level order traversal of the tree
func (avl *AVL[T]) LevelOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        levelOrderHelper[T](avl.Root, avl._NIL, &amp;traversal)
        return traversal
}</span>

// AccessNodesByLayer accesses nodes layer by layer (2-D array),  instead of printing the results as 1-D array.
func (avl *AVL[T]) AccessNodesByLayer() [][]T <span class="cov8" title="1">{
        return accessNodeByLayerHelper[T](avl.Root, avl._NIL)
}</span>

// Depth returns the calculated depth of the AVL tree
func (avl *AVL[T]) Depth() int <span class="cov8" title="1">{
        return calculateDepth[T](avl.Root, avl._NIL, 0)
}</span>

// Max returns the Max value of the tree
func (avl *AVL[T]) Max() (T, bool) <span class="cov8" title="1">{
        ret := maximum[T](avl.Root, avl._NIL)
        if ret == avl._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Min returns the Min value of the tree
func (avl *AVL[T]) Min() (T, bool) <span class="cov8" title="1">{
        ret := minimum[T](avl.Root, avl._NIL)
        if ret == avl._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Predecessor returns the Predecessor of the node of Key
// if there is no predecessor, return default value of type T and false
// otherwise return the Key of predecessor and true
func (avl *AVL[T]) Predecessor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](avl.Root, avl._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return predecessorHelper[T](node, avl._NIL)</span>
}

// Successor returns the Successor of the node of Key
// if there is no successor, return default value of type T and false
// otherwise return the Key of successor and true
func (avl *AVL[T]) Successor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](avl.Root, avl._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return successorHelper[T](node, avl._NIL)</span>
}

func (avl *AVL[T]) pushHelper(root *AVLNode[T], key T) *AVLNode[T] <span class="cov8" title="1">{
        if root == avl._NIL </span><span class="cov8" title="1">{
                return &amp;AVLNode[T]{
                        key:    key,
                        left:   avl._NIL,
                        right:  avl._NIL,
                        parent: avl._NIL,
                        height: 1,
                }
        }</span>

        <span class="cov8" title="1">switch </span>{
        case key &lt; root.key:<span class="cov8" title="1">
                tmp := avl.pushHelper(root.left, key)
                tmp.parent = root
                root.left = tmp</span>
        case key &gt; root.key:<span class="cov8" title="1">
                tmp := avl.pushHelper(root.right, key)
                tmp.parent = root
                root.right = tmp</span>
        default:<span class="cov8" title="1">
                return root</span>
        }

        // balance the tree
        <span class="cov8" title="1">root.height = avl.height(root)
        bFactor := avl.balanceFactor(root)
        if bFactor &gt; 1 </span><span class="cov8" title="1">{
                switch </span>{
                case key &lt; root.left.key:<span class="cov8" title="1">
                        return avl.rightRotate(root)</span>
                case key &gt; root.left.key:<span class="cov8" title="1">
                        root.left = avl.leftRotate(root.left)
                        return avl.rightRotate(root)</span>
                }
        }

        <span class="cov8" title="1">if bFactor &lt; -1 </span><span class="cov8" title="1">{
                switch </span>{
                case key &gt; root.right.key:<span class="cov8" title="1">
                        return avl.leftRotate(root)</span>
                case key &lt; root.right.key:<span class="cov8" title="1">
                        root.right = avl.rightRotate(root.right)
                        return avl.leftRotate(root)</span>
                }
        }

        <span class="cov8" title="1">return root</span>
}

func (avl *AVL[T]) deleteHelper(root *AVLNode[T], key T) *AVLNode[T] <span class="cov8" title="1">{
        if root == avl._NIL </span><span class="cov0" title="0">{
                return root
        }</span>

        <span class="cov8" title="1">switch </span>{
        case key &lt; root.key:<span class="cov8" title="1">
                tmp := avl.deleteHelper(root.left, key)
                root.left = tmp
                if tmp != avl._NIL </span><span class="cov8" title="1">{
                        tmp.parent = root
                }</span>
        case key &gt; root.key:<span class="cov8" title="1">
                tmp := avl.deleteHelper(root.right, key)
                root.right = tmp
                if tmp != avl._NIL </span><span class="cov8" title="1">{
                        tmp.parent = root
                }</span>
        default:<span class="cov8" title="1">
                if root.left == avl._NIL || root.right == avl._NIL </span><span class="cov8" title="1">{
                        tmp := root.left
                        if root.right != avl._NIL </span><span class="cov8" title="1">{
                                tmp = root.right
                        }</span>

                        <span class="cov8" title="1">if tmp == avl._NIL </span><span class="cov8" title="1">{
                                root = avl._NIL
                        }</span> else<span class="cov8" title="1"> {
                                tmp.parent = root.parent
                                root = tmp
                        }</span>
                } else<span class="cov8" title="1"> {
                        tmp := minimum[T](root.right, avl._NIL).(*AVLNode[T])
                        root.key = tmp.key
                        del := avl.deleteHelper(root.right, tmp.key)
                        root.right = del
                        if del != avl._NIL </span><span class="cov8" title="1">{
                                del.parent = root
                        }</span>
                }
        }

        <span class="cov8" title="1">if root == avl._NIL </span><span class="cov8" title="1">{
                return root
        }</span>

        // balance the tree
        <span class="cov8" title="1">root.height = avl.height(root)
        bFactor := avl.balanceFactor(root)
        switch </span>{
        case bFactor &gt; 1:<span class="cov8" title="1">
                switch </span>{
                case avl.balanceFactor(root.left) &gt;= 0:<span class="cov8" title="1">
                        return avl.rightRotate(root)</span>
                default:<span class="cov8" title="1">
                        root.left = avl.leftRotate(root.left)
                        return avl.rightRotate(root)</span>
                }
        case bFactor &lt; -1:<span class="cov8" title="1">
                switch </span>{
                case avl.balanceFactor(root.right) &lt;= 0:<span class="cov8" title="1">
                        return avl.leftRotate(root)</span>
                default:<span class="cov8" title="1">
                        root.right = avl.rightRotate(root.right)
                        return avl.leftRotate(root)</span>
                }
        }

        <span class="cov8" title="1">return root</span>
}

func (avl *AVL[T]) height(root *AVLNode[T]) int <span class="cov8" title="1">{
        if root == avl._NIL </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov8" title="1">var leftHeight, rightHeight int
        if root.left != avl._NIL </span><span class="cov8" title="1">{
                leftHeight = root.left.height
        }</span>
        <span class="cov8" title="1">if root.right != avl._NIL </span><span class="cov8" title="1">{
                rightHeight = root.right.height
        }</span>
        <span class="cov8" title="1">return 1 + max.Int(leftHeight, rightHeight)</span>
}

// balanceFactor : negative balance factor means subtree Root is heavy toward Left
// and positive balance factor means subtree Root is heavy toward Right side
func (avl *AVL[T]) balanceFactor(root *AVLNode[T]) int <span class="cov8" title="1">{
        var leftHeight, rightHeight int
        if root.left != avl._NIL </span><span class="cov8" title="1">{
                leftHeight = root.left.height
        }</span>
        <span class="cov8" title="1">if root.right != avl._NIL </span><span class="cov8" title="1">{
                rightHeight = root.right.height
        }</span>
        <span class="cov8" title="1">return leftHeight - rightHeight</span>
}

func (avl *AVL[T]) leftRotate(x *AVLNode[T]) *AVLNode[T] <span class="cov8" title="1">{
        y := x.right
        yl := y.left
        y.left = x
        x.right = yl

        if yl != avl._NIL </span><span class="cov8" title="1">{
                yl.parent = x
        }</span>

        <span class="cov8" title="1">y.parent = x.parent
        x.parent = y

        x.height = avl.height(x)
        y.height = avl.height(y)
        return y</span>
}

func (avl *AVL[T]) rightRotate(x *AVLNode[T]) *AVLNode[T] <span class="cov8" title="1">{
        y := x.left
        yr := y.right
        y.right = x
        x.left = yr

        if yr != avl._NIL </span><span class="cov8" title="1">{
                yr.parent = x
        }</span>

        <span class="cov8" title="1">y.parent = x.parent
        x.parent = y

        x.height = avl.height(x)
        y.height = avl.height(y)
        return y</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">// Binary search tree.
//
// For more details check out those links below here:
// Wikipedia article: https://en.wikipedia.org/wiki/Binary_search_tree
// see bstree.go

package tree

import "github.com/TheAlgorithms/Go/constraints"

// Verify Interface Compliance
var _ Node[int] = &amp;BSNode[int]{}

// BSNode represents a single node in the BinarySearch.
type BSNode[T constraints.Ordered] struct {
        key    T
        parent *BSNode[T]
        left   *BSNode[T]
        right  *BSNode[T]
}

func (n *BSNode[T]) Key() T <span class="cov8" title="1">{
        return n.key
}</span>

func (n *BSNode[T]) Parent() Node[T] <span class="cov8" title="1">{
        return n.parent
}</span>

func (n *BSNode[T]) Left() Node[T] <span class="cov8" title="1">{
        return n.left
}</span>

func (n *BSNode[T]) Right() Node[T] <span class="cov8" title="1">{
        return n.right
}</span>

// BinarySearch represents a Binary-Search tree.
// By default, _NIL = nil.
type BinarySearch[T constraints.Ordered] struct {
        Root *BSNode[T]
        _NIL *BSNode[T] // a sentinel value for nil
}

// NewBinarySearch creates a novel Binary-Search tree
func NewBinarySearch[T constraints.Ordered]() *BinarySearch[T] <span class="cov8" title="1">{
        return &amp;BinarySearch[T]{
                Root: nil,
                _NIL: nil,
        }
}</span>

// Empty determines the Binary-Search tree is empty
func (t *BinarySearch[T]) Empty() bool <span class="cov8" title="1">{
        return t.Root == t._NIL
}</span>

// Push a chain of Node's into the BinarySearch
func (t *BinarySearch[T]) Push(keys ...T) <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                t.pushHelper(t.Root, key)
        }</span>
}

// Delete removes the node of val
func (t *BinarySearch[T]) Delete(val T) bool <span class="cov8" title="1">{
        node, ok := t.Get(val)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">t.deleteHelper(node.(*BSNode[T]))
        return true</span>
}

// Get a Node from the Binary-Search Tree
func (t *BinarySearch[T]) Get(key T) (Node[T], bool) <span class="cov8" title="1">{
        return searchTreeHelper[T](t.Root, t._NIL, key)
}</span>

// Has Determines the tree has the node of Key
func (t *BinarySearch[T]) Has(key T) bool <span class="cov8" title="1">{
        _, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        return ok
}</span>

// PreOrder Traverses the tree in the following order Root --&gt; Left --&gt; Right
func (t *BinarySearch[T]) PreOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        preOrderRecursive[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// InOrder Traverses the tree in the following order Left --&gt; Root --&gt; Right
func (t *BinarySearch[T]) InOrder() []T <span class="cov8" title="1">{
        return inOrderHelper[T](t.Root, t._NIL)
}</span>

// PostOrder traverses the tree in the following order Left --&gt; Right --&gt; Root
func (t *BinarySearch[T]) PostOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        postOrderRecursive[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// LevelOrder returns the level order traversal of the tree
func (t *BinarySearch[T]) LevelOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        levelOrderHelper[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// AccessNodesByLayer accesses nodes layer by layer (2-D array),  instead of printing the results as 1-D array.
func (t *BinarySearch[T]) AccessNodesByLayer() [][]T <span class="cov8" title="1">{
        return accessNodeByLayerHelper[T](t.Root, t._NIL)
}</span>

// Depth returns the calculated depth of a binary search tree
func (t *BinarySearch[T]) Depth() int <span class="cov8" title="1">{
        return calculateDepth[T](t.Root, t._NIL, 0)
}</span>

// Max returns the Max value of the tree
func (t *BinarySearch[T]) Max() (T, bool) <span class="cov8" title="1">{
        ret := maximum[T](t.Root, t._NIL)
        if ret == t._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Min returns the Min value of the tree
func (t *BinarySearch[T]) Min() (T, bool) <span class="cov8" title="1">{
        ret := minimum[T](t.Root, t._NIL)
        if ret == t._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Predecessor returns the Predecessor of the node of Key
// if there is no predecessor, return default value of type T and false
// otherwise return the Key of predecessor and true
func (t *BinarySearch[T]) Predecessor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return predecessorHelper[T](node, t._NIL)</span>
}

// Successor returns the Successor of the node of Key
// if there is no successor, return default value of type T and false
// otherwise return the Key of successor and true
func (t *BinarySearch[T]) Successor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return successorHelper[T](node, t._NIL)</span>
}

func (t *BinarySearch[T]) pushHelper(x *BSNode[T], val T) <span class="cov8" title="1">{
        y := t._NIL
        for x != t._NIL </span><span class="cov8" title="1">{
                y = x
                switch </span>{
                case val &lt; x.Key():<span class="cov8" title="1">
                        x = x.left</span>
                case val &gt; x.Key():<span class="cov8" title="1">
                        x = x.right</span>
                default:<span class="cov8" title="1">
                        return</span>
                }
        }

        <span class="cov8" title="1">z := &amp;BSNode[T]{
                key:    val,
                left:   t._NIL,
                right:  t._NIL,
                parent: y,
        }
        if y == t._NIL </span><span class="cov8" title="1">{
                t.Root = z
        }</span> else<span class="cov8" title="1"> if val &lt; y.key </span><span class="cov8" title="1">{
                y.left = z
        }</span> else<span class="cov8" title="1"> {
                y.right = z
        }</span>
}

func (t *BinarySearch[T]) deleteHelper(z *BSNode[T]) <span class="cov8" title="1">{
        switch </span>{
        case z.left == t._NIL:<span class="cov8" title="1">
                t.transplant(z, z.right)</span>
        case z.right == t._NIL:<span class="cov8" title="1">
                t.transplant(z, z.left)</span>
        default:<span class="cov8" title="1">
                y := minimum[T](z.right, t._NIL).(*BSNode[T])
                if y.parent != z </span><span class="cov8" title="1">{
                        t.transplant(y, y.right)
                        y.right = z.right
                        y.right.parent = y
                }</span>

                <span class="cov8" title="1">t.transplant(z, y)
                y.left = z.left
                y.left.parent = y</span>
        }
}

func (t *BinarySearch[T]) transplant(u, v *BSNode[T]) <span class="cov8" title="1">{
        switch </span>{
        case u.parent == t._NIL:<span class="cov8" title="1">
                t.Root = v</span>
        case u == u.parent.left:<span class="cov8" title="1">
                u.parent.left = v</span>
        default:<span class="cov8" title="1">
                u.parent.right = v</span>
        }

        <span class="cov8" title="1">if v != t._NIL </span><span class="cov8" title="1">{
                v.parent = u.parent
        }</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">// Red-Black Tree is a kind of self-balancing binary search tree.
// Each node stores "color" ("red" or "black"), used to ensure that the tree remains balanced during insertions and deletions.
//
// For more details check out those links below here:
// Programiz article : https://www.programiz.com/dsa/red-black-tree
// Wikipedia article: https://en.wikipedia.org/wiki/Red_black_tree
// authors [guuzaa](https://github.com/guuzaa)
// see rbtree.go

package tree

import "github.com/TheAlgorithms/Go/constraints"

type Color byte

const (
        Red Color = iota
        Black
)

// Verify Interface Compliance
var _ Node[int] = &amp;RBNode[int]{}

// RBNode represents a single node in the RB.
type RBNode[T constraints.Ordered] struct {
        key    T
        parent *RBNode[T]
        left   *RBNode[T]
        right  *RBNode[T]
        color  Color
}

func (n *RBNode[T]) Key() T <span class="cov8" title="1">{
        return n.key
}</span>

func (n *RBNode[T]) Parent() Node[T] <span class="cov8" title="1">{
        return n.parent
}</span>

func (n *RBNode[T]) Left() Node[T] <span class="cov8" title="1">{
        return n.left
}</span>

func (n *RBNode[T]) Right() Node[T] <span class="cov8" title="1">{
        return n.right
}</span>

// RB represents a Red-Black tree.
// By default, _NIL = leaf, a dummy variable.
type RB[T constraints.Ordered] struct {
        Root *RBNode[T]
        _NIL *RBNode[T] // a sentinel value for nil
}

// NewRB creates a new Red-Black Tree
func NewRB[T constraints.Ordered]() *RB[T] <span class="cov8" title="1">{
        leaf := &amp;RBNode[T]{color: Black, left: nil, right: nil}
        leaf.parent = leaf
        return &amp;RB[T]{
                Root: leaf,
                _NIL: leaf,
        }
}</span>

// Empty determines the Red-Black tree is empty
func (t *RB[T]) Empty() bool <span class="cov8" title="1">{
        return t.Root == t._NIL
}</span>

// Push a chain of Node's into the Red-Black Tree
func (t *RB[T]) Push(keys ...T) <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                t.pushHelper(t.Root, key)
        }</span>
}

// Delete a node of Red-Black Tree
// Returns false if the node does not exist, otherwise returns true.
func (t *RB[T]) Delete(data T) bool <span class="cov8" title="1">{
        return t.deleteHelper(t.Root, data)
}</span>

// Get a Node from the Red-Black Tree
func (t *RB[T]) Get(key T) (Node[T], bool) <span class="cov8" title="1">{
        return searchTreeHelper[T](t.Root, t._NIL, key)
}</span>

// Has Determines the tree has the node of Key
func (t *RB[T]) Has(key T) bool <span class="cov8" title="1">{
        _, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        return ok
}</span>

// PreOrder Traverses the tree in the following order Root --&gt; Left --&gt; Right
func (t *RB[T]) PreOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        preOrderRecursive[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// InOrder Traverses the tree in the following order Left --&gt; Root --&gt; Right
func (t *RB[T]) InOrder() []T <span class="cov8" title="1">{
        return inOrderHelper[T](t.Root, t._NIL)
}</span>

// PostOrder traverses the tree in the following order Left --&gt; Right --&gt; Root
func (t *RB[T]) PostOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        postOrderRecursive[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// LevelOrder returns the level order traversal of the tree
func (t *RB[T]) LevelOrder() []T <span class="cov8" title="1">{
        traversal := make([]T, 0)
        levelOrderHelper[T](t.Root, t._NIL, &amp;traversal)
        return traversal
}</span>

// AccessNodesByLayer accesses nodes layer by layer (2-D array),  instead of printing the results as 1-D array.
func (t *RB[T]) AccessNodesByLayer() [][]T <span class="cov8" title="1">{
        return accessNodeByLayerHelper[T](t.Root, t._NIL)
}</span>

// Depth returns the calculated depth of a Red-Black tree
func (t *RB[T]) Depth() int <span class="cov8" title="1">{
        return calculateDepth[T](t.Root, t._NIL, 0)
}</span>

// Max returns the Max value of the tree
func (t *RB[T]) Max() (T, bool) <span class="cov8" title="1">{
        ret := maximum[T](t.Root, t._NIL)
        if ret == t._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Min returns the Min value of the tree
func (t *RB[T]) Min() (T, bool) <span class="cov8" title="1">{
        ret := minimum[T](t.Root, t._NIL)
        if ret == t._NIL </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return ret.Key(), true</span>
}

// Predecessor returns the Predecessor of the node of Key
// if there is no predecessor, return default value of type T and false
// otherwise return the Key of predecessor and true
func (t *RB[T]) Predecessor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return predecessorHelper[T](node, t._NIL)</span>
}

// Successor returns the Successor of the node of Key
// if there is no successor, return default value of type T and false
// otherwise return the Key of successor and true
func (t *RB[T]) Successor(key T) (T, bool) <span class="cov8" title="1">{
        node, ok := searchTreeHelper[T](t.Root, t._NIL, key)
        if !ok </span><span class="cov8" title="1">{
                var dft T
                return dft, ok
        }</span>
        <span class="cov8" title="1">return successorHelper[T](node, t._NIL)</span>
}

func (t *RB[T]) pushHelper(x *RBNode[T], key T) <span class="cov8" title="1">{
        y := t._NIL
        for x != t._NIL </span><span class="cov8" title="1">{
                y = x
                switch </span>{
                case key &lt; x.Key():<span class="cov8" title="1">
                        x = x.left</span>
                case key &gt; x.Key():<span class="cov8" title="1">
                        x = x.right</span>
                default:<span class="cov8" title="1">
                        return</span>
                }
        }

        <span class="cov8" title="1">node := &amp;RBNode[T]{
                key:    key,
                left:   t._NIL,
                right:  t._NIL,
                parent: y,
                color:  Red,
        }
        if y == t._NIL </span><span class="cov8" title="1">{
                t.Root = node
        }</span> else<span class="cov8" title="1"> if node.key &lt; y.key </span><span class="cov8" title="1">{
                y.left = node
        }</span> else<span class="cov8" title="1"> {
                y.right = node
        }</span>

        <span class="cov8" title="1">if node.parent == t._NIL </span><span class="cov8" title="1">{
                node.color = Black
                return
        }</span>

        <span class="cov8" title="1">if node.parent.parent == t._NIL </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">t.pushFix(node)</span>
}

func (t *RB[T]) leftRotate(x *RBNode[T]) <span class="cov8" title="1">{
        y := x.right
        x.right = y.left

        if y.left != t._NIL </span><span class="cov8" title="1">{
                y.left.parent = x
        }</span>

        <span class="cov8" title="1">y.parent = x.parent
        if x.parent == t._NIL </span><span class="cov8" title="1">{
                t.Root = y
        }</span> else<span class="cov8" title="1"> if x == x.parent.left </span><span class="cov8" title="1">{
                x.parent.left = y
        }</span> else<span class="cov8" title="1"> {
                x.parent.right = y
        }</span>

        <span class="cov8" title="1">y.left = x
        x.parent = y</span>
}

func (t *RB[T]) rightRotate(x *RBNode[T]) <span class="cov8" title="1">{
        y := x.left
        x.left = y.right
        if y.right != t._NIL </span><span class="cov8" title="1">{
                y.right.parent = x
        }</span>

        <span class="cov8" title="1">y.parent = x.parent
        if x.parent == t._NIL </span><span class="cov8" title="1">{
                t.Root = y
        }</span> else<span class="cov8" title="1"> if x == y.parent.right </span><span class="cov8" title="1">{
                y.parent.right = y
        }</span> else<span class="cov8" title="1"> {
                y.parent.left = y
        }</span>

        <span class="cov8" title="1">y.right = x
        x.parent = y</span>
}

func (t *RB[T]) pushFix(k *RBNode[T]) <span class="cov8" title="1">{
        for k.parent.color == Red </span><span class="cov8" title="1">{
                if k.parent == k.parent.parent.right </span><span class="cov8" title="1">{
                        u := k.parent.parent.left
                        if u.color == Red </span><span class="cov8" title="1">{
                                u.color = Black
                                k.parent.color = Black
                                k.parent.parent.color = Red
                                k = k.parent.parent
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.parent.left </span><span class="cov8" title="1">{
                                        k = k.parent
                                        t.rightRotate(k)
                                }</span>
                                <span class="cov8" title="1">k.parent.color = Black
                                k.parent.parent.color = Red
                                t.leftRotate(k.parent.parent)</span>
                        }
                } else<span class="cov8" title="1"> {
                        u := k.parent.parent.right
                        if u.color == Red </span><span class="cov8" title="1">{
                                u.color = Black
                                k.parent.color = Black
                                k.parent.parent.color = Red
                                k = k.parent.parent
                        }</span> else<span class="cov8" title="1"> {
                                if k == k.parent.right </span><span class="cov8" title="1">{
                                        k = k.parent
                                        t.leftRotate(k)
                                }</span>
                                <span class="cov8" title="1">k.parent.color = Black
                                k.parent.parent.color = Red
                                t.rightRotate(k.parent.parent)</span>
                        }
                }
                <span class="cov8" title="1">if k == t.Root </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">t.Root.color = Black</span>
}

func (t *RB[T]) deleteHelper(node *RBNode[T], key T) bool <span class="cov8" title="1">{
        z := t._NIL
        for node != t._NIL </span><span class="cov8" title="1">{
                switch </span>{
                case node.key == key:<span class="cov8" title="1">
                        z = node
                        fallthrough</span>
                case node.key &lt;= key:<span class="cov8" title="1">
                        node = node.right</span>
                case node.key &gt; key:<span class="cov8" title="1">
                        node = node.left</span>
                }
        }

        <span class="cov8" title="1">if z == t._NIL </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var x *RBNode[T]
        y := z
        yOriginColor := y.color
        if z.left == t._NIL </span><span class="cov8" title="1">{
                x = z.right
                t.transplant(z, z.right)
        }</span> else<span class="cov8" title="1"> if z.right == t._NIL </span><span class="cov8" title="1">{
                x = z.left
                t.transplant(z, z.left)
        }</span> else<span class="cov8" title="1"> {
                y = minimum[T](z.right, t._NIL).(*RBNode[T])
                yOriginColor = y.color
                x = y.right
                if y.parent == z </span><span class="cov8" title="1">{
                        x.parent = y
                }</span> else<span class="cov8" title="1"> {
                        t.transplant(y, y.right)
                        y.right = z.right
                        y.right.parent = y
                }</span>

                <span class="cov8" title="1">t.transplant(z, y)
                y.left = z.left
                y.left.parent = y
                y.color = z.color</span>
        }

        <span class="cov8" title="1">if yOriginColor == Black </span><span class="cov8" title="1">{
                t.deleteFix(x)
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (t *RB[T]) deleteFix(x *RBNode[T]) <span class="cov8" title="1">{
        var s *RBNode[T]
        for x != t.Root &amp;&amp; x.color == Black </span><span class="cov8" title="1">{
                if x == x.parent.left </span><span class="cov8" title="1">{
                        s = x.parent.right
                        if s.color == Red </span><span class="cov8" title="1">{
                                s.color = Black
                                x.parent.color = Red
                                t.leftRotate(x.parent)
                                s = x.parent.right
                        }</span>

                        <span class="cov8" title="1">if s.left.color == Black &amp;&amp; s.right.color == Black </span><span class="cov8" title="1">{
                                s.color = Red
                                x = x.parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.right.color == Black </span><span class="cov8" title="1">{
                                        s.left.color = Black
                                        s.color = Red
                                        t.rightRotate(s)
                                        s = x.parent.right
                                }</span>

                                <span class="cov8" title="1">s.color = x.parent.color
                                x.parent.color = Black
                                s.right.color = Black
                                t.leftRotate(x.parent)
                                x = t.Root</span>
                        }
                } else<span class="cov8" title="1"> {
                        s = x.parent.left
                        if s.color == Red </span><span class="cov8" title="1">{
                                s.color = Black
                                x.parent.color = Red
                                t.rightRotate(x.parent)
                                s = x.parent.left
                        }</span>

                        <span class="cov8" title="1">if s.right.color == Black &amp;&amp; s.left.color == Black </span><span class="cov8" title="1">{
                                s.color = Red
                                x = x.parent
                        }</span> else<span class="cov8" title="1"> {
                                if s.left.color == Black </span><span class="cov8" title="1">{
                                        s.right.color = Black
                                        s.color = Red
                                        t.leftRotate(s)
                                        s = x.parent.left
                                }</span>

                                <span class="cov8" title="1">s.color = x.parent.color
                                x.parent.color = Black
                                s.left.color = Black
                                t.rightRotate(x.parent)
                                x = t.Root</span>
                        }
                }
        }

        <span class="cov8" title="1">x.color = Black</span>
}

func (t *RB[T]) transplant(u, v *RBNode[T]) <span class="cov8" title="1">{
        switch </span>{
        case u.parent == t._NIL:<span class="cov8" title="1">
                t.Root = v</span>
        case u == u.parent.left:<span class="cov8" title="1">
                u.parent.left = v</span>
        default:<span class="cov8" title="1">
                u.parent.right = v</span>
        }

        <span class="cov8" title="1">v.parent = u.parent</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">// Binary-Search tree is the tree, with the key of each internal node
// being greater than keys in the respective node's left subtree
// and less than the ones in its right subtree.

// For more details check out those links below here:
// Wikipedia article: https://en.wikipedia.org/wiki/Binary_search_tree
// authors [guuzaa](https://github.com/guuzaa)
package tree

import (
        "github.com/TheAlgorithms/Go/constraints"
        "github.com/TheAlgorithms/Go/math/max"
)

type Node[T constraints.Ordered] interface {
        Key() T
        Parent() Node[T]
        Left() Node[T]
        Right() Node[T]
}

// The following is a collection of helper functions for BinarySearch, AVL and RB.

func accessNodeByLayerHelper[T constraints.Ordered](root, nilNode Node[T]) [][]T <span class="cov8" title="1">{
        if root == nilNode </span><span class="cov8" title="1">{
                return [][]T{}
        }</span>
        <span class="cov8" title="1">var q []Node[T]
        var n Node[T]
        var idx = 0
        q = append(q, root)
        var res [][]T

        for len(q) != 0 </span><span class="cov8" title="1">{
                res = append(res, []T{})
                qLen := len(q)
                for i := 0; i &lt; qLen; i++ </span><span class="cov8" title="1">{
                        n, q = q[0], q[1:]
                        res[idx] = append(res[idx], n.Key())
                        if n.Left() != nilNode </span><span class="cov8" title="1">{
                                q = append(q, n.Left())
                        }</span>
                        <span class="cov8" title="1">if n.Right() != nilNode </span><span class="cov8" title="1">{
                                q = append(q, n.Right())
                        }</span>
                }
                <span class="cov8" title="1">idx++</span>
        }
        <span class="cov8" title="1">return res</span>
}

func searchTreeHelper[T constraints.Ordered](node, nilNode Node[T], key T) (Node[T], bool) <span class="cov8" title="1">{
        if node == nilNode </span><span class="cov8" title="1">{
                return node, false
        }</span>

        <span class="cov8" title="1">if key == node.Key() </span><span class="cov8" title="1">{
                return node, true
        }</span>
        <span class="cov8" title="1">if key &lt; node.Key() </span><span class="cov8" title="1">{
                return searchTreeHelper(node.Left(), nilNode, key)
        }</span>
        <span class="cov8" title="1">return searchTreeHelper(node.Right(), nilNode, key)</span>
}

func inOrderHelper[T constraints.Ordered](node, nilNode Node[T]) []T <span class="cov8" title="1">{
        var stack []Node[T]
        var ret []T

        for node != nilNode || len(stack) &gt; 0 </span><span class="cov8" title="1">{
                for node != nilNode </span><span class="cov8" title="1">{
                        stack = append(stack, node)
                        node = node.Left()
                }</span>

                <span class="cov8" title="1">node = stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                ret = append(ret, node.Key())
                node = node.Right()</span>
        }

        <span class="cov8" title="1">return ret</span>
}

func preOrderRecursive[T constraints.Ordered](n, nilNode Node[T], traversal *[]T) <span class="cov8" title="1">{
        if n == nilNode </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">*traversal = append(*traversal, n.Key())
        preOrderRecursive(n.Left(), nilNode, traversal)
        preOrderRecursive(n.Right(), nilNode, traversal)</span>

}

func postOrderRecursive[T constraints.Ordered](n, nilNode Node[T], traversal *[]T) <span class="cov8" title="1">{
        if n == nilNode </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">postOrderRecursive(n.Left(), nilNode, traversal)
        postOrderRecursive(n.Right(), nilNode, traversal)
        *traversal = append(*traversal, n.Key())</span>
}

func calculateDepth[T constraints.Ordered](n, nilNode Node[T], depth int) int <span class="cov8" title="1">{
        if n == nilNode </span><span class="cov8" title="1">{
                return depth
        }</span>

        <span class="cov8" title="1">return max.Int(calculateDepth(n.Left(), nilNode, depth+1), calculateDepth(n.Right(), nilNode, depth+1))</span>
}

func minimum[T constraints.Ordered](node, nilNode Node[T]) Node[T] <span class="cov8" title="1">{
        if node == nilNode </span><span class="cov8" title="1">{
                return node
        }</span>

        <span class="cov8" title="1">for node.Left() != nilNode </span><span class="cov8" title="1">{
                node = node.Left()
        }</span>
        <span class="cov8" title="1">return node</span>
}

func maximum[T constraints.Ordered](node, nilNode Node[T]) Node[T] <span class="cov8" title="1">{
        if node == nilNode </span><span class="cov8" title="1">{
                return node
        }</span>

        <span class="cov8" title="1">for node.Right() != nilNode </span><span class="cov8" title="1">{
                node = node.Right()
        }</span>
        <span class="cov8" title="1">return node</span>
}

func levelOrderHelper[T constraints.Ordered](root, nilNode Node[T], traversal *[]T) <span class="cov8" title="1">{
        var q []Node[T] // queue
        var tmp Node[T]

        q = append(q, root)

        for len(q) != 0 </span><span class="cov8" title="1">{
                tmp, q = q[0], q[1:]
                *traversal = append(*traversal, tmp.Key())
                if tmp.Left() != nilNode </span><span class="cov8" title="1">{
                        q = append(q, tmp.Left())
                }</span>

                <span class="cov8" title="1">if tmp.Right() != nilNode </span><span class="cov8" title="1">{
                        q = append(q, tmp.Right())
                }</span>
        }
}

func predecessorHelper[T constraints.Ordered](node, nilNode Node[T]) (T, bool) <span class="cov8" title="1">{
        if node.Left() != nilNode </span><span class="cov8" title="1">{
                return maximum(node.Left(), nilNode).Key(), true
        }</span>

        <span class="cov8" title="1">p := node.Parent()
        for p != nilNode &amp;&amp; node == p.Left() </span><span class="cov8" title="1">{
                node = p
                p = p.Parent()
        }</span>

        <span class="cov8" title="1">if p == nilNode </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return p.Key(), true</span>
}

func successorHelper[T constraints.Ordered](node, nilNode Node[T]) (T, bool) <span class="cov8" title="1">{
        if node.Right() != nilNode </span><span class="cov8" title="1">{
                return minimum(node.Right(), nilNode).Key(), true
        }</span>

        <span class="cov8" title="1">p := node.Parent()
        for p != nilNode &amp;&amp; node == p.Right() </span><span class="cov8" title="1">{
                node = p
                p = p.Parent()
        }</span>

        <span class="cov8" title="1">if p == nilNode </span><span class="cov8" title="1">{
                var dft T
                return dft, false
        }</span>
        <span class="cov8" title="1">return p.Key(), true</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">// Package trie provides Trie data structures in golang.
//
// Wikipedia: https://en.wikipedia.org/wiki/Trie
package trie

// Node represents each node in Trie.
type Node struct {
        children map[rune]*Node // map children nodes
        isLeaf   bool           // current node value
}

// NewNode creates a new Trie node with initialized
// children map.
func NewNode() *Node <span class="cov8" title="1">{
        n := &amp;Node{}
        n.children = make(map[rune]*Node)
        n.isLeaf = false
        return n
}</span>

// insert a single word at a Trie node.
func (n *Node) insert(s string) <span class="cov8" title="1">{
        curr := n
        for _, c := range s </span><span class="cov8" title="1">{
                next, ok := curr.children[c]
                if !ok </span><span class="cov8" title="1">{
                        next = NewNode()
                        curr.children[c] = next
                }</span>
                <span class="cov8" title="1">curr = next</span>
        }
        <span class="cov8" title="1">curr.isLeaf = true</span>
}

// Insert zero, one or more words at a Trie node.
func (n *Node) Insert(s ...string) <span class="cov8" title="1">{
        for _, ss := range s </span><span class="cov8" title="1">{
                n.insert(ss)
        }</span>
}

// Find  words at a Trie node.
func (n *Node) Find(s string) bool <span class="cov8" title="1">{
        next, ok := n, false
        for _, c := range s </span><span class="cov8" title="1">{
                next, ok = next.children[c]
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return next.isLeaf</span>
}

// Capacity returns the number of nodes in the Trie
func (n *Node) Capacity() int <span class="cov8" title="1">{
        r := 0
        for _, c := range n.children </span><span class="cov8" title="1">{
                r += c.Capacity()
        }</span>
        <span class="cov8" title="1">return 1 + r</span>
}

// Size returns the number of words in the Trie
func (n *Node) Size() int <span class="cov8" title="1">{
        r := 0
        for _, c := range n.children </span><span class="cov8" title="1">{
                r += c.Size()
        }</span>
        <span class="cov8" title="1">if n.isLeaf </span><span class="cov8" title="1">{
                r++
        }</span>
        <span class="cov8" title="1">return r</span>
}

// remove lazily a word from the Trie node, no node is actually removed.
func (n *Node) remove(s string) <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">next, ok := n, false
        for _, c := range s </span><span class="cov8" title="1">{
                next, ok = next.children[c]
                if !ok </span><span class="cov8" title="1">{
                        // word cannot be found - we're done !
                        return
                }</span>
        }
        <span class="cov8" title="1">next.isLeaf = false</span>
}

// Remove zero, one or more words lazily from the Trie, no node is actually removed.
func (n *Node) Remove(s ...string) <span class="cov8" title="1">{
        for _, ss := range s </span><span class="cov8" title="1">{
                n.remove(ss)
        }</span>
}

// Compact will remove unecessay nodes, reducing the capacity, returning true if node n itself should be removed.
func (n *Node) Compact() (remove bool) <span class="cov8" title="1">{

        for r, c := range n.children </span><span class="cov8" title="1">{
                if c.Compact() </span><span class="cov8" title="1">{
                        delete(n.children, r)
                }</span>
        }
        <span class="cov8" title="1">return !n.isLeaf &amp;&amp; len(n.children) == 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
